<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://markojs.com/"

    >marko (v4.2.8)</a>
</h1>
<h4>Marko is an extensible, streaming, asynchronous, high performance, HTML-based templating language that can be used in Node.js or in the browser.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko">module marko</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Builder">
            function <span class="apidocSignatureSpan">marko.</span>Builder
            <span class="apidocSignatureSpan">(elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.CodeGenerator">
            function <span class="apidocSignatureSpan">marko.</span>CodeGenerator
            <span class="apidocSignatureSpan">(context, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.CodeWriter">
            function <span class="apidocSignatureSpan">marko.</span>CodeWriter
            <span class="apidocSignatureSpan">(options, builder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.CompileContext">
            function <span class="apidocSignatureSpan">marko.</span>CompileContext
            <span class="apidocSignatureSpan">(src, filename, builder, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.CompileError">
            function <span class="apidocSignatureSpan">marko.</span>CompileError
            <span class="apidocSignatureSpan">(errorInfo, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Compiler">
            function <span class="apidocSignatureSpan">marko.</span>Compiler
            <span class="apidocSignatureSpan">(options, userOptions, inline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component">
            function <span class="apidocSignatureSpan">marko.</span>Component
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentDef">
            function <span class="apidocSignatureSpan">marko.</span>ComponentDef
            <span class="apidocSignatureSpan">(component, componentId, out, componentStack, componentStackLen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentsContext">
            function <span class="apidocSignatureSpan">marko.</span>ComponentsContext
            <span class="apidocSignatureSpan">(out, parentComponentsContext, shouldAddGlobalRoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.HtmlJsParser">
            function <span class="apidocSignatureSpan">marko.</span>HtmlJsParser
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.InlineCompiler">
            function <span class="apidocSignatureSpan">marko.</span>InlineCompiler
            <span class="apidocSignatureSpan">(context, compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Parser">
            function <span class="apidocSignatureSpan">marko.</span>Parser
            <span class="apidocSignatureSpan">(parserImpl, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult">
            function <span class="apidocSignatureSpan">marko.</span>RenderResult
            <span class="apidocSignatureSpan">(out)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.State">
            function <span class="apidocSignatureSpan">marko.</span>State
            <span class="apidocSignatureSpan">(component)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Walker">
            function <span class="apidocSignatureSpan">marko.</span>Walker
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.createOut">
            function <span class="apidocSignatureSpan">marko.</span>createOut
            <span class="apidocSignatureSpan">(globalData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.defineComponent">
            function <span class="apidocSignatureSpan">marko.</span>defineComponent
            <span class="apidocSignatureSpan">(def, renderer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.defineRenderer">
            function <span class="apidocSignatureSpan">marko.</span>defineRenderer
            <span class="apidocSignatureSpan">(def)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.dom_insert">
            function <span class="apidocSignatureSpan">marko.</span>dom_insert
            <span class="apidocSignatureSpan">(target, getEl, afterInsert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.empty">
            function <span class="apidocSignatureSpan">marko.</span>empty
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_forEachPropStatusVar">
            function <span class="apidocSignatureSpan">marko.</span>helper_forEachPropStatusVar
            <span class="apidocSignatureSpan">(object, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_forEachProperty">
            function <span class="apidocSignatureSpan">marko.</span>helper_forEachProperty
            <span class="apidocSignatureSpan">(o, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_forEachWithStatusVar">
            function <span class="apidocSignatureSpan">marko.</span>helper_forEachWithStatusVar
            <span class="apidocSignatureSpan">(array, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_forRange">
            function <span class="apidocSignatureSpan">marko.</span>helper_forRange
            <span class="apidocSignatureSpan">(from, to, step, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_loadNestedTag">
            function <span class="apidocSignatureSpan">marko.</span>helper_loadNestedTag
            <span class="apidocSignatureSpan">(targetProperty, isRepeated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_merge">
            function <span class="apidocSignatureSpan">marko.</span>helper_merge
            <span class="apidocSignatureSpan">(into, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_mergeNestedTags">
            function <span class="apidocSignatureSpan">marko.</span>helper_mergeNestedTags
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.load">
            function <span class="apidocSignatureSpan">marko.</span>load
            <span class="apidocSignatureSpan">(templatePath, templateSrc, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loadComponent">
            function <span class="apidocSignatureSpan">marko.</span>loadComponent
            <span class="apidocSignatureSpan">(typeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loadComponent_dynamic">
            function <span class="apidocSignatureSpan">marko.</span>loadComponent_dynamic
            <span class="apidocSignatureSpan">(typeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.nextRepeatedId">
            function <span class="apidocSignatureSpan">marko.</span>nextRepeatedId
            <span class="apidocSignatureSpan">(out, parentId, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.nextTick">
            function <span class="apidocSignatureSpan">marko.</span>nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.notEmpty">
            function <span class="apidocSignatureSpan">marko.</span>notEmpty
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ready">
            function <span class="apidocSignatureSpan">marko.</span>ready
            <span class="apidocSignatureSpan">(callback, thisObj, doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.renderable">
            function <span class="apidocSignatureSpan">marko.</span>renderable
            <span class="apidocSignatureSpan">(target, renderer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.renderer">
            function <span class="apidocSignatureSpan">marko.</span>renderer
            <span class="apidocSignatureSpan">(templateRenderFunc, componentProps, renderingLogic)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>Component.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>ComponentDef.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>ComponentsContext.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>RenderResult.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>State.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>event_delegation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>html</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>jquery</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>modules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>node_require</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>node_require_browser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>registry_browser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>specialElHandlers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>update_manager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>vdom</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.Builder">module marko.Builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Builder.Builder">
            function <span class="apidocSignatureSpan">marko.</span>Builder
            <span class="apidocSignatureSpan">(elements)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.Builder.</span>DEFAULT_BUILDER</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.CodeGenerator">module marko.CodeGenerator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.CodeGenerator.CodeGenerator">
            function <span class="apidocSignatureSpan">marko.</span>CodeGenerator
            <span class="apidocSignatureSpan">(context, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.CodeWriter">module marko.CodeWriter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.CodeWriter.CodeWriter">
            function <span class="apidocSignatureSpan">marko.</span>CodeWriter
            <span class="apidocSignatureSpan">(options, builder)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.CompileContext">module marko.CompileContext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.CompileContext.CompileContext">
            function <span class="apidocSignatureSpan">marko.</span>CompileContext
            <span class="apidocSignatureSpan">(src, filename, builder, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.CompileError">module marko.CompileError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.CompileError.CompileError">
            function <span class="apidocSignatureSpan">marko.</span>CompileError
            <span class="apidocSignatureSpan">(errorInfo, context)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.Compiler">module marko.Compiler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Compiler.Compiler">
            function <span class="apidocSignatureSpan">marko.</span>Compiler
            <span class="apidocSignatureSpan">(options, userOptions, inline)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.Component">module marko.Component</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.Component">
            function <span class="apidocSignatureSpan">marko.</span>Component
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.Component.prototype">module marko.Component.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.appendTo">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>appendTo
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.destroy">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.elId">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>elId
            <span class="apidocSignatureSpan">(componentElId, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.emit">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>emit
            <span class="apidocSignatureSpan">(eventType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.forceUpdate">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>forceUpdate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.getComponent">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getComponent
            <span class="apidocSignatureSpan">(id, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.getComponents">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getComponents
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.getEl">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getEl
            <span class="apidocSignatureSpan">(componentElId, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.getElId">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getElId
            <span class="apidocSignatureSpan">(componentElId, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.getEls">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getEls
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.insertAfter">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>insertAfter
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.insertBefore">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>insertBefore
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.isDestroyed">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>isDestroyed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.prependTo">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>prependTo
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.replace">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>replace
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.replaceChildrenOf">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>replaceChildrenOf
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.replaceState">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>replaceState
            <span class="apidocSignatureSpan">(newState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.setState">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>setState
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.setStateDirty">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>setStateDirty
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.shouldUpdate">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>shouldUpdate
            <span class="apidocSignatureSpan">(newState, newProps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.subscribeTo">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>subscribeTo
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.update">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>update
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.ComponentDef">module marko.ComponentDef</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentDef.ComponentDef">
            function <span class="apidocSignatureSpan">marko.</span>ComponentDef
            <span class="apidocSignatureSpan">(component, componentId, out, componentStack, componentStackLen)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.ComponentDef.prototype">module marko.ComponentDef.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentDef.prototype.d">
            function <span class="apidocSignatureSpan">marko.ComponentDef.prototype.</span>d
            <span class="apidocSignatureSpan">(handlerMethodName, extraArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentDef.prototype.e">
            function <span class="apidocSignatureSpan">marko.ComponentDef.prototype.</span>e
            <span class="apidocSignatureSpan">(type, targetMethod, elId, extraArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentDef.prototype.elId">
            function <span class="apidocSignatureSpan">marko.ComponentDef.prototype.</span>elId
            <span class="apidocSignatureSpan">(nestedId)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.ComponentsContext">module marko.ComponentsContext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentsContext.ComponentsContext">
            function <span class="apidocSignatureSpan">marko.</span>ComponentsContext
            <span class="apidocSignatureSpan">(out, parentComponentsContext, shouldAddGlobalRoot)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.ComponentsContext.prototype">module marko.ComponentsContext.prototype</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.HtmlJsParser">module marko.HtmlJsParser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.HtmlJsParser.HtmlJsParser">
            function <span class="apidocSignatureSpan">marko.</span>HtmlJsParser
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.InlineCompiler">module marko.InlineCompiler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.InlineCompiler.InlineCompiler">
            function <span class="apidocSignatureSpan">marko.</span>InlineCompiler
            <span class="apidocSignatureSpan">(context, compiler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.Parser">module marko.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Parser.Parser">
            function <span class="apidocSignatureSpan">marko.</span>Parser
            <span class="apidocSignatureSpan">(parserImpl, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.RenderResult">module marko.RenderResult</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.RenderResult">
            function <span class="apidocSignatureSpan">marko.</span>RenderResult
            <span class="apidocSignatureSpan">(out)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.RenderResult.prototype">module marko.RenderResult.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>document</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.afterInsert">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>afterInsert
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.appendTo">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>appendTo
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.getComponent">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.getComponents">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getComponents
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.getNode">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getNode
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.getOutput">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getOutput
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.insertAfter">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>insertAfter
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.insertBefore">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>insertBefore
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.prependTo">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>prependTo
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.replace">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>replace
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.replaceChildrenOf">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>replaceChildrenOf
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.toString">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.State">module marko.State</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.State.State">
            function <span class="apidocSignatureSpan">marko.</span>State
            <span class="apidocSignatureSpan">(component)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.State.prototype">module marko.State.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.State.prototype.toJSON">
            function <span class="apidocSignatureSpan">marko.State.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.Walker">module marko.Walker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Walker.Walker">
            function <span class="apidocSignatureSpan">marko.</span>Walker
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.createOut">module marko.createOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.createOut.createOut">
            function <span class="apidocSignatureSpan">marko.</span>createOut
            <span class="apidocSignatureSpan">(globalData)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.defineComponent">module marko.defineComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.defineComponent.defineComponent">
            function <span class="apidocSignatureSpan">marko.</span>defineComponent
            <span class="apidocSignatureSpan">(def, renderer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.defineRenderer">module marko.defineRenderer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.defineRenderer.defineRenderer">
            function <span class="apidocSignatureSpan">marko.</span>defineRenderer
            <span class="apidocSignatureSpan">(def)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.dom_insert">module marko.dom_insert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.dom_insert.dom_insert">
            function <span class="apidocSignatureSpan">marko.</span>dom_insert
            <span class="apidocSignatureSpan">(target, getEl, afterInsert)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.empty">module marko.empty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.empty.empty">
            function <span class="apidocSignatureSpan">marko.</span>empty
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.event_delegation">module marko.event_delegation</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.helper_forEachPropStatusVar">module marko.helper_forEachPropStatusVar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_forEachPropStatusVar.helper_forEachPropStatusVar">
            function <span class="apidocSignatureSpan">marko.</span>helper_forEachPropStatusVar
            <span class="apidocSignatureSpan">(object, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.helper_forEachProperty">module marko.helper_forEachProperty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_forEachProperty.helper_forEachProperty">
            function <span class="apidocSignatureSpan">marko.</span>helper_forEachProperty
            <span class="apidocSignatureSpan">(o, func)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.helper_forEachWithStatusVar">module marko.helper_forEachWithStatusVar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_forEachWithStatusVar.helper_forEachWithStatusVar">
            function <span class="apidocSignatureSpan">marko.</span>helper_forEachWithStatusVar
            <span class="apidocSignatureSpan">(array, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.helper_forRange">module marko.helper_forRange</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_forRange.helper_forRange">
            function <span class="apidocSignatureSpan">marko.</span>helper_forRange
            <span class="apidocSignatureSpan">(from, to, step, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.helper_loadNestedTag">module marko.helper_loadNestedTag</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_loadNestedTag.helper_loadNestedTag">
            function <span class="apidocSignatureSpan">marko.</span>helper_loadNestedTag
            <span class="apidocSignatureSpan">(targetProperty, isRepeated)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.helper_merge">module marko.helper_merge</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_merge.helper_merge">
            function <span class="apidocSignatureSpan">marko.</span>helper_merge
            <span class="apidocSignatureSpan">(into, source)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.helper_mergeNestedTags">module marko.helper_mergeNestedTags</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helper_mergeNestedTags.helper_mergeNestedTags">
            function <span class="apidocSignatureSpan">marko.</span>helper_mergeNestedTags
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.helpers">module marko.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helpers.cl">
            function <span class="apidocSignatureSpan">marko.helpers.</span>cl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helpers.f">
            function <span class="apidocSignatureSpan">marko.helpers.</span>f
            <span class="apidocSignatureSpan">(array, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helpers.s">
            function <span class="apidocSignatureSpan">marko.helpers.</span>s
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helpers.t">
            function <span class="apidocSignatureSpan">marko.helpers.</span>t
            <span class="apidocSignatureSpan">(renderer, targetProperty, isRepeated)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.html">module marko.html</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.html.AsyncStream">
            function <span class="apidocSignatureSpan">marko.html.</span>AsyncStream
            <span class="apidocSignatureSpan">(global, writer, state, shouldBuffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.html.Template">
            function <span class="apidocSignatureSpan">marko.html.</span>Template
            <span class="apidocSignatureSpan">(path, renderFunc, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.html.createWriter">
            function <span class="apidocSignatureSpan">marko.html.</span>createWriter
            <span class="apidocSignatureSpan">(writer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.html.enableAsyncStackTrace">
            function <span class="apidocSignatureSpan">marko.html.</span>enableAsyncStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.html.t">
            function <span class="apidocSignatureSpan">marko.html.</span>t
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.jquery">module marko.jquery</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.jquery.patchComponent">
            function <span class="apidocSignatureSpan">marko.jquery.</span>patchComponent
            <span class="apidocSignatureSpan">(jQuery)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.load">module marko.load</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.load.load">
            function <span class="apidocSignatureSpan">marko.</span>load
            <span class="apidocSignatureSpan">(templatePath, templateSrc, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.loadComponent">module marko.loadComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loadComponent.loadComponent">
            function <span class="apidocSignatureSpan">marko.</span>loadComponent
            <span class="apidocSignatureSpan">(typeName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.loadComponent_dynamic">module marko.loadComponent_dynamic</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loadComponent_dynamic.loadComponent_dynamic">
            function <span class="apidocSignatureSpan">marko.</span>loadComponent_dynamic
            <span class="apidocSignatureSpan">(typeName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.modules">module marko.modules</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.modules.deresolve">
            function <span class="apidocSignatureSpan">marko.modules.</span>deresolve
            <span class="apidocSignatureSpan">(targetFilename, from)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.modules.require">
            function <span class="apidocSignatureSpan">marko.modules.</span>require
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.modules.resolve">
            function <span class="apidocSignatureSpan">marko.modules.</span>resolve
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.modules.resolveFrom">
            function <span class="apidocSignatureSpan">marko.modules.</span>resolveFrom
            <span class="apidocSignatureSpan">(from, target)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.nextRepeatedId">module marko.nextRepeatedId</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.nextRepeatedId.nextRepeatedId">
            function <span class="apidocSignatureSpan">marko.</span>nextRepeatedId
            <span class="apidocSignatureSpan">(out, parentId, id)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.nextTick">module marko.nextTick</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.nextTick.nextTick">
            function <span class="apidocSignatureSpan">marko.</span>nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.node_require">module marko.node_require</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.node_require.getExtensions">
            function <span class="apidocSignatureSpan">marko.node_require.</span>getExtensions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.node_require.install">
            function <span class="apidocSignatureSpan">marko.node_require.</span>install
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.node_require_browser">module marko.node_require_browser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.node_require_browser.install">
            function <span class="apidocSignatureSpan">marko.node_require_browser.</span>install
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.notEmpty">module marko.notEmpty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.notEmpty.notEmpty">
            function <span class="apidocSignatureSpan">marko.</span>notEmpty
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.ready">module marko.ready</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ready.ready">
            function <span class="apidocSignatureSpan">marko.</span>ready
            <span class="apidocSignatureSpan">(callback, thisObj, doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ready.patchComponent">
            function <span class="apidocSignatureSpan">marko.ready.</span>patchComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.registry">module marko.registry</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.registry_browser">module marko.registry_browser</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.renderable">module marko.renderable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.renderable.renderable">
            function <span class="apidocSignatureSpan">marko.</span>renderable
            <span class="apidocSignatureSpan">(target, renderer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.renderer">module marko.renderer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.renderer.renderer">
            function <span class="apidocSignatureSpan">marko.</span>renderer
            <span class="apidocSignatureSpan">(templateRenderFunc, componentProps, renderingLogic)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.specialElHandlers">module marko.specialElHandlers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.specialElHandlers.INPUT">
            function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>INPUT
            <span class="apidocSignatureSpan">(fromEl, toEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.specialElHandlers.OPTION">
            function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>OPTION
            <span class="apidocSignatureSpan">(fromEl, toEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.specialElHandlers.SELECT">
            function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>SELECT
            <span class="apidocSignatureSpan">(fromEl, toEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.specialElHandlers.TEXTAREA">
            function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>TEXTAREA
            <span class="apidocSignatureSpan">(fromEl, toEl)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.update_manager">module marko.update_manager</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.util">module marko.util</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.vdom">module marko.vdom</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.vdom.Template">
            function <span class="apidocSignatureSpan">marko.vdom.</span>Template
            <span class="apidocSignatureSpan">(path, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.vdom.t">
            function <span class="apidocSignatureSpan">marko.vdom.</span>t
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko" id="apidoc.module.marko">module marko</a></h1>


    <h2>
        <a href="#apidoc.element.marko.Builder" id="apidoc.element.marko.Builder">
        function <span class="apidocSignatureSpan">marko.</span>Builder
        <span class="apidocSignatureSpan">(elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Builder {
    arrayExpression(elements) {
        if (elements) {
            if (!isArray(elements)) {
                elements = [elements];
            }

            for (var i=0; i&#x3c;elements.length; i++) {
                elements[i] = makeNode(elements[i]);
            }
        } else {
            elements = [];
        }

        return new ArrayExpression({elements});
    }

    assignment(left, right, operator) {
        if (operator == null) {
            operator = &#x27;=&#x27;;
        }
        left = makeNode(left);
        right = makeNode(right);
        return new Assignment({left, right, operator});
    }

    binaryExpression(left, operator, right) {
        left = makeNode(left);
        right = makeNode(right);
        return new BinaryExpression({left, operator, right});
    }

    sequenceExpression(expressions) {
        expressions = makeNode(expressions);
        return new SequenceExpression({expressions});
    }

    code(value) {
        return new Code({value});
    }

    computedMemberExpression(object, property) {
        object = makeNode(object);
        property = makeNode(property);
        let computed = true;

        return new MemberExpression({object, property, computed});
    }

    concat(args) {
        var prev;
        let operator = &#x27;+&#x27;;

        for (var i=1; i&#x3c;arguments.length; i++) {
            var left;
            var right = makeNode(arguments[i]);
            if (i === 1) {
                left = makeNode(arguments[i-1]);
            } else {
                left = prev;
            }

            prev = new BinaryExpression({left, operator, right});
        }

        return prev;
    }

    conditionalExpression(test, consequent, alternate) {
        return new ConditionalExpression({test, consequent, alternate});
    }

    containerNode(type, generateCode) {
        if (typeof type === &#x27;function&#x27;) {
            generateCode = arguments[0];
            type = &#x27;ContainerNode&#x27;;
        }

        var node = new ContainerNode(type);
        if (generateCode) {
            node.setCodeGenerator(generateCode);
        }
        return node;
    }

    customTag(el, tagDef) {
        return new CustomTag(el, tagDef);
    }

    declaration(declaration) {
        return new Declaration({declaration});
    }

    documentType(documentType) {
        return new DocumentType({documentType});
    }

    elseStatement(body) {
        return new Else({body});
    }

    elseIfStatement(test, body, elseStatement) {
        test = makeNode(test);

        return new ElseIf({test, body, else: elseStatement});
    }

    expression(value) {
        return new Expression({value});
    }

    forEach(varName, inExpression, body) {
        if (arguments.length === 1) {
            var def = arguments[0];
            return new ForEach(def);
        } else {
            varName = makeNode(varName);
            inExpression = makeNode(inExpression);
            return new ForEach({varName, in: inExpression, body});
        }
    }

    forEachProp(nameVarName, valueVarName, inExpression, body) {
        if (arguments.length === 1) {
            var def = arguments[0];
            return new ForEachProp(def);
        } else {
            nameVarName = makeNode(nameVarName);
            valueVarName = makeNode(valueVarName);
            inExpression = makeNode(inExpression);
            return new ForEachProp({nameVarName, valueVarName, in: inExpression, body});
        }
    }

    forRange(varName, from, to, step, body) {
        if (arguments.length === 1) {
            var def = arguments[0];
            return new ForRange(def);
        } else {
            varName = makeNode(varName);
            from = makeNode(from);
            to = makeNode(to);
            step = makeNode(step);
            body = makeNode(body);

            return new ForRange({varName, from, to, step, body});
        }
    }

    forStatement(init, test, update, body) {
        if (arguments.length === 1) {
            var def = arguments[0];
            return new ForStatement(def);
        } else { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.CodeGenerator" id="apidoc.element.marko.CodeGenerator">
        function <span class="apidocSignatureSpan">marko.</span>CodeGenerator
        <span class="apidocSignatureSpan">(context, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CodeGenerator {
    constructor(context, options) {
        options = options || {};
        this.root = null;

        this._code = &#x27;&#x27;;
        this.currentIndent = &#x27;&#x27;;
        this.inFunction = false;

        this._doneListeners = [];


        this.builder = context.builder;

        this.context = context;

        ok(this.builder, &#x27;&#x22;this.builder&#x22; is required&#x27;);

        this._codegenCodeMethodName = &#x27;generate&#x27; +
            context.outputType.toUpperCase() +
            &#x27;Code&#x27;;
    }

    addVar(name, value) {
        return this.context.addVar(name, value);
    }

    addStaticVar(name, value) {
        return this.context.addStaticVar(name, value);
    }

    addStaticCode(code) {
        this.context.addStaticCode(code);
    }

    addDependency(path, type, options) {
        this.context.addDependency(path, type, options);
    }

    pushMeta(key, value, unique) {
        this.context.pushMeta(key, value, unique);
    }

    setMeta(key, value) {
        this.context.setMeta(key, value);
    }

    getEscapeXmlAttrVar() {
        return this.context.getEscapeXmlAttrVar();
    }

    importModule(varName, path) {
        return this.context.importModule(varName, path);
    }

    _invokeCodeGenerator(func, node, isMethod) {
        try {
            if (isMethod) {
                return func.call(node, this);
            } else {
                return func.call(node, node, this);
            }
        } catch(err) {
            var errorMessage = &#x27;Generating code for &#x27;;

            if (node instanceof HtmlElement) {
                errorMessage += &#x27;&#x3c;&#x27;+node.tagName+&#x27;&#x3e; tag&#x27;;
            } else {
                errorMessage += node.type + &#x27; node&#x27;;
            }

            if (node.pos) {
                errorMessage += &#x27; (&#x27;+this.context.getPosInfo(node.pos)+&#x27;)&#x27;;
            }

            errorMessage += &#x27; failed. Error: &#x27; + err;

            throw createError(errorMessage, err /* cause */);
        }
    }

    _generateCode(node, finalNodes) {
        if (isArray(node)) {
            node.forEach((child) =&#x3e; {
                this._generateCode(child, finalNodes);
            });
            return;
        } else if (node instanceof Container) {
            node.forEach((child) =&#x3e; {
                if (child.container === node) {
                    this._generateCode(child, finalNodes);
                }
            });
            return;
        }

        if (node == null) {
            return;
        }

        if (typeof node === &#x27;string&#x27; || node._finalNode || !(node instanceof Node)) {
            finalNodes.push(node);
            return;
        }

        if (node._normalizeChildTextNodes) {
            node._normalizeChildTextNodes(this.context);
        }

        let oldCurrentNode = this._currentNode;
        this._currentNode = node;

        var beforeAfterEvent = new GeneratorEvent(node, this);

        var isWhitespacePreserved = node.isPreserveWhitespace();

        if (isWhitespacePreserved) {
            this.context.beginPreserveWhitespace();
        }

        beforeAfterEvent.isBefore = true;
        beforeAfterEvent.node.emit(&#x27;beforeGenerateCode&#x27;, beforeAfterEvent);
        this.context.emit(&#x27;beforeGenerateCode:&#x27; + beforeAfterEvent.node.type, beforeAfterEvent);
        this.context.emit(&#x27;beforeGenerateCode&#x27;, beforeAfterEvent);

        if (beforeAfterEvent.insertedNodes) {
            this._generateCode(beforeAfterEvent.insertedNodes, finalNodes);
            beforeAfterEvent.insertedNodes = null;
        }

        let codeGeneratorFunc;
        let generatedCode;

        if (node.getCodeGenerator) {
            codeGeneratorFunc = node.getCodeGenerator(this.outputType);

            if (codeGeneratorFunc) {
                node.setCodeGenerator(null);

                generatedCode = this._invokeCodeGenerator(codeGeneratorFunc, node, false);

                if (generatedCode === null) {
                    node = null;
                } else if (generatedCode !== undefined &#x26;&#x26; generatedCode !== node) {
                    node = null;
                    this._generateCode ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.CodeWriter" id="apidoc.element.marko.CodeWriter">
        function <span class="apidocSignatureSpan">marko.</span>CodeWriter
        <span class="apidocSignatureSpan">(options, builder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CodeWriter {
    constructor(options, builder) {
        ok(builder, &#x27;&#x22;builder&#x22; is required&#x27;);
        options = options || {};
        this.builder = builder;
        this.root = null;
        this._indentStr = options.indent != null ? options.indent : &#x27;  &#x27;;
        this._indentSize = this._indentStr.length;

        this._code = &#x27;&#x27;;
        this.currentIndent = &#x27;&#x27;;
    }

    getCode() {
        return this._code;
    }

    writeBlock(body) {
        if (!body) {
            this.write(&#x27;{}&#x27;);
            return;
        }

        if (typeof body === &#x27;function&#x27;) {
            body = body();
        }

        if (!body ||
            (Array.isArray(body) &#x26;&#x26; body.length === 0) ||
            (body instanceof Container &#x26;&#x26; body.length === 0)) {
            this.write(&#x27;{}&#x27;);
            return;
        }

        this.write(&#x27;{\n&#x27;)
            .incIndent();

        this.writeStatements(body);

        this.decIndent()
            .writeLineIndent()
            .write(&#x27;}&#x27;);
    }

    writeStatements(nodes) {
        if (!nodes) {
            return;
        }

        ok(nodes, &#x27;&#x22;nodes&#x22; expected&#x27;);
        let firstStatement = true;

        var writeNode = (node) =&#x3e; {
            if (Array.isArray(node) || (node instanceof Container)) {
                node.forEach(writeNode);
                return;
            } else {
                if (firstStatement) {
                    firstStatement = false;
                } else {
                    this._write(&#x27;\n&#x27;);
                }

                this.writeLineIndent();

                if (typeof node === &#x27;string&#x27;) {
                    this._write(node);
                } else {
                    node.statement = true;
                    this.write(node);
                }

                if (this._code.endsWith(&#x27;\n&#x27;)) {
                    // Do nothing
                } else if (this._code.endsWith(&#x27;;&#x27;)) {
                    this._code += &#x27;\n&#x27;;
                }  else if (this._code.endsWith(&#x27;\n&#x27; + this.currentIndent) || node instanceof Comment) {
                    // Do nothing
                } else {
                    this._code += &#x27;;\n&#x27;;
                }
            }
        };

        if (nodes instanceof Node) {
            writeNode(nodes);
        } else {
            nodes.forEach(writeNode);
        }
    }

    write(code) {
        if (code == null || code === &#x27;&#x27;) {
            return;
        }

        if (code instanceof Node) {
            let node = code;
            if (!node.writeCode) {
                throw new Error(&#x27;Node does not have a `writeCode` method: &#x27; + JSON.stringify(node, null, 4));
            }
            node.writeCode(this);
        } else if (isArray(code) || code instanceof Container) {
            code.forEach(this.write, this);
            return;
        } else if (typeof code === &#x27;string&#x27;) {
            this._code += code;
        }  else if (typeof code === &#x27;boolean&#x27; || typeof code === &#x27;number&#x27;) {
            this._code += code.toString();
        } else {
            throw new Error(&#x27;Illegal argument: &#x27; + JSON.stringify(code));
        }

        return this;
    }

    _write(code) {
        this._code += code;
        return this;
    }

    incIndent(count) {
        if (count != null) {
            for (let i=0; i&#x3c;count; i++) {
                this.currentIndent += &#x27; &#x27;;
            }
        } else {
            this.currentIndent += this._indentStr;
        }

        return this;
    }

    decIndent(count) {
        if (count == null) {
            count = this._indentSize;
        }

        this.currentIndent = this.currentIndent.substring(
            0,
            this.currentIndent.length - count);

        return this;
    }

    writeLineIndent() {
        this._code += this.currentIndent;
        return this;
    }

    writeIndent() {
        this._code += this._indentStr;
        return this;
    }

    isLiteralNode(node) {
        return node instanceof Literal;
    }

    isIdentifierNode(node) {
        return node instanceof Identifier;
    }

    writeLiteral(value) {
        if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.CompileContext" id="apidoc.element.marko.CompileContext">
        function <span class="apidocSignatureSpan">marko.</span>CompileContext
        <span class="apidocSignatureSpan">(src, filename, builder, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CompileContext extends EventEmitter {
    constructor(src, filename, builder, options) {
        super();
        ok(typeof src === &#x27;string&#x27;, &#x27;&#x22;src&#x22; string is required&#x27;);
        ok(filename, &#x27;&#x22;filename&#x22; is required&#x27;);

        this.src = src;
        this.filename = filename;
        this.builder = builder;

        this.dirname = path.dirname(filename);
        this.taglibLookup = taglibLookup.buildLookup(this.dirname);
        this.data = {};
        this._dataStacks = {};
        this.meta = {};

        this.options = options || {};

        const writeVersionComment = this.options.writeVersionComment;

        this.outputType = this.options.output || &#x27;html&#x27;;
        this.compilerType = this.options.compilerType || &#x27;marko&#x27;;
        this.compilerVersion = this.options.compilerVersion || markoPkgVersion;
        this.writeVersionComment = writeVersionComment !== &#x27;undefined&#x27; ? writeVersionComment : true;

        this._vars = {};
        this._uniqueVars = new UniqueVars();
        this._staticVars = {};
        this._staticCode = null;
        this._uniqueStaticVars = new UniqueVars();
        this._srcCharProps = null;
        this._flags = {};
        this._errors = [];
        this._macros = null;
        this._preserveWhitespace = null;
        this._preserveComments = null;
        this.inline = this.options.inline === true;
        this.useMeta = this.options.meta !== false;
        this._moduleRuntimeTarget = this.outputType === &#x27;vdom&#x27; ? &#x27;marko/vdom&#x27; : &#x27;marko/html&#x27;;
        this.unrecognizedTags = [];
        this._parsingFinished = false;

        this._helpersIdentifier = null;

        if (this.options.preserveWhitespace) {
            this.setPreserveWhitespace(true);
        }

        this._helpers = {};
        this._imports = {};
        this._fingerprint = undefined;
        this._optimizers = undefined;
    }

    setInline(isInline) {
        this.inline = isInline === true;
    }

    getPosInfo(pos) {
        var srcCharProps = this._srcCharProps || (this._srcCharProps = charProps(this.src));
        let line = srcCharProps.lineAt(pos)+1;
        let column = srcCharProps.columnAt(pos);
        return new PosInfo(this.filename, line, column);
    }

    getNodePos(node) {
        if (node.pos) {
            return this.getPosInfo(node.pos);
        } else {
            return new PosInfo(this.filename);
        }
    }

    setFlag(name) {
        this.pushFlag(name);
    }

    clearFlag(name) {
        delete this._flags[name];
    }

    isFlagSet(name) {
        return this._flags.hasOwnProperty(name);
    }

    pushFlag(name) {
        if (this._flags.hasOwnProperty(name)) {
            this._flags[name]++;
        } else {
            this._flags[name] = 1;
        }
    }

    popFlag(name) {
        if (!this._flags.hasOwnProperty(name)) {
            throw new Error(&#x27;popFlag() called for &#x22;&#x27; + name + &#x27;&#x22; when flag was not set&#x27;);
        }

        if (--this._flags[name] === 0) {
            delete this._flags[name];
        }
    }

    pushData(key, data) {
        var dataStack = this._dataStacks[key];
        if (!dataStack) {
            dataStack = this._dataStacks[key] = [];
        }

        dataStack.push(data);

        return {
            pop: () =&#x3e; {
                this.popData(key);
            }
        };
    }

    popData(key) {
        var dataStack = this._dataStacks[key];

        if (!dataStack || dataStack.length === 0) {
            throw new Error(&#x27;No data pushed for &#x22;&#x27; + key + &#x27;&#x22;&#x27;);
        }

        dataStack.pop();

        if (dataStack.length === 0) {
            delete this.data[key];
        }
    }

    getData(name) {
        var dataStack = this._dataStacks[name];
        if (dataStack) {
            return dataStack[dataStack.length - 1];
        }

        return this.data[name];
    }

    deprecate(message, node) {
        var currentNode = node || this._currentNode;
        var location = currentNode &#x26;&#x26; currentNode.pos;

        if (location != null) {
            location = this.getPosInfo(location).toString();
        }

        complain(me ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.CompileError" id="apidoc.element.marko.CompileError">
        function <span class="apidocSignatureSpan">marko.</span>CompileError
        <span class="apidocSignatureSpan">(errorInfo, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CompileError {
    constructor(errorInfo, context) {
        this.context = context;
        this.node = errorInfo.node;
        this.message = errorInfo.message;
        this.code = errorInfo.code;

        var pos = errorInfo.pos;
        var endPos = errorInfo.endPos;

        if (pos == null) {
            pos = this.node &#x26;&#x26; this.node.pos;
        }

        if (endPos == null) {
            endPos = this.node &#x26;&#x26; this.node.endPos;
        }

        if (pos != null) {
            pos = context.getPosInfo(pos);
        }

        if (endPos != null) {
            endPos = context.getPosInfo(endPos);
        }

        this.pos = pos;
        this.endPos = endPos;
    }

    toString() {
        var pos = this.pos;
        if (pos) {
            pos = &#x27;[&#x27; + pos + &#x27;] &#x27;;
        } else {
            pos = &#x27;&#x27;;
        }
        var str = pos + this.message;
        if (pos == null &#x26;&#x26; this.node) {
            str += &#x27; (&#x27; + this.node.toString() + &#x27;)&#x27;;
        }
        return str;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Compiler" id="apidoc.element.marko.Compiler">
        function <span class="apidocSignatureSpan">marko.</span>Compiler
        <span class="apidocSignatureSpan">(options, userOptions, inline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Compiler {
    constructor(options, userOptions, inline) {
        ok(options, &#x27;&#x22;options&#x22; is required&#x27;);

        this.builder = options.builder;
        this.parser = options.parser;

        ok(this.builder, &#x27;&#x22;options.builder&#x22; is required&#x27;);
        ok(this.parser, &#x27;&#x22;options.parser&#x22; is required&#x27;);
    }

    compile(src, context) {
        ok(typeof src === &#x27;string&#x27;, &#x27;&#x22;src&#x22; argument should be a string&#x27;);

        var codeGenerator = new CodeGenerator(context);

        // STAGE 1: Parse the template to produce the initial AST
        var ast = this.parser.parse(src, context);
        context._parsingFinished = true;

        if (context.unrecognizedTags) {
            for(let i=0; i&#x3c;context.unrecognizedTags.length; i++) {
                let unrecognizedTag = context.unrecognizedTags[i];
                // See if the tag is a macro
                if (!context.isMacro(unrecognizedTag.tagName)) {
                    context.addErrorUnrecognizedTag(unrecognizedTag.tagName, unrecognizedTag.node);
                }
            }
        }

        handleErrors(context);

        context.root = ast;
        // console.log(&#x27;ROOT&#x27;, JSON.stringify(ast, null, 2));

        // STAGE 2: Transform the initial AST to produce the final AST
        var transformedAST = transformTree(ast, context);
        // console.log(&#x27;transformedAST&#x27;, JSON.stringify(ast, null, 2));

        handleErrors(context);

        var finalAST = codeGenerator.generateCode(transformedAST);

        handleErrors(context);

        return new CompiledTemplate(finalAST, context);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component" id="apidoc.element.marko.Component">
        function <span class="apidocSignatureSpan">marko.</span>Component
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Component(id) {
    EventEmitter.call(this);
    this.id = id;
    this.el = null;
    this.$__state = null;
    this.$__roots = null;
    this.$__subscriptions = null;
    this.$__domEventListenerHandles = null;
    this.$__bubblingDomEvents = null;
    this.$__customEvents = null;
    this.$__scope = null;
    this.$__renderInput = null;
    this.$__input = undefined;

    this.$__destroyed = false;
    this.$__updateQueued = false;
    this.$__dirty = false;
    this.$__settingInput = false;

    this.$__document = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.ComponentDef" id="apidoc.element.marko.ComponentDef">
        function <span class="apidocSignatureSpan">marko.</span>ComponentDef
        <span class="apidocSignatureSpan">(component, componentId, out, componentStack, componentStackLen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ComponentDef(component, componentId, out, componentStack, componentStackLen) {
    this.$__out = out; // The AsyncWriter that this component is associated with
    this.$__componentStack = componentStack;
    this.$__componentStackLen = componentStackLen;
    this.$__component = component;
    this.id = componentId;

    this.$__roots =  null;            // IDs of root elements if there are multiple root elements
    this.$__children = null;          // An array of nested ComponentDef instances
    this.$__domEvents = null;         // An array of DOM events that need to be added (in sets of three)
    this.$__bubblingDomEvents = null; // Used to keep track of bubbling DOM events for components rendered on the server

    this.$__isExisting = false;

    this.$__nextIdIndex = 0; // The unique integer to use for the next scoped ID
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.ComponentsContext" id="apidoc.element.marko.ComponentsContext">
        function <span class="apidocSignatureSpan">marko.</span>ComponentsContext
        <span class="apidocSignatureSpan">(out, parentComponentsContext, shouldAddGlobalRoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ComponentsContext(out, parentComponentsContext, shouldAddGlobalRoot) {
    var root;

    var globalComponentsContext;

    if (parentComponentsContext === undefined) {
        root = new ComponentDef(null, null, out);

        globalComponentsContext = out.global.components;
        if (globalComponentsContext === undefined) {
            out.global.components = globalComponentsContext = new GlobalComponentsContext(out);
        }

        if (shouldAddGlobalRoot !== false) {
            globalComponentsContext.$__roots.push(root);
        }
    } else {
        globalComponentsContext = parentComponentsContext.$__globalContext;
        var parentComponentStack = parentComponentsContext.$__componentStack;
        root = parentComponentStack[parentComponentStack.length-1];
    }

    this.$__globalContext = globalComponentsContext;
    this.$__out = out;
    this.$__componentStack = [root];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.HtmlJsParser" id="apidoc.element.marko.HtmlJsParser">
        function <span class="apidocSignatureSpan">marko.</span>HtmlJsParser
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class HtmlJsParser {
    constructor(options) {
        this.ignorePlaceholders = options &#x26;&#x26; options.ignorePlaceholders === true;
    }

    parse(src, handlers, filename) {
        var listeners = {
            onText(event) {
                handlers.handleCharacters(event.value, event.parseMode);
            },

            onPlaceholder(event) {
                if (event.withinBody) {
                    if (!event.withinString) {
                        handlers.handleBodyTextPlaceholder(event.value, event.escape);
                    }
                } else if (event.withinOpenTag) {
                    // Don&#x27;t escape placeholder for dynamic attributes. For example: &#x3c;div ${data.myAttrs}&#x3e;&#x3c;/div&#x3e;
                } else {
                    // placeholder within attribute
                    if (event.escape) {
                        event.value = &#x27;$escapeXml(&#x27; + event.value + &#x27;)&#x27;;
                    } else {
                        event.value = &#x27;$noEscapeXml(&#x27; + event.value + &#x27;)&#x27;;
                    }
                }
                // placeholder within content

            },

            onCDATA(event) {
                handlers.handleCharacters(event.value, &#x27;static-text&#x27;);
            },

            onOpenTagName(event, parser) {
                event.selfClosed = false; // Don&#x27;t allow self-closed tags

                var tagParseOptions = handlers.getTagParseOptions(event);

                if (tagParseOptions) {
                    event.setParseOptions(tagParseOptions);
                }
            },

            onOpenTag(event, parser) {
                event.selfClosed = false; // Don&#x27;t allow self-closed tags
                handlers.handleStartElement(event, parser);

                var tagParseOptions = handlers.getTagParseOptions(event);
                if (tagParseOptions) {
                    event.setParseOptions(tagParseOptions);
                }
            },

            onCloseTag(event) {
                var tagName = event.tagName;
                handlers.handleEndElement(tagName);
            },

            onDocumentType(event) {

                // Document type: &#x3c;!DOCTYPE html PUBLIC &#x22;-//W3C//DTD XHTML 1.0 Transitional//EN&#x22; &#x22;http://www.w3.org/TR/xhtml1/DTD
/xhtml1-transitional.dtd
                // NOTE: The value will be all of the text between &#x22;&#x3c;!&#x22; and &#x22;&#x3e;&#x22;&#x22;
                handlers.handleDocumentType(event.value);
            },

            onDeclaration(event) {
                handlers.handleDeclaration(event.value);
            },

            onComment(event) {
                // Text within XML comment
                handlers.handleComment(event.value);
            },

            onScriptlet(event) {
                // &#x3c;% (code) %&#x3e; or $ {}
                handlers.handleScriptlet(event);
            },

            onError(event) {
                handlers.handleError(event);
            }
        };

        var parser = this.parser = htmljs.createParser(listeners, {
            ignorePlaceholders: this.ignorePlaceholders,
            isOpenTagOnly: function(tagName) {
                return handlers.isOpenTagOnly(tagName);
            }
        });
        parser.parse(src, filename);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.InlineCompiler" id="apidoc.element.marko.InlineCompiler">
        function <span class="apidocSignatureSpan">marko.</span>InlineCompiler
        <span class="apidocSignatureSpan">(context, compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineCompiler {
    constructor(context, compiler) {
        this.context = context;
        this.compiler = compiler;
        this.builder = context.builder;

        context.setInline(true);
    }

    compile(src) {
        src = normalizeTemplateSrc(src);
        // console.log(&#x27;TEMPLATE SRC:&#x3e;\n&#x27; + src + &#x27;\n&#x3c;&#x27;);
        return this.compiler.compile(src, this.context);
    }

    get staticCode() {
        let staticNodes = this.context.getStaticNodes();

        if (!staticNodes || staticNodes.length === 0) {
            return null;
        }

        let codeWriter = new CodeWriter(this.context.options, this.builder);
        codeWriter.write(staticNodes);
        return codeWriter.getCode();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Parser" id="apidoc.element.marko.Parser">
        function <span class="apidocSignatureSpan">marko.</span>Parser
        <span class="apidocSignatureSpan">(parserImpl, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Parser {
    constructor(parserImpl, options) {
        ok(parserImpl, &#x27;&#x22;parserImpl&#x22; is required&#x27;);

        this.parserImpl = parserImpl;

        this.prevTextNode = null;
        this.stack = null;

        this.raw = options &#x26;&#x26; options.raw === true;

        // The context gets provided when parse is called
        // but we store it as part of the object so that the handler
        // methods have access
        this.context = null;
    }

    _reset() {
        this.prevTextNode = null;
        this.stack = [];
    }

    parse(src, context) {
        ok(typeof src === &#x27;string&#x27;, &#x27;&#x22;src&#x22; should be a string&#x27;);
        ok(context, &#x27;&#x22;context&#x22; is required&#x27;);

        this._reset();

        this.context = context;

        var builder = context.builder;
        var rootNode = builder.templateRoot();

        this.stack.push({
            node: rootNode
        });

        this.parserImpl.parse(src, this, context.filename);

        return rootNode;
    }

    handleCharacters(text, parseMode) {
        var builder = this.context.builder;

        var escape = parseMode !== &#x27;html&#x27;;
        // NOTE: If parseMode is &#x27;static-text&#x27; or &#x27;parsed-text&#x27; then that means that special
        //       HTML characters may not have been escaped on the way in so we need to escape
        //       them on the way out

        if (this.prevTextNode &#x26;&#x26; this.prevTextNode.isLiteral() &#x26;&#x26; this.prevTextNode.escape === escape) {
            this.prevTextNode.argument.value += text;
        } else {
            this.prevTextNode = builder.text(builder.literal(text), escape);
            this.parentNode.appendChild(this.prevTextNode);
        }
    }

    handleStartElement(el, parser) {
        var context = this.context;
        var builder = context.builder;

        var tagName = el.tagName;
        var tagNameExpression = el.tagNameExpression;
        var attributes = el.attributes;
        var argument = el.argument; // e.g. For &#x3c;for(color in colors)&#x3e;, argument will be &#x22;color in colors&#x22;

        if (argument) {
            argument = argument.value;
        }

        var raw = this.raw;

        if (!raw) {
            if (tagNameExpression) {
                tagName = builder.parseExpression(tagNameExpression);
            } else if (tagName === &#x27;marko-compiler-options&#x27;) {
                this.parentNode.setTrimStartEnd(true);

                attributes.forEach(function (attr) {
                    let attrName = attr.name;
                    let handler = COMPILER_ATTRIBUTE_HANDLERS[attrName];

                    if (!handler) {
                        context.addError({
                            code: &#x27;ERR_INVALID_COMPILER_OPTION&#x27;,
                            message: &#x27;Invalid Marko compiler option of &#x22;&#x27; + attrName + &#x27;&#x22;. Allowed: &#x27; + Object.keys(COMPILER_ATTRIBUTE_HANDLERS
).join(&#x27;, &#x27;),
                            pos: el.pos,
                            node: el
                        });
                        return;
                    }

                    handler(attr, context);
                });

                return;
            }
        }

        this.prevTextNode = null;

        var tagDef = el.tagName ? this.context.getTagDef(el.tagName) : null;

        var attributeParseErrors = [];
        // &#x3c;div class=&#x22;foo&#x22;&#x3e; -&#x3e; &#x22;div class=foo&#x22;
        var tagString = parser.substring(el.pos, el.endPos)
                              .replace(/^&#x3c;|\/&#x3e;$|&#x3e;$/g, &#x22;&#x22;).trim();

        var shouldParsedAttributes = !tagDef || tagDef.parseAttributes !== false;

        var parsedAttributes = [];

        if (shouldParsedAttributes) {
            attributes.forEach((attr) =&#x3e; {
                var attrValue;
                if (attr.hasOwnProperty(&#x27;literalValue&#x27;)) {
                    attrValue = builder.literal(attr.literalValue);
                } else if (attr.value == null) {
                    attrValue = undefined;
                } else {
                    let parsedExpression;
                    let valid = true;
                    try {
                        parsedExpression = builder.parseExpression(attr.value); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult" id="apidoc.element.marko.RenderResult">
        function <span class="apidocSignatureSpan">marko.</span>RenderResult
        <span class="apidocSignatureSpan">(out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RenderResult(out) {
   this.out = this.$__out = out;
   this.$__components = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.State" id="apidoc.element.marko.State">
        function <span class="apidocSignatureSpan">marko.</span>State
        <span class="apidocSignatureSpan">(component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function State(component) {
    this.$__component = component;
    this.$__raw = {};

    this.$__dirty = false;
    this.$__old = null;
    this.$__changes = null;
    this.$__forced = null; // An object that we use to keep tracking of state properties that were forced to be dirty

    Object.seal(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Walker" id="apidoc.element.marko.Walker">
        function <span class="apidocSignatureSpan">marko.</span>Walker
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Walker {
    constructor(options) {
        this._enter = options.enter || noop;
        this._exit = options.exit || noop;
        this._enterArray = options.enterArray || noop;
        this._exitArray = options.exitArray || noop;
        this._stopped = false;
        this._reset();
        this._stack = [];
    }

    _reset() {
        this._skipped = false;
        this._replaced = undefined;
        this._removed = false;
    }

    skip() {
        this._skipped = true;
    }

    stop() {
        this._stopped = true;
    }

    replace(newNode) {
        this._replaced = newNode;
    }

    remove() {
        this._removed = true;
    }

    _walkArray(array) {
        var hasRemoval = false;

        array = this._enterArray(array) || array;

        array.forEach((node, i) =&#x3e; {
            var transformed = this.walk(node);
            if (transformed == null) {
                array[i] = null;
                hasRemoval = true;
            } else if (transformed !== node) {
                array[i] = transformed;
            }
        });

        if (hasRemoval) {
            for (let i=array.length-1; i&#x3e;=0; i--) {
                if (array[i] == null) {
                    array.splice(i, 1);
                }
            }
        }

        array = this._exitArray(array) || array;

        return array;
    }

    _walkContainer(nodes) {
        nodes.forEach((node) =&#x3e; {
            var transformed = this.walk(node);
            if (!transformed) {
                node.container.removeChild(node);
            } else if (transformed !== node) {
                node.container.replaceChild(transformed, node);
            }
        });
    }

    walk(node) {
        if (!node || this._stopped || typeof node === &#x27;string&#x27;) {
            return node;
        }

        this._reset();

        var parent = this._stack.length ? this._stack[this._stack.length - 1] : undefined;

        this._stack.push(node);

        var replaced = this._enter(node, parent);
        if (replaced === undefined) {
            replaced = this._replaced;
        }

        if (this._removed) {
            replaced = null;
        }

        if (replaced !== undefined) {
            this._stack.pop();
            return replaced;
        }

        if (this._skipped || this._stopped) {
            this._stack.pop();
            return node;
        }

        if (isArray(node)) {
            let array = node;
            let newArray = this._walkArray(array);
            this._stack.pop();
            return newArray;
        } else if (node instanceof Container) {
            let container = node;
            this._walkContainer(container);
            this._stack.pop();
            return container;
        } else {
            if (node.walk) {
                node.walk(this);
            }
        }

        if (this._stopped) {
            this._stack.pop();
            return node;
        }

        this._reset();

        replaced = this._exit(node, parent);
        if (replaced === undefined) {
            replaced = this._replaced;
        }

        if (this._removed) {
            replaced = null;
        }

        if (replaced !== undefined) {
            this._stack.pop();
            return replaced;
        }

        this._stack.pop();
        return node;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.createOut" id="apidoc.element.marko.createOut">
        function <span class="apidocSignatureSpan">marko.</span>createOut
        <span class="apidocSignatureSpan">(globalData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createOut(globalData) {
    return actualCreateOut(globalData);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.defineComponent" id="apidoc.element.marko.defineComponent">
        function <span class="apidocSignatureSpan">marko.</span>defineComponent
        <span class="apidocSignatureSpan">(def, renderer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineComponent(def, renderer) {
    if (def.$__isComponent) {
        return def;
    }

    var ComponentClass = function() {};
    var proto;

    var type = typeof def;

    if (type == &#x27;function&#x27;) {
        proto = def.prototype;
    } else if (type == &#x27;object&#x27;) {
        proto = def;
    } else {
        throw TypeError();
    }

    ComponentClass.prototype = proto;

    // We don&#x27;t use the constructor provided by the user
    // since we don&#x27;t invoke their constructor until
    // we have had a chance to do our own initialization.
    // Instead, we store their constructor in the &#x22;initComponent&#x22;
    // property and that method gets called later inside
    // init-components-browser.js
    function Component(id) {
        BaseComponent.call(this, id);
    }

    if (!proto.$__isComponent) {
        // Inherit from Component if they didn&#x27;t already
        inherit(ComponentClass, BaseComponent);
    }

    // The same prototype will be used by our constructor after
    // we he have set up the prototype chain using the inherit function
    proto = Component.prototype = ComponentClass.prototype;

    // proto.constructor = def.constructor = Component;

    // Set a flag on the constructor function to make it clear this is
    // a component so that we can short-circuit this work later
    Component.$__isComponent = true;

    function State(component) { BaseState.call(this, component); }
    inherit(State, BaseState);
    proto.$__State = State;
    proto.$__renderer = renderer;

    return Component;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.defineRenderer" id="apidoc.element.marko.defineRenderer">
        function <span class="apidocSignatureSpan">marko.</span>defineRenderer
        <span class="apidocSignatureSpan">(def)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineRenderer(def) {
    var template = def.template;
    var getTemplateData = def.getTemplateData;
    var renderer = def.renderer;

    if (typeof template === &#x27;string&#x27;) {
        template = marko.load(template);
    }

    var createOut;

    if (template) {
        createOut = template.createOut;
    } else {
        createOut = def.createOut || marko.createOut;
    }

    if (!renderer) {
        // Create a renderer function that takes care of translating
        // the input properties to a view state. Also, this renderer
        // takes care of re-using existing components.
        renderer = function renderer(input, out) {
            var newProps = input;

            if (!newProps) {
                // Make sure we always have a non-null input object
                newProps = {};
            }

            // Use getTemplateData(state, props, out) to get the template
            // data. If that method is not provided then just use the
            // the state (if provided) or the input data.
            var templateData = getTemplateData ?
                getTemplateData(newProps, out) :
                newProps;

            // Render the template associated with the component using the final template
            // data that we constructed
            template.render(templateData, out);
        };
    }

    renderer.render = function(input) {
        var out = createOut();
        renderer(input, out);
        return out.end();
    };

    return renderer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.dom_insert" id="apidoc.element.marko.dom_insert">
        function <span class="apidocSignatureSpan">marko.</span>dom_insert
        <span class="apidocSignatureSpan">(target, getEl, afterInsert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dom_insert = function (target, getEl, afterInsert) {
    extend(target, {
        appendTo: function(referenceEl) {
            referenceEl = resolveEl(referenceEl);
            var el = getEl(this, referenceEl);
            referenceEl.appendChild(el);
            return afterInsert(this, referenceEl);
        },
        prependTo: function(referenceEl) {
            referenceEl = resolveEl(referenceEl);
            var el = getEl(this, referenceEl);
            referenceEl.insertBefore(el, referenceEl.firstChild || null);
            return afterInsert(this, referenceEl);
        },
        replace: function(referenceEl) {
            referenceEl = resolveEl(referenceEl);
            var el = getEl(this, referenceEl);
            beforeRemove(referenceEl);
            referenceEl.parentNode.replaceChild(el, referenceEl);
            return afterInsert(this, referenceEl);
        },
        replaceChildrenOf: function(referenceEl) {
            referenceEl = resolveEl(referenceEl);
            var el = getEl(this, referenceEl);

            var curChild = referenceEl.firstChild;
            while(curChild) {
                var nextSibling = curChild.nextSibling; // Just in case the DOM changes while removing
                if (curChild.nodeType == 1) {
                    beforeRemove(curChild);
                }
                curChild = nextSibling;
            }

            referenceEl.innerHTML = &#x27;&#x27;;
            referenceEl.appendChild(el);
            return afterInsert(this, referenceEl);
        },
        insertBefore: function(referenceEl) {
            referenceEl = resolveEl(referenceEl);
            var el = getEl(this, referenceEl);
            referenceEl.parentNode.insertBefore(el, referenceEl);
            return afterInsert(this, referenceEl);
        },
        insertAfter: function(referenceEl) {
            referenceEl = resolveEl(referenceEl);
            var el = getEl(this, referenceEl);
            el = el;
            var nextSibling = referenceEl.nextSibling;
            var parentNode = referenceEl.parentNode;
            if (nextSibling) {
                parentNode.insertBefore(el, nextSibling);
            } else {
                parentNode.appendChild(el);
            }
            return afterInsert(this, referenceEl);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.empty" id="apidoc.element.marko.empty">
        function <span class="apidocSignatureSpan">marko.</span>empty
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function (o) {
    return !notEmpty(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helper_forEachPropStatusVar" id="apidoc.element.marko.helper_forEachPropStatusVar">
        function <span class="apidocSignatureSpan">marko.</span>helper_forEachPropStatusVar
        <span class="apidocSignatureSpan">(object, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachPropStatusVarHelper(object, callback) {
    var keys = Object.keys(object);

    var i = 0;
    var len = keys.length;
    var loopStatus = new LoopStatus(
            function getLength() {
                return len;
            },
            function isLast() {
                return i === len - 1;
            },
            function isFirst() {
                return i === 0;
            },
            function getIndex() {
                return i;
            });

    for (; i &#x3c; len; i++) {
        var key = keys[i];
        var value = object[key];
        callback(key, value, loopStatus);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helper_forEachProperty" id="apidoc.element.marko.helper_forEachProperty">
        function <span class="apidocSignatureSpan">marko.</span>helper_forEachProperty
        <span class="apidocSignatureSpan">(o, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachPropertyHelper(o, func) {
    if (!o) {
        return;
    }

    if (isArray(o)) {
        for (var i=0; i&#x3c;o.length; i++) {
            func(i, o[i]);
        }
    } else if (typeof Map &#x26;&#x26; o instanceof Map) {
        o.forEach(function(v, k) {
            func(k, v);
        });
    } else {
        for (var k in o) {
            if (o.hasOwnProperty(k)) {
                func(k, o[k]);
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helper_forEachWithStatusVar" id="apidoc.element.marko.helper_forEachWithStatusVar">
        function <span class="apidocSignatureSpan">marko.</span>helper_forEachWithStatusVar
        <span class="apidocSignatureSpan">(array, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachStatusVariableHelper(array, callback) {
    if (!array) {
        return;
    }
    if (!array.forEach) {
        array = [array];
    }

    var len = array.length;
    var loopStatus = new LoopStatus(len);

    for (; loopStatus.i &#x3c; len; loopStatus.i++) {
        var o = array[loopStatus.i];
        callback(o, loopStatus);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helper_forRange" id="apidoc.element.marko.helper_forRange">
        function <span class="apidocSignatureSpan">marko.</span>helper_forRange
        <span class="apidocSignatureSpan">(from, to, step, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forRangeHelper(from, to, step, callback) {
    if (step == null) {
        step = from &#x3c;= to ? 1 : -1;
    }

    var i;

    if (step &#x3e; 0) {
        for (i=from; i&#x3c;=to; i += step) {
            callback(i);
        }
    } else {
        for (i=from; i&#x3e;=to; i += step) {
            callback(i);
        }
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helper_loadNestedTag" id="apidoc.element.marko.helper_loadNestedTag">
        function <span class="apidocSignatureSpan">marko.</span>helper_loadNestedTag
        <span class="apidocSignatureSpan">(targetProperty, isRepeated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadNestedTagHelper(targetProperty, isRepeated) {
    return function(input, parent) {
        // If we are nested tag then we do not have a renderer
        if (isRepeated) {
            var existingArray = parent[targetProperty];
            if (existingArray) {
                existingArray.push(input);
            } else {
                parent[targetProperty] = [input];
            }
        } else {
            parent[targetProperty] = input;
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helper_merge" id="apidoc.element.marko.helper_merge">
        function <span class="apidocSignatureSpan">marko.</span>helper_merge
        <span class="apidocSignatureSpan">(into, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(into, source) {
    for (var k in source) {
        if (source.hasOwnProperty(k) &#x26;&#x26; !into.hasOwnProperty(k)) {
            into[k] = source[k];
        }
    }
    return into;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helper_mergeNestedTags" id="apidoc.element.marko.helper_mergeNestedTags">
        function <span class="apidocSignatureSpan">marko.</span>helper_mergeNestedTags
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeNestedTags(input) {
    if (input.renderBody) {
        input.renderBody(null, input);
    }
    input.renderBody = null;
    return input;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.load" id="apidoc.element.marko.load">
        function <span class="apidocSignatureSpan">marko.</span>load
        <span class="apidocSignatureSpan">(templatePath, templateSrc, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(templatePath, templateSrc, options) {
    if (typeof templatePath === &#x27;string&#x27; &#x26;&#x26; nodePath.extname(templatePath) === &#x27;.js&#x27;) {
        // assume compiled template
        return require(templatePath);
    }

    if (arguments.length === 1) {
        return doLoad(templatePath);
    } else if (arguments.length === 2) {
        // see if second argument is templateSrc (a String)
        // or options (an Object)
        var lastArg = arguments[arguments.length - 1];
        if (typeof lastArg === &#x27;string&#x27;) {
            return doLoad(templatePath, templateSrc);
        } else {
            var finalOptions = templateSrc;
            return doLoad(templatePath, null, finalOptions);
        }
    } else if (arguments.length === 3) {
        // assume function called according to function signature
        return doLoad(templatePath, templateSrc, options);
    } else {
        throw new Error(&#x27;Illegal arguments&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function defineRenderer(def) {
var template = def.template;
var getTemplateData = def.getTemplateData;
var renderer = def.renderer;

if (typeof template === &#x27;string&#x27;) {
    template = marko.<span class="apidocCodeKeywordSpan">load</span>(template);
}

var createOut;

if (template) {
    createOut = template.createOut;
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loadComponent" id="apidoc.element.marko.loadComponent">
        function <span class="apidocSignatureSpan">marko.</span>loadComponent
        <span class="apidocSignatureSpan">(typeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(typeName) {
    throw new Error(&#x27;Not found: &#x27; + typeName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loadComponent_dynamic" id="apidoc.element.marko.loadComponent_dynamic">
        function <span class="apidocSignatureSpan">marko.</span>loadComponent_dynamic
        <span class="apidocSignatureSpan">(typeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(typeName) {
    // We make the assumption that the component type name is a path to a
    // fully resolved module path and that the module exists
    // as a CommonJS module
    return require(typeName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.nextRepeatedId" id="apidoc.element.marko.nextRepeatedId">
        function <span class="apidocSignatureSpan">marko.</span>nextRepeatedId
        <span class="apidocSignatureSpan">(out, parentId, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextRepeatedId(out, parentId, id) {
    var nextIdLookup = out.global[REPEATED_ID_KEY] || (out.global[REPEATED_ID_KEY] = {});

    var indexLookupKey = parentId + &#x27;-&#x27; + id;
    var currentIndex = nextIdLookup[indexLookupKey];
    if (currentIndex == null) {
        currentIndex = nextIdLookup[indexLookupKey] = 0;
    } else {
        currentIndex = ++nextIdLookup[indexLookupKey];
    }

    return indexLookupKey.slice(0, -2) + &#x27;[&#x27; + currentIndex + &#x27;]&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.nextTick" id="apidoc.element.marko.nextTick">
        function <span class="apidocSignatureSpan">marko.</span>nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
  if (typeof callback !== &#x27;function&#x27;)
    throw new TypeError(&#x27;callback is not a function&#x27;);
  // on the way out, don&#x27;t bother. it won&#x27;t get fired anyway.
  if (process._exiting)
    return;

  var args;
  if (arguments.length &#x3e; 1) {
    args = new Array(arguments.length - 1);
    for (var i = 1; i &#x3c; arguments.length; i++)
      args[i - 1] = arguments[i];
  }

  nextTickQueue.push({
    callback,
    domain: process.domain || null,
    args
  });
  tickInfo[kLength]++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.notEmpty" id="apidoc.element.marko.notEmpty">
        function <span class="apidocSignatureSpan">marko.</span>notEmpty
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notEmpty(o) {
    if (o == null) {
        return false;
    } else if (Array.isArray(o)) {
        return !!o.length;
    } else if (o === &#x27;&#x27;) {
        return false;
    }

    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.ready" id="apidoc.element.marko.ready">
        function <span class="apidocSignatureSpan">marko.</span>ready
        <span class="apidocSignatureSpan">(callback, thisObj, doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ready(callback, thisObj, doc) {
    if (isReady) {
        return callback.call(thisObj);
    }

    listeners.push([callback, thisObj]);

    if (!readyBound) {
        readyBound = true;
        bindReady(doc || defaultDocument);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.renderable" id="apidoc.element.marko.renderable">
        function <span class="apidocSignatureSpan">marko.</span>renderable
        <span class="apidocSignatureSpan">(target, renderer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderable = function (target, renderer) {
    var renderFunc = renderer &#x26;&#x26; (renderer.renderer || renderer.render || renderer);
    var createOut = target.createOut || renderer.createOut || defaultCreateOut;

    return extend(target, {
        createOut: createOut,

        renderToString: function(data, callback) {
            var localData = data || {};
            var render = renderFunc || this._;
            var globalData = localData.$global;
            var out = createOut(globalData);

            out.global.template = this;

            if (globalData) {
                localData.$global = undefined;
            }

            if (callback) {
                out.on(&#x27;finish&#x27;, function() {
                       callback(null, out.toString(), out);
                   })
                   .once(&#x27;error&#x27;, callback);

                return safeRender(render, localData, out, true);
            } else {
                out.sync();
                render(localData, out);
                return out.toString();
            }
        },

        renderSync: function(data) {
            var localData = data || {};
            var render = renderFunc || this._;
            var globalData = localData.$global;
            var out = createOut(globalData);
            out.sync();

            out.global.template = this;

            if (globalData) {
                localData.$global = undefined;
            }

            render(localData, out);
            return out.$__getResult();
        },

<span class="apidocCodeCommentSpan">        /**
         * Renders a template to either a stream (if the last
         * argument is a Stream instance) or
         * provides the output to a callback function (if the last
         * argument is a Function).
         *
         * Supported signatures:
         *
         * render(data)
         * render(data, out)
         * render(data, stream)
         * render(data, callback)
         *
         * @param  {Object} data The view model data for the template
         * @param  {AsyncStream/AsyncVDOMBuilder} out A Stream, an AsyncStream/AsyncVDOMBuilder instance, or a callback function
         * @return {AsyncStream/AsyncVDOMBuilder} Returns the AsyncStream/AsyncVDOMBuilder instance that the template is rendered
 to
         */
</span>        render: function(data, out) {
            var callback;
            var finalOut;
            var finalData;
            var globalData;
            var render = renderFunc || this._;
            var shouldBuffer = this.$__shouldBuffer;
            var shouldEnd = true;

            if (data) {
                finalData = data;
                if ((globalData = data.$global)) {
                    finalData.$global = undefined;
                }
            } else {
                finalData = {};
            }

            if (out &#x26;&#x26; out.$__isOut) {
                finalOut = out;
                shouldEnd = false;
                extend(out.global, globalData);
            } else if (typeof out == &#x27;function&#x27;) {
                finalOut = createOut(globalData);
                callback = out;
            } else {
                finalOut = createOut(
                    globalData, // global
                    out, // writer(AsyncStream) or parentNode(AsyncVDOMBuilder)
                    null, // state
                    shouldBuffer // ignored by AsyncVDOMBuilder
                );
            }

            if (callback) {
                finalOut
                    .on(&#x27;finish&#x27;, function() {
                        callback(null, finalOut.$__getResult());
                    })
                    .once(&#x27;error&#x27;, callback);
            }

            globalData = finalOut.global;

            globalData.template = globalData.template || this;

            return safeRender(render, finalData, finalOut, shouldEnd);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.renderer" id="apidoc.element.marko.renderer">
        function <span class="apidocSignatureSpan">marko.</span>renderer
        <span class="apidocSignatureSpan">(templateRenderFunc, componentProps, renderingLogic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createRendererFunc(templateRenderFunc, componentProps, renderingLogic) {
    renderingLogic = renderingLogic || {};
    var onInput = renderingLogic.onInput;
    var typeName = componentProps.type;
    var roots = componentProps.roots;
    var assignedId = componentProps.id;
    var split = componentProps.split;

    return function renderer(input, out) {
        var outGlobal = out.global;

        if (out.isSync() === false) {
            if (!outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY]) {
                outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY] = true;
                out.on(&#x27;beginAsync&#x27;, handleBeginAsync);
            }
        }

        var component = outGlobal.$w;
        var isRerender = component !== undefined;
        var id = assignedId;
        var isExisting;
        var customEvents;
        var scope;

        if (component) {
            id = component.id;
            isExisting = true;
            outGlobal.$w = null;
        } else {
            var componentArgs = out.$c;

            if (componentArgs) {
                out.$c = null;

                scope = componentArgs[0];

                if (scope) {
                    scope = scope.id;
                }

                var key = componentArgs[1];
                if (key != null) {
                    key = key.toString();
                }
                id = id || resolveComponentKey(out, key, scope);
                customEvents = componentArgs[2];
            }
        }

        var componentsContext = getComponentsContext(out);
        id = id || componentsContext.$__nextComponentId();

        if (registry.$__isServer) {
            component = registry.$__createComponent(
                renderingLogic,
                id,
                input,
                out,
                typeName,
                customEvents,
                scope);
            input = component.$__updatedInput;
            component.$__updatedInput = undefined; // We don&#x27;t want $__updatedInput to be serialized to the browser
        } else {
            if (!component) {
                if (isRerender) {
                    // Look in in the DOM to see if a component with the same ID and type already exists.
                    component = componentLookup[id];
                    if (component &#x26;&#x26; component.$__type !== typeName) {
                        component = undefined;
                    }
                }

                if (component) {
                    isExisting = true;
                } else {
                    isExisting = false;
                    // We need to create a new instance of the component
                    component = registry.$__createComponent(typeName, id);

                    if (split) {
                        split = false;

                        var renderingLogicProps = typeof renderingLogic == &#x27;function&#x27; ?
                            renderingLogic.prototype :
                            renderingLogic;

                        copyProps(renderingLogicProps, component.constructor.prototype);
                    }
                }

                // Set this flag to prevent the component from being queued for update
                // based on the new input. The component is about to be rerendered
                // so we don&#x27;t want to queue it up as a result of calling `setInput()`
                component.$__updateQueued = true;

                if (customEvents !== undefined) {
                    component.$__setCustomEvents(customEvents, scope);
                }


                if (isExisting === false) {
                    emitLifecycleEvent(component, &#x27;create&#x27;, input, out);
                }

                input = component.$__setInput(input, onInput, out);

                if (isExisting === true) {
                    if (component.$__isDirty === false || component.shouldUpdate(input, component.$__state) === false) {
                        preserveComponentEls(component, out, componentsContext);
                        return;
                    }
                } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }
}
}

function createDeferredRenderer(handler) {
function deferredRenderer(input, out) {
    deferredRenderer.<span class="apidocCodeKeywordSpan">renderer</span>(input, out);
}

// This is the initial function that will do the rendering. We replace
// the renderer with the actual renderer func on the first render
deferredRenderer.renderer = function(input, out) {
    var rendererFunc = handler.renderer || handler._ || handler.render;
    if (!isFunction(rendererFunc)) {
...</pre></li>
    </ul>








































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.Builder" id="apidoc.module.marko.Builder">module marko.Builder</a></h1>


    <h2>
        <a href="#apidoc.element.marko.Builder.Builder" id="apidoc.element.marko.Builder.Builder">
        function <span class="apidocSignatureSpan">marko.</span>Builder
        <span class="apidocSignatureSpan">(elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Builder {
    arrayExpression(elements) {
        if (elements) {
            if (!isArray(elements)) {
                elements = [elements];
            }

            for (var i=0; i&#x3c;elements.length; i++) {
                elements[i] = makeNode(elements[i]);
            }
        } else {
            elements = [];
        }

        return new ArrayExpression({elements});
    }

    assignment(left, right, operator) {
        if (operator == null) {
            operator = &#x27;=&#x27;;
        }
        left = makeNode(left);
        right = makeNode(right);
        return new Assignment({left, right, operator});
    }

    binaryExpression(left, operator, right) {
        left = makeNode(left);
        right = makeNode(right);
        return new BinaryExpression({left, operator, right});
    }

    sequenceExpression(expressions) {
        expressions = makeNode(expressions);
        return new SequenceExpression({expressions});
    }

    code(value) {
        return new Code({value});
    }

    computedMemberExpression(object, property) {
        object = makeNode(object);
        property = makeNode(property);
        let computed = true;

        return new MemberExpression({object, property, computed});
    }

    concat(args) {
        var prev;
        let operator = &#x27;+&#x27;;

        for (var i=1; i&#x3c;arguments.length; i++) {
            var left;
            var right = makeNode(arguments[i]);
            if (i === 1) {
                left = makeNode(arguments[i-1]);
            } else {
                left = prev;
            }

            prev = new BinaryExpression({left, operator, right});
        }

        return prev;
    }

    conditionalExpression(test, consequent, alternate) {
        return new ConditionalExpression({test, consequent, alternate});
    }

    containerNode(type, generateCode) {
        if (typeof type === &#x27;function&#x27;) {
            generateCode = arguments[0];
            type = &#x27;ContainerNode&#x27;;
        }

        var node = new ContainerNode(type);
        if (generateCode) {
            node.setCodeGenerator(generateCode);
        }
        return node;
    }

    customTag(el, tagDef) {
        return new CustomTag(el, tagDef);
    }

    declaration(declaration) {
        return new Declaration({declaration});
    }

    documentType(documentType) {
        return new DocumentType({documentType});
    }

    elseStatement(body) {
        return new Else({body});
    }

    elseIfStatement(test, body, elseStatement) {
        test = makeNode(test);

        return new ElseIf({test, body, else: elseStatement});
    }

    expression(value) {
        return new Expression({value});
    }

    forEach(varName, inExpression, body) {
        if (arguments.length === 1) {
            var def = arguments[0];
            return new ForEach(def);
        } else {
            varName = makeNode(varName);
            inExpression = makeNode(inExpression);
            return new ForEach({varName, in: inExpression, body});
        }
    }

    forEachProp(nameVarName, valueVarName, inExpression, body) {
        if (arguments.length === 1) {
            var def = arguments[0];
            return new ForEachProp(def);
        } else {
            nameVarName = makeNode(nameVarName);
            valueVarName = makeNode(valueVarName);
            inExpression = makeNode(inExpression);
            return new ForEachProp({nameVarName, valueVarName, in: inExpression, body});
        }
    }

    forRange(varName, from, to, step, body) {
        if (arguments.length === 1) {
            var def = arguments[0];
            return new ForRange(def);
        } else {
            varName = makeNode(varName);
            from = makeNode(from);
            to = makeNode(to);
            step = makeNode(step);
            body = makeNode(body);

            return new ForRange({varName, from, to, step, body});
        }
    }

    forStatement(init, test, update, body) {
        if (arguments.length === 1) {
            var def = arguments[0];
            return new ForStatement(def);
        } else { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.CodeGenerator" id="apidoc.module.marko.CodeGenerator">module marko.CodeGenerator</a></h1>


    <h2>
        <a href="#apidoc.element.marko.CodeGenerator.CodeGenerator" id="apidoc.element.marko.CodeGenerator.CodeGenerator">
        function <span class="apidocSignatureSpan">marko.</span>CodeGenerator
        <span class="apidocSignatureSpan">(context, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CodeGenerator {
    constructor(context, options) {
        options = options || {};
        this.root = null;

        this._code = &#x27;&#x27;;
        this.currentIndent = &#x27;&#x27;;
        this.inFunction = false;

        this._doneListeners = [];


        this.builder = context.builder;

        this.context = context;

        ok(this.builder, &#x27;&#x22;this.builder&#x22; is required&#x27;);

        this._codegenCodeMethodName = &#x27;generate&#x27; +
            context.outputType.toUpperCase() +
            &#x27;Code&#x27;;
    }

    addVar(name, value) {
        return this.context.addVar(name, value);
    }

    addStaticVar(name, value) {
        return this.context.addStaticVar(name, value);
    }

    addStaticCode(code) {
        this.context.addStaticCode(code);
    }

    addDependency(path, type, options) {
        this.context.addDependency(path, type, options);
    }

    pushMeta(key, value, unique) {
        this.context.pushMeta(key, value, unique);
    }

    setMeta(key, value) {
        this.context.setMeta(key, value);
    }

    getEscapeXmlAttrVar() {
        return this.context.getEscapeXmlAttrVar();
    }

    importModule(varName, path) {
        return this.context.importModule(varName, path);
    }

    _invokeCodeGenerator(func, node, isMethod) {
        try {
            if (isMethod) {
                return func.call(node, this);
            } else {
                return func.call(node, node, this);
            }
        } catch(err) {
            var errorMessage = &#x27;Generating code for &#x27;;

            if (node instanceof HtmlElement) {
                errorMessage += &#x27;&#x3c;&#x27;+node.tagName+&#x27;&#x3e; tag&#x27;;
            } else {
                errorMessage += node.type + &#x27; node&#x27;;
            }

            if (node.pos) {
                errorMessage += &#x27; (&#x27;+this.context.getPosInfo(node.pos)+&#x27;)&#x27;;
            }

            errorMessage += &#x27; failed. Error: &#x27; + err;

            throw createError(errorMessage, err /* cause */);
        }
    }

    _generateCode(node, finalNodes) {
        if (isArray(node)) {
            node.forEach((child) =&#x3e; {
                this._generateCode(child, finalNodes);
            });
            return;
        } else if (node instanceof Container) {
            node.forEach((child) =&#x3e; {
                if (child.container === node) {
                    this._generateCode(child, finalNodes);
                }
            });
            return;
        }

        if (node == null) {
            return;
        }

        if (typeof node === &#x27;string&#x27; || node._finalNode || !(node instanceof Node)) {
            finalNodes.push(node);
            return;
        }

        if (node._normalizeChildTextNodes) {
            node._normalizeChildTextNodes(this.context);
        }

        let oldCurrentNode = this._currentNode;
        this._currentNode = node;

        var beforeAfterEvent = new GeneratorEvent(node, this);

        var isWhitespacePreserved = node.isPreserveWhitespace();

        if (isWhitespacePreserved) {
            this.context.beginPreserveWhitespace();
        }

        beforeAfterEvent.isBefore = true;
        beforeAfterEvent.node.emit(&#x27;beforeGenerateCode&#x27;, beforeAfterEvent);
        this.context.emit(&#x27;beforeGenerateCode:&#x27; + beforeAfterEvent.node.type, beforeAfterEvent);
        this.context.emit(&#x27;beforeGenerateCode&#x27;, beforeAfterEvent);

        if (beforeAfterEvent.insertedNodes) {
            this._generateCode(beforeAfterEvent.insertedNodes, finalNodes);
            beforeAfterEvent.insertedNodes = null;
        }

        let codeGeneratorFunc;
        let generatedCode;

        if (node.getCodeGenerator) {
            codeGeneratorFunc = node.getCodeGenerator(this.outputType);

            if (codeGeneratorFunc) {
                node.setCodeGenerator(null);

                generatedCode = this._invokeCodeGenerator(codeGeneratorFunc, node, false);

                if (generatedCode === null) {
                    node = null;
                } else if (generatedCode !== undefined &#x26;&#x26; generatedCode !== node) {
                    node = null;
                    this._generateCode ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.CodeWriter" id="apidoc.module.marko.CodeWriter">module marko.CodeWriter</a></h1>


    <h2>
        <a href="#apidoc.element.marko.CodeWriter.CodeWriter" id="apidoc.element.marko.CodeWriter.CodeWriter">
        function <span class="apidocSignatureSpan">marko.</span>CodeWriter
        <span class="apidocSignatureSpan">(options, builder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CodeWriter {
    constructor(options, builder) {
        ok(builder, &#x27;&#x22;builder&#x22; is required&#x27;);
        options = options || {};
        this.builder = builder;
        this.root = null;
        this._indentStr = options.indent != null ? options.indent : &#x27;  &#x27;;
        this._indentSize = this._indentStr.length;

        this._code = &#x27;&#x27;;
        this.currentIndent = &#x27;&#x27;;
    }

    getCode() {
        return this._code;
    }

    writeBlock(body) {
        if (!body) {
            this.write(&#x27;{}&#x27;);
            return;
        }

        if (typeof body === &#x27;function&#x27;) {
            body = body();
        }

        if (!body ||
            (Array.isArray(body) &#x26;&#x26; body.length === 0) ||
            (body instanceof Container &#x26;&#x26; body.length === 0)) {
            this.write(&#x27;{}&#x27;);
            return;
        }

        this.write(&#x27;{\n&#x27;)
            .incIndent();

        this.writeStatements(body);

        this.decIndent()
            .writeLineIndent()
            .write(&#x27;}&#x27;);
    }

    writeStatements(nodes) {
        if (!nodes) {
            return;
        }

        ok(nodes, &#x27;&#x22;nodes&#x22; expected&#x27;);
        let firstStatement = true;

        var writeNode = (node) =&#x3e; {
            if (Array.isArray(node) || (node instanceof Container)) {
                node.forEach(writeNode);
                return;
            } else {
                if (firstStatement) {
                    firstStatement = false;
                } else {
                    this._write(&#x27;\n&#x27;);
                }

                this.writeLineIndent();

                if (typeof node === &#x27;string&#x27;) {
                    this._write(node);
                } else {
                    node.statement = true;
                    this.write(node);
                }

                if (this._code.endsWith(&#x27;\n&#x27;)) {
                    // Do nothing
                } else if (this._code.endsWith(&#x27;;&#x27;)) {
                    this._code += &#x27;\n&#x27;;
                }  else if (this._code.endsWith(&#x27;\n&#x27; + this.currentIndent) || node instanceof Comment) {
                    // Do nothing
                } else {
                    this._code += &#x27;;\n&#x27;;
                }
            }
        };

        if (nodes instanceof Node) {
            writeNode(nodes);
        } else {
            nodes.forEach(writeNode);
        }
    }

    write(code) {
        if (code == null || code === &#x27;&#x27;) {
            return;
        }

        if (code instanceof Node) {
            let node = code;
            if (!node.writeCode) {
                throw new Error(&#x27;Node does not have a `writeCode` method: &#x27; + JSON.stringify(node, null, 4));
            }
            node.writeCode(this);
        } else if (isArray(code) || code instanceof Container) {
            code.forEach(this.write, this);
            return;
        } else if (typeof code === &#x27;string&#x27;) {
            this._code += code;
        }  else if (typeof code === &#x27;boolean&#x27; || typeof code === &#x27;number&#x27;) {
            this._code += code.toString();
        } else {
            throw new Error(&#x27;Illegal argument: &#x27; + JSON.stringify(code));
        }

        return this;
    }

    _write(code) {
        this._code += code;
        return this;
    }

    incIndent(count) {
        if (count != null) {
            for (let i=0; i&#x3c;count; i++) {
                this.currentIndent += &#x27; &#x27;;
            }
        } else {
            this.currentIndent += this._indentStr;
        }

        return this;
    }

    decIndent(count) {
        if (count == null) {
            count = this._indentSize;
        }

        this.currentIndent = this.currentIndent.substring(
            0,
            this.currentIndent.length - count);

        return this;
    }

    writeLineIndent() {
        this._code += this.currentIndent;
        return this;
    }

    writeIndent() {
        this._code += this._indentStr;
        return this;
    }

    isLiteralNode(node) {
        return node instanceof Literal;
    }

    isIdentifierNode(node) {
        return node instanceof Identifier;
    }

    writeLiteral(value) {
        if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.CompileContext" id="apidoc.module.marko.CompileContext">module marko.CompileContext</a></h1>


    <h2>
        <a href="#apidoc.element.marko.CompileContext.CompileContext" id="apidoc.element.marko.CompileContext.CompileContext">
        function <span class="apidocSignatureSpan">marko.</span>CompileContext
        <span class="apidocSignatureSpan">(src, filename, builder, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CompileContext extends EventEmitter {
    constructor(src, filename, builder, options) {
        super();
        ok(typeof src === &#x27;string&#x27;, &#x27;&#x22;src&#x22; string is required&#x27;);
        ok(filename, &#x27;&#x22;filename&#x22; is required&#x27;);

        this.src = src;
        this.filename = filename;
        this.builder = builder;

        this.dirname = path.dirname(filename);
        this.taglibLookup = taglibLookup.buildLookup(this.dirname);
        this.data = {};
        this._dataStacks = {};
        this.meta = {};

        this.options = options || {};

        const writeVersionComment = this.options.writeVersionComment;

        this.outputType = this.options.output || &#x27;html&#x27;;
        this.compilerType = this.options.compilerType || &#x27;marko&#x27;;
        this.compilerVersion = this.options.compilerVersion || markoPkgVersion;
        this.writeVersionComment = writeVersionComment !== &#x27;undefined&#x27; ? writeVersionComment : true;

        this._vars = {};
        this._uniqueVars = new UniqueVars();
        this._staticVars = {};
        this._staticCode = null;
        this._uniqueStaticVars = new UniqueVars();
        this._srcCharProps = null;
        this._flags = {};
        this._errors = [];
        this._macros = null;
        this._preserveWhitespace = null;
        this._preserveComments = null;
        this.inline = this.options.inline === true;
        this.useMeta = this.options.meta !== false;
        this._moduleRuntimeTarget = this.outputType === &#x27;vdom&#x27; ? &#x27;marko/vdom&#x27; : &#x27;marko/html&#x27;;
        this.unrecognizedTags = [];
        this._parsingFinished = false;

        this._helpersIdentifier = null;

        if (this.options.preserveWhitespace) {
            this.setPreserveWhitespace(true);
        }

        this._helpers = {};
        this._imports = {};
        this._fingerprint = undefined;
        this._optimizers = undefined;
    }

    setInline(isInline) {
        this.inline = isInline === true;
    }

    getPosInfo(pos) {
        var srcCharProps = this._srcCharProps || (this._srcCharProps = charProps(this.src));
        let line = srcCharProps.lineAt(pos)+1;
        let column = srcCharProps.columnAt(pos);
        return new PosInfo(this.filename, line, column);
    }

    getNodePos(node) {
        if (node.pos) {
            return this.getPosInfo(node.pos);
        } else {
            return new PosInfo(this.filename);
        }
    }

    setFlag(name) {
        this.pushFlag(name);
    }

    clearFlag(name) {
        delete this._flags[name];
    }

    isFlagSet(name) {
        return this._flags.hasOwnProperty(name);
    }

    pushFlag(name) {
        if (this._flags.hasOwnProperty(name)) {
            this._flags[name]++;
        } else {
            this._flags[name] = 1;
        }
    }

    popFlag(name) {
        if (!this._flags.hasOwnProperty(name)) {
            throw new Error(&#x27;popFlag() called for &#x22;&#x27; + name + &#x27;&#x22; when flag was not set&#x27;);
        }

        if (--this._flags[name] === 0) {
            delete this._flags[name];
        }
    }

    pushData(key, data) {
        var dataStack = this._dataStacks[key];
        if (!dataStack) {
            dataStack = this._dataStacks[key] = [];
        }

        dataStack.push(data);

        return {
            pop: () =&#x3e; {
                this.popData(key);
            }
        };
    }

    popData(key) {
        var dataStack = this._dataStacks[key];

        if (!dataStack || dataStack.length === 0) {
            throw new Error(&#x27;No data pushed for &#x22;&#x27; + key + &#x27;&#x22;&#x27;);
        }

        dataStack.pop();

        if (dataStack.length === 0) {
            delete this.data[key];
        }
    }

    getData(name) {
        var dataStack = this._dataStacks[name];
        if (dataStack) {
            return dataStack[dataStack.length - 1];
        }

        return this.data[name];
    }

    deprecate(message, node) {
        var currentNode = node || this._currentNode;
        var location = currentNode &#x26;&#x26; currentNode.pos;

        if (location != null) {
            location = this.getPosInfo(location).toString();
        }

        complain(me ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.CompileError" id="apidoc.module.marko.CompileError">module marko.CompileError</a></h1>


    <h2>
        <a href="#apidoc.element.marko.CompileError.CompileError" id="apidoc.element.marko.CompileError.CompileError">
        function <span class="apidocSignatureSpan">marko.</span>CompileError
        <span class="apidocSignatureSpan">(errorInfo, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CompileError {
    constructor(errorInfo, context) {
        this.context = context;
        this.node = errorInfo.node;
        this.message = errorInfo.message;
        this.code = errorInfo.code;

        var pos = errorInfo.pos;
        var endPos = errorInfo.endPos;

        if (pos == null) {
            pos = this.node &#x26;&#x26; this.node.pos;
        }

        if (endPos == null) {
            endPos = this.node &#x26;&#x26; this.node.endPos;
        }

        if (pos != null) {
            pos = context.getPosInfo(pos);
        }

        if (endPos != null) {
            endPos = context.getPosInfo(endPos);
        }

        this.pos = pos;
        this.endPos = endPos;
    }

    toString() {
        var pos = this.pos;
        if (pos) {
            pos = &#x27;[&#x27; + pos + &#x27;] &#x27;;
        } else {
            pos = &#x27;&#x27;;
        }
        var str = pos + this.message;
        if (pos == null &#x26;&#x26; this.node) {
            str += &#x27; (&#x27; + this.node.toString() + &#x27;)&#x27;;
        }
        return str;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.Compiler" id="apidoc.module.marko.Compiler">module marko.Compiler</a></h1>


    <h2>
        <a href="#apidoc.element.marko.Compiler.Compiler" id="apidoc.element.marko.Compiler.Compiler">
        function <span class="apidocSignatureSpan">marko.</span>Compiler
        <span class="apidocSignatureSpan">(options, userOptions, inline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Compiler {
    constructor(options, userOptions, inline) {
        ok(options, &#x27;&#x22;options&#x22; is required&#x27;);

        this.builder = options.builder;
        this.parser = options.parser;

        ok(this.builder, &#x27;&#x22;options.builder&#x22; is required&#x27;);
        ok(this.parser, &#x27;&#x22;options.parser&#x22; is required&#x27;);
    }

    compile(src, context) {
        ok(typeof src === &#x27;string&#x27;, &#x27;&#x22;src&#x22; argument should be a string&#x27;);

        var codeGenerator = new CodeGenerator(context);

        // STAGE 1: Parse the template to produce the initial AST
        var ast = this.parser.parse(src, context);
        context._parsingFinished = true;

        if (context.unrecognizedTags) {
            for(let i=0; i&#x3c;context.unrecognizedTags.length; i++) {
                let unrecognizedTag = context.unrecognizedTags[i];
                // See if the tag is a macro
                if (!context.isMacro(unrecognizedTag.tagName)) {
                    context.addErrorUnrecognizedTag(unrecognizedTag.tagName, unrecognizedTag.node);
                }
            }
        }

        handleErrors(context);

        context.root = ast;
        // console.log(&#x27;ROOT&#x27;, JSON.stringify(ast, null, 2));

        // STAGE 2: Transform the initial AST to produce the final AST
        var transformedAST = transformTree(ast, context);
        // console.log(&#x27;transformedAST&#x27;, JSON.stringify(ast, null, 2));

        handleErrors(context);

        var finalAST = codeGenerator.generateCode(transformedAST);

        handleErrors(context);

        return new CompiledTemplate(finalAST, context);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.Component" id="apidoc.module.marko.Component">module marko.Component</a></h1>


    <h2>
        <a href="#apidoc.element.marko.Component.Component" id="apidoc.element.marko.Component.Component">
        function <span class="apidocSignatureSpan">marko.</span>Component
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Component(id) {
    EventEmitter.call(this);
    this.id = id;
    this.el = null;
    this.$__state = null;
    this.$__roots = null;
    this.$__subscriptions = null;
    this.$__domEventListenerHandles = null;
    this.$__bubblingDomEvents = null;
    this.$__customEvents = null;
    this.$__scope = null;
    this.$__renderInput = null;
    this.$__input = undefined;

    this.$__destroyed = false;
    this.$__updateQueued = false;
    this.$__dirty = false;
    this.$__settingInput = false;

    this.$__document = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.Component.prototype" id="apidoc.module.marko.Component.prototype">module marko.Component.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.Component.prototype.appendTo" id="apidoc.element.marko.Component.prototype.appendTo">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>appendTo
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendTo = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.appendChild(el);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.destroy" id="apidoc.element.marko.Component.prototype.destroy">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
    if (this.$__destroyed) {
        return;
    }

    var els = this.els;

    this.$__destroyShallow();

    var rootComponents = this.$__rootComponents;
    if (rootComponents) {
        rootComponents.forEach(function(rootComponent) {
            rootComponent.$__destroy();
        });
    }

    els.forEach(function(el) {
        destroyElRecursive(el);

        var parentNode = el.parentNode;
        if (parentNode) {
            parentNode.removeChild(el);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.elId" id="apidoc.element.marko.Component.prototype.elId">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>elId
        <span class="apidocSignatureSpan">(componentElId, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">elId = function (componentElId, index) {
    return getElIdHelper(this, componentElId, index);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.emit" id="apidoc.element.marko.Component.prototype.emit">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>emit
        <span class="apidocSignatureSpan">(eventType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (eventType) {
    var customEvents = this.$__customEvents;
    var target;

    if (customEvents &#x26;&#x26; (target = customEvents[eventType])) {
        var targetMethodName = target[0];
        var extraArgs = target[1];
        var args = slice.call(arguments, 1);

        handleCustomEventWithMethodListener(this, targetMethodName, args, extraArgs);
    }

    if (this.listenerCount(eventType)) {
        return emit.apply(this, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var isWhitespacePreserved = node.isPreserveWhitespace();

if (isWhitespacePreserved) {
    this.context.beginPreserveWhitespace();
}

beforeAfterEvent.isBefore = true;
beforeAfterEvent.node.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;beforeGenerateCode&#x27;, beforeAfterEvent);
this.context.emit(&#x27;beforeGenerateCode:&#x27; + beforeAfterEvent.node.type, beforeAfterEvent);
this.context.emit(&#x27;beforeGenerateCode&#x27;, beforeAfterEvent);

if (beforeAfterEvent.insertedNodes) {
    this._generateCode(beforeAfterEvent.insertedNodes, finalNodes);
    beforeAfterEvent.insertedNodes = null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.forceUpdate" id="apidoc.element.marko.Component.prototype.forceUpdate">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>forceUpdate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forceUpdate = function () {
    this.$__dirty = true;
    this.$__queueUpdate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.getComponent" id="apidoc.element.marko.Component.prototype.getComponent">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getComponent
        <span class="apidocSignatureSpan">(id, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComponent = function (id, index) {
    return componentLookup[getElIdHelper(this, id, index)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.getComponents" id="apidoc.element.marko.Component.prototype.getComponents">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getComponents
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComponents = function (id) {
    var components = [];
    var i = 0;
    var component;
    while((component = componentLookup[getElIdHelper(this, id, i)])) {
        components.push(component);
        i++;
    }
    return components;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   this.$__components = undefined;
}

module.exports = RenderResult;

var proto = RenderResult.prototype = {
    getComponent: function() {
return this.<span class="apidocCodeKeywordSpan">getComponents</span>()[0];
    },
    getComponents: function(selector) {
if (this.$__components === undefined) {
    throw Error(&#x27;Not added to DOM&#x27;);
}

var componentDefs = getComponentDefs(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.getEl" id="apidoc.element.marko.Component.prototype.getEl">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getEl
        <span class="apidocSignatureSpan">(componentElId, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEl = function (componentElId, index) {
    var doc = this.$__document;

    if (componentElId != null) {
        return getElementById(doc, getElIdHelper(this, componentElId, index));
    } else {
        return this.el || getElementById(doc, getElIdHelper(this));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return this.el || getElementById(doc, getElIdHelper(this));
    }
},
getEls: function(id) {
    var els = [];
    var i = 0;
    var el;
    while((el = this.<span class="apidocCodeKeywordSpan">getEl</span>(id, i))) {
        els.push(el);
        i++;
    }
    return els;
},
getComponent: function(id, index) {
    return componentLookup[getElIdHelper(this, id, index)];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.getElId" id="apidoc.element.marko.Component.prototype.getElId">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getElId
        <span class="apidocSignatureSpan">(componentElId, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getElId = function (componentElId, index) {
    return getElIdHelper(this, componentElId, index);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var match = idRegExp.exec(arg);
//Reset the search to 0 so the next call to exec will start from the beginning for the new string
if (match != null) {
    var componentElId = match[1];
    if (match[2] == null) {
        return jQuery(self.getEl(componentElId));
    } else {
        return jQuery(&#x27;#&#x27; + self.<span class="apidocCodeKeywordSpan">getElId</span>(componentElId) + match[2]);
    }
} else {
    var rootEl = self.getEl();
    if (!rootEl) {
        throw new Error(&#x27;Root element is not defined for component&#x27;);
    }
    if (rootEl) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.getEls" id="apidoc.element.marko.Component.prototype.getEls">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getEls
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEls = function (id) {
    var els = [];
    var i = 0;
    var el;
    while((el = this.getEl(id, i))) {
        els.push(el);
        i++;
    }
    return els;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.insertAfter" id="apidoc.element.marko.Component.prototype.insertAfter">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>insertAfter
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertAfter = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    el = el;
    var nextSibling = referenceEl.nextSibling;
    var parentNode = referenceEl.parentNode;
    if (nextSibling) {
        parentNode.insertBefore(el, nextSibling);
    } else {
        parentNode.appendChild(el);
    }
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.insertBefore" id="apidoc.element.marko.Component.prototype.insertBefore">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>insertBefore
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertBefore = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.parentNode.insertBefore(el, referenceEl);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var el = getEl(this, referenceEl);
    referenceEl.appendChild(el);
    return afterInsert(this, referenceEl);
},
prependTo: function(referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.<span class="apidocCodeKeywordSpan">insertBefore</span>(el, referenceEl.firstChild || null);
    return afterInsert(this, referenceEl);
},
replace: function(referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    beforeRemove(referenceEl);
    referenceEl.parentNode.replaceChild(el, referenceEl);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.isDestroyed" id="apidoc.element.marko.Component.prototype.isDestroyed">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>isDestroyed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDestroyed = function () {
    return this.$__destroyed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.prependTo" id="apidoc.element.marko.Component.prototype.prependTo">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>prependTo
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependTo = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.insertBefore(el, referenceEl.firstChild || null);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.replace" id="apidoc.element.marko.Component.prototype.replace">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>replace
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    beforeRemove(referenceEl);
    referenceEl.parentNode.replaceChild(el, referenceEl);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.prevTextNode = null;

var tagDef = el.tagName ? this.context.getTagDef(el.tagName) : null;

var attributeParseErrors = [];
// &#x3c;div class=&#x22;foo&#x22;&#x3e; -&#x3e; &#x22;div class=foo&#x22;
var tagString = parser.substring(el.pos, el.endPos)
                      .<span class="apidocCodeKeywordSpan">replace</span>(/^&#x3c;|\/&#x3e;$|&#x3e;$/g, &#x22;&#x22;).trim();

var shouldParsedAttributes = !tagDef || tagDef.parseAttributes !== false;

var parsedAttributes = [];

if (shouldParsedAttributes) {
    attributes.forEach((attr) =&#x3e; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.replaceChildrenOf" id="apidoc.element.marko.Component.prototype.replaceChildrenOf">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>replaceChildrenOf
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceChildrenOf = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);

    var curChild = referenceEl.firstChild;
    while(curChild) {
        var nextSibling = curChild.nextSibling; // Just in case the DOM changes while removing
        if (curChild.nodeType == 1) {
            beforeRemove(curChild);
        }
        curChild = nextSibling;
    }

    referenceEl.innerHTML = &#x27;&#x27;;
    referenceEl.appendChild(el);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.replaceState" id="apidoc.element.marko.Component.prototype.replaceState">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>replaceState
        <span class="apidocSignatureSpan">(newState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceState = function (newState) {
    this.$__state.$__replace(newState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.setState" id="apidoc.element.marko.Component.prototype.setState">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>setState
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setState = function (name, value) {
    var state = this.$__state;

    if (typeof name == &#x27;object&#x27;) {
        // Merge in the new state with the old state
        var newState = name;
        for (var k in newState) {
            if (newState.hasOwnProperty(k)) {
                state.$__set(k, newState[k], true /* ensure:true */);
            }
        }
    } else {
        state.$__set(name, value, true /* ensure:true */);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.setStateDirty" id="apidoc.element.marko.Component.prototype.setStateDirty">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>setStateDirty
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setStateDirty = function (name, value) {
    var state = this.$__state;

    if (arguments.length == 1) {
        value = state[name];
    }

    state.$__set(name, value, true /* ensure:true */, true /* forceDirty:true */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.shouldUpdate" id="apidoc.element.marko.Component.prototype.shouldUpdate">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>shouldUpdate
        <span class="apidocSignatureSpan">(newState, newProps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shouldUpdate = function (newState, newProps) {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }

    if (this.$__isDirty === true) {
        // The UI component is still dirty after process state handlers
        // then we should rerender

        if (this.<span class="apidocCodeKeywordSpan">shouldUpdate</span>(input, state) !== false) {
            this.$__rerender();
        }
    }

    this.$__reset();
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.subscribeTo" id="apidoc.element.marko.Component.prototype.subscribeTo">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>subscribeTo
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeTo = function (target) {
    if (!target) {
        throw TypeError();
    }

    var subscriptions = this.$__subscriptions || (this.$__subscriptions = new SubscriptionTracker());

    var subscribeToOptions = target.$__isComponent ?
        COMPONENT_SUBSCRIBE_TO_OPTIONS :
        NON_COMPONENT_SUBSCRIBE_TO_OPTIONS;

    return subscriptions.subscribeTo(target, subscribeToOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var subscriptions = this.$__subscriptions || (this.$__subscriptions = new SubscriptionTracker());

var subscribeToOptions = target.$__isComponent ?
    COMPONENT_SUBSCRIBE_TO_OPTIONS :
    NON_COMPONENT_SUBSCRIBE_TO_OPTIONS;

return subscriptions.<span class="apidocCodeKeywordSpan">subscribeTo</span>(target, subscribeToOptions);
    },

    emit: function(eventType) {
var customEvents = this.$__customEvents;
var target;

if (customEvents &#x26;&#x26; (target = customEvents[eventType])) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.update" id="apidoc.element.marko.Component.prototype.update">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>update
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function () {
    if (this.$__destroyed === true || this.$__isDirty === false) {
        return;
    }

    var input = this.$__input;
    var state = this.$__state;

    if (this.$__dirty === false &#x26;&#x26; state !== null &#x26;&#x26; state.$__dirty === true) {
        if (processUpdateHandlers(this, state.$__changes, state.$__old, state)) {
            state.$__dirty = false;
        }
    }

    if (this.$__isDirty === true) {
        // The UI component is still dirty after process state handlers
        // then we should rerender

        if (this.shouldUpdate(input, state) !== false) {
            this.$__rerender();
        }
    }

    this.$__reset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.ComponentDef" id="apidoc.module.marko.ComponentDef">module marko.ComponentDef</a></h1>


    <h2>
        <a href="#apidoc.element.marko.ComponentDef.ComponentDef" id="apidoc.element.marko.ComponentDef.ComponentDef">
        function <span class="apidocSignatureSpan">marko.</span>ComponentDef
        <span class="apidocSignatureSpan">(component, componentId, out, componentStack, componentStackLen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ComponentDef(component, componentId, out, componentStack, componentStackLen) {
    this.$__out = out; // The AsyncWriter that this component is associated with
    this.$__componentStack = componentStack;
    this.$__componentStackLen = componentStackLen;
    this.$__component = component;
    this.id = componentId;

    this.$__roots =  null;            // IDs of root elements if there are multiple root elements
    this.$__children = null;          // An array of nested ComponentDef instances
    this.$__domEvents = null;         // An array of DOM events that need to be added (in sets of three)
    this.$__bubblingDomEvents = null; // Used to keep track of bubbling DOM events for components rendered on the server

    this.$__isExisting = false;

    this.$__nextIdIndex = 0; // The unique integer to use for the next scoped ID
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.ComponentDef.prototype" id="apidoc.module.marko.ComponentDef.prototype">module marko.ComponentDef.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.ComponentDef.prototype.d" id="apidoc.element.marko.ComponentDef.prototype.d">
        function <span class="apidocSignatureSpan">marko.ComponentDef.prototype.</span>d
        <span class="apidocSignatureSpan">(handlerMethodName, extraArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">d = function (handlerMethodName, extraArgs) {
    return attachBubblingEvent(this, handlerMethodName, extraArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.ComponentDef.prototype.e" id="apidoc.element.marko.ComponentDef.prototype.e">
        function <span class="apidocSignatureSpan">marko.ComponentDef.prototype.</span>e
        <span class="apidocSignatureSpan">(type, targetMethod, elId, extraArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">e = function (type, targetMethod, elId, extraArgs) {
    if (targetMethod) {
        // The event handler method is allowed to be conditional. At render time if the target
        // method is null then we do not attach any direct event listeners.
        (this.$__domEvents || (this.$__domEvents = [])).push([
            type,
            targetMethod,
            elId,
            extraArgs]);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.ComponentDef.prototype.elId" id="apidoc.element.marko.ComponentDef.prototype.elId">
        function <span class="apidocSignatureSpan">marko.ComponentDef.prototype.</span>elId
        <span class="apidocSignatureSpan">(nestedId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">elId = function (nestedId) {
    var id = this.id;
    if (nestedId == null) {
        return id;
    } else {
        if (typeof nestedId == &#x27;string&#x27; &#x26;&#x26; repeatedRegExp.test(nestedId)) {
            return nextRepeatedId(this.$__out, id, nestedId);
        } else {
            return id + &#x27;-&#x27; + nestedId;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.ComponentsContext" id="apidoc.module.marko.ComponentsContext">module marko.ComponentsContext</a></h1>


    <h2>
        <a href="#apidoc.element.marko.ComponentsContext.ComponentsContext" id="apidoc.element.marko.ComponentsContext.ComponentsContext">
        function <span class="apidocSignatureSpan">marko.</span>ComponentsContext
        <span class="apidocSignatureSpan">(out, parentComponentsContext, shouldAddGlobalRoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ComponentsContext(out, parentComponentsContext, shouldAddGlobalRoot) {
    var root;

    var globalComponentsContext;

    if (parentComponentsContext === undefined) {
        root = new ComponentDef(null, null, out);

        globalComponentsContext = out.global.components;
        if (globalComponentsContext === undefined) {
            out.global.components = globalComponentsContext = new GlobalComponentsContext(out);
        }

        if (shouldAddGlobalRoot !== false) {
            globalComponentsContext.$__roots.push(root);
        }
    } else {
        globalComponentsContext = parentComponentsContext.$__globalContext;
        var parentComponentStack = parentComponentsContext.$__componentStack;
        root = parentComponentStack[parentComponentStack.length-1];
    }

    this.$__globalContext = globalComponentsContext;
    this.$__out = out;
    this.$__componentStack = [root];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.ComponentsContext.prototype" id="apidoc.module.marko.ComponentsContext.prototype">module marko.ComponentsContext.prototype</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.HtmlJsParser" id="apidoc.module.marko.HtmlJsParser">module marko.HtmlJsParser</a></h1>


    <h2>
        <a href="#apidoc.element.marko.HtmlJsParser.HtmlJsParser" id="apidoc.element.marko.HtmlJsParser.HtmlJsParser">
        function <span class="apidocSignatureSpan">marko.</span>HtmlJsParser
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class HtmlJsParser {
    constructor(options) {
        this.ignorePlaceholders = options &#x26;&#x26; options.ignorePlaceholders === true;
    }

    parse(src, handlers, filename) {
        var listeners = {
            onText(event) {
                handlers.handleCharacters(event.value, event.parseMode);
            },

            onPlaceholder(event) {
                if (event.withinBody) {
                    if (!event.withinString) {
                        handlers.handleBodyTextPlaceholder(event.value, event.escape);
                    }
                } else if (event.withinOpenTag) {
                    // Don&#x27;t escape placeholder for dynamic attributes. For example: &#x3c;div ${data.myAttrs}&#x3e;&#x3c;/div&#x3e;
                } else {
                    // placeholder within attribute
                    if (event.escape) {
                        event.value = &#x27;$escapeXml(&#x27; + event.value + &#x27;)&#x27;;
                    } else {
                        event.value = &#x27;$noEscapeXml(&#x27; + event.value + &#x27;)&#x27;;
                    }
                }
                // placeholder within content

            },

            onCDATA(event) {
                handlers.handleCharacters(event.value, &#x27;static-text&#x27;);
            },

            onOpenTagName(event, parser) {
                event.selfClosed = false; // Don&#x27;t allow self-closed tags

                var tagParseOptions = handlers.getTagParseOptions(event);

                if (tagParseOptions) {
                    event.setParseOptions(tagParseOptions);
                }
            },

            onOpenTag(event, parser) {
                event.selfClosed = false; // Don&#x27;t allow self-closed tags
                handlers.handleStartElement(event, parser);

                var tagParseOptions = handlers.getTagParseOptions(event);
                if (tagParseOptions) {
                    event.setParseOptions(tagParseOptions);
                }
            },

            onCloseTag(event) {
                var tagName = event.tagName;
                handlers.handleEndElement(tagName);
            },

            onDocumentType(event) {

                // Document type: &#x3c;!DOCTYPE html PUBLIC &#x22;-//W3C//DTD XHTML 1.0 Transitional//EN&#x22; &#x22;http://www.w3.org/TR/xhtml1/DTD
/xhtml1-transitional.dtd
                // NOTE: The value will be all of the text between &#x22;&#x3c;!&#x22; and &#x22;&#x3e;&#x22;&#x22;
                handlers.handleDocumentType(event.value);
            },

            onDeclaration(event) {
                handlers.handleDeclaration(event.value);
            },

            onComment(event) {
                // Text within XML comment
                handlers.handleComment(event.value);
            },

            onScriptlet(event) {
                // &#x3c;% (code) %&#x3e; or $ {}
                handlers.handleScriptlet(event);
            },

            onError(event) {
                handlers.handleError(event);
            }
        };

        var parser = this.parser = htmljs.createParser(listeners, {
            ignorePlaceholders: this.ignorePlaceholders,
            isOpenTagOnly: function(tagName) {
                return handlers.isOpenTagOnly(tagName);
            }
        });
        parser.parse(src, filename);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.InlineCompiler" id="apidoc.module.marko.InlineCompiler">module marko.InlineCompiler</a></h1>


    <h2>
        <a href="#apidoc.element.marko.InlineCompiler.InlineCompiler" id="apidoc.element.marko.InlineCompiler.InlineCompiler">
        function <span class="apidocSignatureSpan">marko.</span>InlineCompiler
        <span class="apidocSignatureSpan">(context, compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineCompiler {
    constructor(context, compiler) {
        this.context = context;
        this.compiler = compiler;
        this.builder = context.builder;

        context.setInline(true);
    }

    compile(src) {
        src = normalizeTemplateSrc(src);
        // console.log(&#x27;TEMPLATE SRC:&#x3e;\n&#x27; + src + &#x27;\n&#x3c;&#x27;);
        return this.compiler.compile(src, this.context);
    }

    get staticCode() {
        let staticNodes = this.context.getStaticNodes();

        if (!staticNodes || staticNodes.length === 0) {
            return null;
        }

        let codeWriter = new CodeWriter(this.context.options, this.builder);
        codeWriter.write(staticNodes);
        return codeWriter.getCode();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.Parser" id="apidoc.module.marko.Parser">module marko.Parser</a></h1>


    <h2>
        <a href="#apidoc.element.marko.Parser.Parser" id="apidoc.element.marko.Parser.Parser">
        function <span class="apidocSignatureSpan">marko.</span>Parser
        <span class="apidocSignatureSpan">(parserImpl, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Parser {
    constructor(parserImpl, options) {
        ok(parserImpl, &#x27;&#x22;parserImpl&#x22; is required&#x27;);

        this.parserImpl = parserImpl;

        this.prevTextNode = null;
        this.stack = null;

        this.raw = options &#x26;&#x26; options.raw === true;

        // The context gets provided when parse is called
        // but we store it as part of the object so that the handler
        // methods have access
        this.context = null;
    }

    _reset() {
        this.prevTextNode = null;
        this.stack = [];
    }

    parse(src, context) {
        ok(typeof src === &#x27;string&#x27;, &#x27;&#x22;src&#x22; should be a string&#x27;);
        ok(context, &#x27;&#x22;context&#x22; is required&#x27;);

        this._reset();

        this.context = context;

        var builder = context.builder;
        var rootNode = builder.templateRoot();

        this.stack.push({
            node: rootNode
        });

        this.parserImpl.parse(src, this, context.filename);

        return rootNode;
    }

    handleCharacters(text, parseMode) {
        var builder = this.context.builder;

        var escape = parseMode !== &#x27;html&#x27;;
        // NOTE: If parseMode is &#x27;static-text&#x27; or &#x27;parsed-text&#x27; then that means that special
        //       HTML characters may not have been escaped on the way in so we need to escape
        //       them on the way out

        if (this.prevTextNode &#x26;&#x26; this.prevTextNode.isLiteral() &#x26;&#x26; this.prevTextNode.escape === escape) {
            this.prevTextNode.argument.value += text;
        } else {
            this.prevTextNode = builder.text(builder.literal(text), escape);
            this.parentNode.appendChild(this.prevTextNode);
        }
    }

    handleStartElement(el, parser) {
        var context = this.context;
        var builder = context.builder;

        var tagName = el.tagName;
        var tagNameExpression = el.tagNameExpression;
        var attributes = el.attributes;
        var argument = el.argument; // e.g. For &#x3c;for(color in colors)&#x3e;, argument will be &#x22;color in colors&#x22;

        if (argument) {
            argument = argument.value;
        }

        var raw = this.raw;

        if (!raw) {
            if (tagNameExpression) {
                tagName = builder.parseExpression(tagNameExpression);
            } else if (tagName === &#x27;marko-compiler-options&#x27;) {
                this.parentNode.setTrimStartEnd(true);

                attributes.forEach(function (attr) {
                    let attrName = attr.name;
                    let handler = COMPILER_ATTRIBUTE_HANDLERS[attrName];

                    if (!handler) {
                        context.addError({
                            code: &#x27;ERR_INVALID_COMPILER_OPTION&#x27;,
                            message: &#x27;Invalid Marko compiler option of &#x22;&#x27; + attrName + &#x27;&#x22;. Allowed: &#x27; + Object.keys(COMPILER_ATTRIBUTE_HANDLERS
).join(&#x27;, &#x27;),
                            pos: el.pos,
                            node: el
                        });
                        return;
                    }

                    handler(attr, context);
                });

                return;
            }
        }

        this.prevTextNode = null;

        var tagDef = el.tagName ? this.context.getTagDef(el.tagName) : null;

        var attributeParseErrors = [];
        // &#x3c;div class=&#x22;foo&#x22;&#x3e; -&#x3e; &#x22;div class=foo&#x22;
        var tagString = parser.substring(el.pos, el.endPos)
                              .replace(/^&#x3c;|\/&#x3e;$|&#x3e;$/g, &#x22;&#x22;).trim();

        var shouldParsedAttributes = !tagDef || tagDef.parseAttributes !== false;

        var parsedAttributes = [];

        if (shouldParsedAttributes) {
            attributes.forEach((attr) =&#x3e; {
                var attrValue;
                if (attr.hasOwnProperty(&#x27;literalValue&#x27;)) {
                    attrValue = builder.literal(attr.literalValue);
                } else if (attr.value == null) {
                    attrValue = undefined;
                } else {
                    let parsedExpression;
                    let valid = true;
                    try {
                        parsedExpression = builder.parseExpression(attr.value); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.RenderResult" id="apidoc.module.marko.RenderResult">module marko.RenderResult</a></h1>


    <h2>
        <a href="#apidoc.element.marko.RenderResult.RenderResult" id="apidoc.element.marko.RenderResult.RenderResult">
        function <span class="apidocSignatureSpan">marko.</span>RenderResult
        <span class="apidocSignatureSpan">(out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RenderResult(out) {
   this.out = this.$__out = out;
   this.$__components = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.RenderResult.prototype" id="apidoc.module.marko.RenderResult.prototype">module marko.RenderResult.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.afterInsert" id="apidoc.element.marko.RenderResult.prototype.afterInsert">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>afterInsert
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterInsert = function (doc) {
    var out = this.$__out;
    var globalComponentsContext = out.global.components;
    if (globalComponentsContext) {
        this.$__components = globalComponentsContext.$__initComponents(doc);
    } else {
        this.$__components = null;
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        onBeforeElChildrenUpdated);
                }
            }

            targetEl = targetEl.nextSibling;
        }

        result.<span class="apidocCodeKeywordSpan">afterInsert</span>(doc);

        out.emit(&#x27;$__componentsInitialized&#x27;);
    });

    this.$__reset();
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.appendTo" id="apidoc.element.marko.RenderResult.prototype.appendTo">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>appendTo
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendTo = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.appendChild(el);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.getComponent" id="apidoc.element.marko.RenderResult.prototype.getComponent">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComponent = function () {
    return this.getComponents()[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.getComponents" id="apidoc.element.marko.RenderResult.prototype.getComponents">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getComponents
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComponents = function (selector) {
    if (this.$__components === undefined) {
        throw Error(&#x27;Not added to DOM&#x27;);
    }

    var componentDefs = getComponentDefs(this);

    var components = [];

    componentDefs.forEach(function(componentDef) {
        var component = componentDef.$__component;
        if (!selector || selector(component)) {
            components.push(component);
        }
    });

    return components;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   this.$__components = undefined;
}

module.exports = RenderResult;

var proto = RenderResult.prototype = {
    getComponent: function() {
return this.<span class="apidocCodeKeywordSpan">getComponents</span>()[0];
    },
    getComponents: function(selector) {
if (this.$__components === undefined) {
    throw Error(&#x27;Not added to DOM&#x27;);
}

var componentDefs = getComponentDefs(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.getNode" id="apidoc.element.marko.RenderResult.prototype.getNode">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getNode
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNode = function (doc) {
    return this.$__out.$__getNode(doc);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// - replaceChildrenOf(referenceEl)
// - insertBefore(referenceEl)
// - insertAfter(referenceEl)
// - prependTo(referenceEl)
domInsert(
proto,
function getEl(renderResult, referenceEl) {
    return renderResult.<span class="apidocCodeKeywordSpan">getNode</span>(referenceEl.ownerDocument);
},
function afterInsert(renderResult, referenceEl) {
    return renderResult.afterInsert(referenceEl.ownerDocument);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.getOutput" id="apidoc.element.marko.RenderResult.prototype.getOutput">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getOutput
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOutput = function () {
    return this.$__out.$__getOutput();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.insertAfter" id="apidoc.element.marko.RenderResult.prototype.insertAfter">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>insertAfter
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertAfter = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    el = el;
    var nextSibling = referenceEl.nextSibling;
    var parentNode = referenceEl.parentNode;
    if (nextSibling) {
        parentNode.insertBefore(el, nextSibling);
    } else {
        parentNode.appendChild(el);
    }
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.insertBefore" id="apidoc.element.marko.RenderResult.prototype.insertBefore">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>insertBefore
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertBefore = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.parentNode.insertBefore(el, referenceEl);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var el = getEl(this, referenceEl);
    referenceEl.appendChild(el);
    return afterInsert(this, referenceEl);
},
prependTo: function(referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.<span class="apidocCodeKeywordSpan">insertBefore</span>(el, referenceEl.firstChild || null);
    return afterInsert(this, referenceEl);
},
replace: function(referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    beforeRemove(referenceEl);
    referenceEl.parentNode.replaceChild(el, referenceEl);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.prependTo" id="apidoc.element.marko.RenderResult.prototype.prependTo">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>prependTo
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependTo = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.insertBefore(el, referenceEl.firstChild || null);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.replace" id="apidoc.element.marko.RenderResult.prototype.replace">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>replace
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    beforeRemove(referenceEl);
    referenceEl.parentNode.replaceChild(el, referenceEl);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.prevTextNode = null;

var tagDef = el.tagName ? this.context.getTagDef(el.tagName) : null;

var attributeParseErrors = [];
// &#x3c;div class=&#x22;foo&#x22;&#x3e; -&#x3e; &#x22;div class=foo&#x22;
var tagString = parser.substring(el.pos, el.endPos)
                      .<span class="apidocCodeKeywordSpan">replace</span>(/^&#x3c;|\/&#x3e;$|&#x3e;$/g, &#x22;&#x22;).trim();

var shouldParsedAttributes = !tagDef || tagDef.parseAttributes !== false;

var parsedAttributes = [];

if (shouldParsedAttributes) {
    attributes.forEach((attr) =&#x3e; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.replaceChildrenOf" id="apidoc.element.marko.RenderResult.prototype.replaceChildrenOf">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>replaceChildrenOf
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceChildrenOf = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);

    var curChild = referenceEl.firstChild;
    while(curChild) {
        var nextSibling = curChild.nextSibling; // Just in case the DOM changes while removing
        if (curChild.nodeType == 1) {
            beforeRemove(curChild);
        }
        curChild = nextSibling;
    }

    referenceEl.innerHTML = &#x27;&#x27;;
    referenceEl.appendChild(el);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.toString" id="apidoc.element.marko.RenderResult.prototype.toString">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return this.$__out.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        node.writeCode(this);
    } else if (isArray(code) || code instanceof Container) {
        code.forEach(this.write, this);
        return;
    } else if (typeof code === &#x27;string&#x27;) {
        this._code += code;
    }  else if (typeof code === &#x27;boolean&#x27; || typeof code === &#x27;number&#x27;) {
        this._code += code.<span class="apidocCodeKeywordSpan">toString</span>();
    } else {
        throw new Error(&#x27;Illegal argument: &#x27; + JSON.stringify(code));
    }

    return this;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.State" id="apidoc.module.marko.State">module marko.State</a></h1>


    <h2>
        <a href="#apidoc.element.marko.State.State" id="apidoc.element.marko.State.State">
        function <span class="apidocSignatureSpan">marko.</span>State
        <span class="apidocSignatureSpan">(component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function State(component) {
    this.$__component = component;
    this.$__raw = {};

    this.$__dirty = false;
    this.$__old = null;
    this.$__changes = null;
    this.$__forced = null; // An object that we use to keep tracking of state properties that were forced to be dirty

    Object.seal(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.State.prototype" id="apidoc.module.marko.State.prototype">module marko.State.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.State.prototype.toJSON" id="apidoc.element.marko.State.prototype.toJSON">
        function <span class="apidocSignatureSpan">marko.State.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
    return this.$__raw;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.Walker" id="apidoc.module.marko.Walker">module marko.Walker</a></h1>


    <h2>
        <a href="#apidoc.element.marko.Walker.Walker" id="apidoc.element.marko.Walker.Walker">
        function <span class="apidocSignatureSpan">marko.</span>Walker
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Walker {
    constructor(options) {
        this._enter = options.enter || noop;
        this._exit = options.exit || noop;
        this._enterArray = options.enterArray || noop;
        this._exitArray = options.exitArray || noop;
        this._stopped = false;
        this._reset();
        this._stack = [];
    }

    _reset() {
        this._skipped = false;
        this._replaced = undefined;
        this._removed = false;
    }

    skip() {
        this._skipped = true;
    }

    stop() {
        this._stopped = true;
    }

    replace(newNode) {
        this._replaced = newNode;
    }

    remove() {
        this._removed = true;
    }

    _walkArray(array) {
        var hasRemoval = false;

        array = this._enterArray(array) || array;

        array.forEach((node, i) =&#x3e; {
            var transformed = this.walk(node);
            if (transformed == null) {
                array[i] = null;
                hasRemoval = true;
            } else if (transformed !== node) {
                array[i] = transformed;
            }
        });

        if (hasRemoval) {
            for (let i=array.length-1; i&#x3e;=0; i--) {
                if (array[i] == null) {
                    array.splice(i, 1);
                }
            }
        }

        array = this._exitArray(array) || array;

        return array;
    }

    _walkContainer(nodes) {
        nodes.forEach((node) =&#x3e; {
            var transformed = this.walk(node);
            if (!transformed) {
                node.container.removeChild(node);
            } else if (transformed !== node) {
                node.container.replaceChild(transformed, node);
            }
        });
    }

    walk(node) {
        if (!node || this._stopped || typeof node === &#x27;string&#x27;) {
            return node;
        }

        this._reset();

        var parent = this._stack.length ? this._stack[this._stack.length - 1] : undefined;

        this._stack.push(node);

        var replaced = this._enter(node, parent);
        if (replaced === undefined) {
            replaced = this._replaced;
        }

        if (this._removed) {
            replaced = null;
        }

        if (replaced !== undefined) {
            this._stack.pop();
            return replaced;
        }

        if (this._skipped || this._stopped) {
            this._stack.pop();
            return node;
        }

        if (isArray(node)) {
            let array = node;
            let newArray = this._walkArray(array);
            this._stack.pop();
            return newArray;
        } else if (node instanceof Container) {
            let container = node;
            this._walkContainer(container);
            this._stack.pop();
            return container;
        } else {
            if (node.walk) {
                node.walk(this);
            }
        }

        if (this._stopped) {
            this._stack.pop();
            return node;
        }

        this._reset();

        replaced = this._exit(node, parent);
        if (replaced === undefined) {
            replaced = this._replaced;
        }

        if (this._removed) {
            replaced = null;
        }

        if (replaced !== undefined) {
            this._stack.pop();
            return replaced;
        }

        this._stack.pop();
        return node;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.createOut" id="apidoc.module.marko.createOut">module marko.createOut</a></h1>


    <h2>
        <a href="#apidoc.element.marko.createOut.createOut" id="apidoc.element.marko.createOut.createOut">
        function <span class="apidocSignatureSpan">marko.</span>createOut
        <span class="apidocSignatureSpan">(globalData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createOut(globalData) {
    return actualCreateOut(globalData);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.defineComponent" id="apidoc.module.marko.defineComponent">module marko.defineComponent</a></h1>


    <h2>
        <a href="#apidoc.element.marko.defineComponent.defineComponent" id="apidoc.element.marko.defineComponent.defineComponent">
        function <span class="apidocSignatureSpan">marko.</span>defineComponent
        <span class="apidocSignatureSpan">(def, renderer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineComponent(def, renderer) {
    if (def.$__isComponent) {
        return def;
    }

    var ComponentClass = function() {};
    var proto;

    var type = typeof def;

    if (type == &#x27;function&#x27;) {
        proto = def.prototype;
    } else if (type == &#x27;object&#x27;) {
        proto = def;
    } else {
        throw TypeError();
    }

    ComponentClass.prototype = proto;

    // We don&#x27;t use the constructor provided by the user
    // since we don&#x27;t invoke their constructor until
    // we have had a chance to do our own initialization.
    // Instead, we store their constructor in the &#x22;initComponent&#x22;
    // property and that method gets called later inside
    // init-components-browser.js
    function Component(id) {
        BaseComponent.call(this, id);
    }

    if (!proto.$__isComponent) {
        // Inherit from Component if they didn&#x27;t already
        inherit(ComponentClass, BaseComponent);
    }

    // The same prototype will be used by our constructor after
    // we he have set up the prototype chain using the inherit function
    proto = Component.prototype = ComponentClass.prototype;

    // proto.constructor = def.constructor = Component;

    // Set a flag on the constructor function to make it clear this is
    // a component so that we can short-circuit this work later
    Component.$__isComponent = true;

    function State(component) { BaseState.call(this, component); }
    inherit(State, BaseState);
    proto.$__State = State;
    proto.$__renderer = renderer;

    return Component;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.defineRenderer" id="apidoc.module.marko.defineRenderer">module marko.defineRenderer</a></h1>


    <h2>
        <a href="#apidoc.element.marko.defineRenderer.defineRenderer" id="apidoc.element.marko.defineRenderer.defineRenderer">
        function <span class="apidocSignatureSpan">marko.</span>defineRenderer
        <span class="apidocSignatureSpan">(def)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineRenderer(def) {
    var template = def.template;
    var getTemplateData = def.getTemplateData;
    var renderer = def.renderer;

    if (typeof template === &#x27;string&#x27;) {
        template = marko.load(template);
    }

    var createOut;

    if (template) {
        createOut = template.createOut;
    } else {
        createOut = def.createOut || marko.createOut;
    }

    if (!renderer) {
        // Create a renderer function that takes care of translating
        // the input properties to a view state. Also, this renderer
        // takes care of re-using existing components.
        renderer = function renderer(input, out) {
            var newProps = input;

            if (!newProps) {
                // Make sure we always have a non-null input object
                newProps = {};
            }

            // Use getTemplateData(state, props, out) to get the template
            // data. If that method is not provided then just use the
            // the state (if provided) or the input data.
            var templateData = getTemplateData ?
                getTemplateData(newProps, out) :
                newProps;

            // Render the template associated with the component using the final template
            // data that we constructed
            template.render(templateData, out);
        };
    }

    renderer.render = function(input) {
        var out = createOut();
        renderer(input, out);
        return out.end();
    };

    return renderer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.dom_insert" id="apidoc.module.marko.dom_insert">module marko.dom_insert</a></h1>


    <h2>
        <a href="#apidoc.element.marko.dom_insert.dom_insert" id="apidoc.element.marko.dom_insert.dom_insert">
        function <span class="apidocSignatureSpan">marko.</span>dom_insert
        <span class="apidocSignatureSpan">(target, getEl, afterInsert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dom_insert = function (target, getEl, afterInsert) {
    extend(target, {
        appendTo: function(referenceEl) {
            referenceEl = resolveEl(referenceEl);
            var el = getEl(this, referenceEl);
            referenceEl.appendChild(el);
            return afterInsert(this, referenceEl);
        },
        prependTo: function(referenceEl) {
            referenceEl = resolveEl(referenceEl);
            var el = getEl(this, referenceEl);
            referenceEl.insertBefore(el, referenceEl.firstChild || null);
            return afterInsert(this, referenceEl);
        },
        replace: function(referenceEl) {
            referenceEl = resolveEl(referenceEl);
            var el = getEl(this, referenceEl);
            beforeRemove(referenceEl);
            referenceEl.parentNode.replaceChild(el, referenceEl);
            return afterInsert(this, referenceEl);
        },
        replaceChildrenOf: function(referenceEl) {
            referenceEl = resolveEl(referenceEl);
            var el = getEl(this, referenceEl);

            var curChild = referenceEl.firstChild;
            while(curChild) {
                var nextSibling = curChild.nextSibling; // Just in case the DOM changes while removing
                if (curChild.nodeType == 1) {
                    beforeRemove(curChild);
                }
                curChild = nextSibling;
            }

            referenceEl.innerHTML = &#x27;&#x27;;
            referenceEl.appendChild(el);
            return afterInsert(this, referenceEl);
        },
        insertBefore: function(referenceEl) {
            referenceEl = resolveEl(referenceEl);
            var el = getEl(this, referenceEl);
            referenceEl.parentNode.insertBefore(el, referenceEl);
            return afterInsert(this, referenceEl);
        },
        insertAfter: function(referenceEl) {
            referenceEl = resolveEl(referenceEl);
            var el = getEl(this, referenceEl);
            el = el;
            var nextSibling = referenceEl.nextSibling;
            var parentNode = referenceEl.parentNode;
            if (nextSibling) {
                parentNode.insertBefore(el, nextSibling);
            } else {
                parentNode.appendChild(el);
            }
            return afterInsert(this, referenceEl);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.empty" id="apidoc.module.marko.empty">module marko.empty</a></h1>


    <h2>
        <a href="#apidoc.element.marko.empty.empty" id="apidoc.element.marko.empty.empty">
        function <span class="apidocSignatureSpan">marko.</span>empty
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function (o) {
    return !notEmpty(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.event_delegation" id="apidoc.module.marko.event_delegation">module marko.event_delegation</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.helper_forEachPropStatusVar" id="apidoc.module.marko.helper_forEachPropStatusVar">module marko.helper_forEachPropStatusVar</a></h1>


    <h2>
        <a href="#apidoc.element.marko.helper_forEachPropStatusVar.helper_forEachPropStatusVar" id="apidoc.element.marko.helper_forEachPropStatusVar.helper_forEachPropStatusVar">
        function <span class="apidocSignatureSpan">marko.</span>helper_forEachPropStatusVar
        <span class="apidocSignatureSpan">(object, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachPropStatusVarHelper(object, callback) {
    var keys = Object.keys(object);

    var i = 0;
    var len = keys.length;
    var loopStatus = new LoopStatus(
            function getLength() {
                return len;
            },
            function isLast() {
                return i === len - 1;
            },
            function isFirst() {
                return i === 0;
            },
            function getIndex() {
                return i;
            });

    for (; i &#x3c; len; i++) {
        var key = keys[i];
        var value = object[key];
        callback(key, value, loopStatus);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.helper_forEachProperty" id="apidoc.module.marko.helper_forEachProperty">module marko.helper_forEachProperty</a></h1>


    <h2>
        <a href="#apidoc.element.marko.helper_forEachProperty.helper_forEachProperty" id="apidoc.element.marko.helper_forEachProperty.helper_forEachProperty">
        function <span class="apidocSignatureSpan">marko.</span>helper_forEachProperty
        <span class="apidocSignatureSpan">(o, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachPropertyHelper(o, func) {
    if (!o) {
        return;
    }

    if (isArray(o)) {
        for (var i=0; i&#x3c;o.length; i++) {
            func(i, o[i]);
        }
    } else if (typeof Map &#x26;&#x26; o instanceof Map) {
        o.forEach(function(v, k) {
            func(k, v);
        });
    } else {
        for (var k in o) {
            if (o.hasOwnProperty(k)) {
                func(k, o[k]);
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.helper_forEachWithStatusVar" id="apidoc.module.marko.helper_forEachWithStatusVar">module marko.helper_forEachWithStatusVar</a></h1>


    <h2>
        <a href="#apidoc.element.marko.helper_forEachWithStatusVar.helper_forEachWithStatusVar" id="apidoc.element.marko.helper_forEachWithStatusVar.helper_forEachWithStatusVar">
        function <span class="apidocSignatureSpan">marko.</span>helper_forEachWithStatusVar
        <span class="apidocSignatureSpan">(array, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachStatusVariableHelper(array, callback) {
    if (!array) {
        return;
    }
    if (!array.forEach) {
        array = [array];
    }

    var len = array.length;
    var loopStatus = new LoopStatus(len);

    for (; loopStatus.i &#x3c; len; loopStatus.i++) {
        var o = array[loopStatus.i];
        callback(o, loopStatus);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.helper_forRange" id="apidoc.module.marko.helper_forRange">module marko.helper_forRange</a></h1>


    <h2>
        <a href="#apidoc.element.marko.helper_forRange.helper_forRange" id="apidoc.element.marko.helper_forRange.helper_forRange">
        function <span class="apidocSignatureSpan">marko.</span>helper_forRange
        <span class="apidocSignatureSpan">(from, to, step, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forRangeHelper(from, to, step, callback) {
    if (step == null) {
        step = from &#x3c;= to ? 1 : -1;
    }

    var i;

    if (step &#x3e; 0) {
        for (i=from; i&#x3c;=to; i += step) {
            callback(i);
        }
    } else {
        for (i=from; i&#x3e;=to; i += step) {
            callback(i);
        }
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.helper_loadNestedTag" id="apidoc.module.marko.helper_loadNestedTag">module marko.helper_loadNestedTag</a></h1>


    <h2>
        <a href="#apidoc.element.marko.helper_loadNestedTag.helper_loadNestedTag" id="apidoc.element.marko.helper_loadNestedTag.helper_loadNestedTag">
        function <span class="apidocSignatureSpan">marko.</span>helper_loadNestedTag
        <span class="apidocSignatureSpan">(targetProperty, isRepeated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadNestedTagHelper(targetProperty, isRepeated) {
    return function(input, parent) {
        // If we are nested tag then we do not have a renderer
        if (isRepeated) {
            var existingArray = parent[targetProperty];
            if (existingArray) {
                existingArray.push(input);
            } else {
                parent[targetProperty] = [input];
            }
        } else {
            parent[targetProperty] = input;
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.helper_merge" id="apidoc.module.marko.helper_merge">module marko.helper_merge</a></h1>


    <h2>
        <a href="#apidoc.element.marko.helper_merge.helper_merge" id="apidoc.element.marko.helper_merge.helper_merge">
        function <span class="apidocSignatureSpan">marko.</span>helper_merge
        <span class="apidocSignatureSpan">(into, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(into, source) {
    for (var k in source) {
        if (source.hasOwnProperty(k) &#x26;&#x26; !into.hasOwnProperty(k)) {
            into[k] = source[k];
        }
    }
    return into;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.helper_mergeNestedTags" id="apidoc.module.marko.helper_mergeNestedTags">module marko.helper_mergeNestedTags</a></h1>


    <h2>
        <a href="#apidoc.element.marko.helper_mergeNestedTags.helper_mergeNestedTags" id="apidoc.element.marko.helper_mergeNestedTags.helper_mergeNestedTags">
        function <span class="apidocSignatureSpan">marko.</span>helper_mergeNestedTags
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeNestedTags(input) {
    if (input.renderBody) {
        input.renderBody(null, input);
    }
    input.renderBody = null;
    return input;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.helpers" id="apidoc.module.marko.helpers">module marko.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.marko.helpers.cl" id="apidoc.element.marko.helpers.cl">
        function <span class="apidocSignatureSpan">marko.helpers.</span>cl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function classListHelper() {
    var classNames = [];
    classList(arguments, classNames);
    return classNames.join(&#x27; &#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helpers.f" id="apidoc.element.marko.helpers.f">
        function <span class="apidocSignatureSpan">marko.helpers.</span>f
        <span class="apidocSignatureSpan">(array, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachHelper(array, callback) {
    if (isArray(array)) {
        for (var i=0; i&#x3c;array.length; i++) {
            callback(array[i]);
        }
    } else if (isFunction(array)) {
        // Also allow the first argument to be a custom iterator function
        array(callback);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helpers.s" id="apidoc.element.marko.helpers.s">
        function <span class="apidocSignatureSpan">marko.helpers.</span>s
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function strHelper(str) {
    return (str == null) ? &#x27;&#x27; : str.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helpers.t" id="apidoc.element.marko.helpers.t">
        function <span class="apidocSignatureSpan">marko.helpers.</span>t
        <span class="apidocSignatureSpan">(renderer, targetProperty, isRepeated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadTagHelper(renderer, targetProperty, isRepeated) {
    if (renderer) {
        renderer = resolveRenderer(renderer);
    }

    return renderer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.html" id="apidoc.module.marko.html">module marko.html</a></h1>


    <h2>
        <a href="#apidoc.element.marko.html.AsyncStream" id="apidoc.element.marko.html.AsyncStream">
        function <span class="apidocSignatureSpan">marko.html.</span>AsyncStream
        <span class="apidocSignatureSpan">(global, writer, state, shouldBuffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncStream(global, writer, state, shouldBuffer) {
    var finalGlobal = this.attributes = global || {};
    var originalStream;

    if (state) {
        originalStream = state.stream;
    } else {
        var events = finalGlobal.events /* deprecated */ = writer &#x26;&#x26; writer.on ? writer : new EventEmitter();

        if (writer) {
            originalStream = writer;
            if (shouldBuffer) {
                writer = new BufferedWriter(writer);
            }
        } else {
            writer = originalStream = new StringWriter();
        }

        state = new State(this, originalStream, writer, events);
    }

    this.global = finalGlobal;
    this.stream = originalStream;
    this._state = state;

    this.data = {};
    this.writer = writer;
    writer.stream = this;

    this._sync = false;
    this._stack = undefined;
    this.name = undefined;
    this._timeoutId = undefined;

    this._node = undefined;

    this._elStack = undefined; // Array

    this.$c = null; // Component args
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.html.Template" id="apidoc.element.marko.html.Template">
        function <span class="apidocSignatureSpan">marko.html.</span>Template
        <span class="apidocSignatureSpan">(path, renderFunc, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Template(path, renderFunc, options) {
    this.path = path;
    this._ = renderFunc;
    this.$__shouldBuffer = !options || options.shouldBuffer !== false;
    this.meta = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.html.createWriter" id="apidoc.element.marko.html.createWriter">
        function <span class="apidocSignatureSpan">marko.html.</span>createWriter
        <span class="apidocSignatureSpan">(writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createWriter = function (writer) {
    return new AsyncStream(null, writer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.html.enableAsyncStackTrace" id="apidoc.element.marko.html.enableAsyncStackTrace">
        function <span class="apidocSignatureSpan">marko.html.</span>enableAsyncStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableAsyncStackTrace = function () {
    AsyncStream.INCLUDE_STACK = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.html.t" id="apidoc.element.marko.html.t">
        function <span class="apidocSignatureSpan">marko.html.</span>t
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTemplate(path) {
     return new Template(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.jquery" id="apidoc.module.marko.jquery">module marko.jquery</a></h1>


    <h2>
        <a href="#apidoc.element.marko.jquery.patchComponent" id="apidoc.element.marko.jquery.patchComponent">
        function <span class="apidocSignatureSpan">marko.jquery.</span>patchComponent
        <span class="apidocSignatureSpan">(jQuery)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patchComponent = function (jQuery) {
<span class="apidocCodeCommentSpan">    /* globals window */
</span>
    if (!jQuery) {
        jQuery = window.$;
        if (!jQuery) {
            throw new Error(&#x27;jQuery not found&#x27;);
        }
    }

    require(&#x27;./components/Component&#x27;).prototype.$ = function jqueryProxy(arg) {
        var args = arguments;
        var self = this;

        if (args.length === 1) {
            //Handle an &#x22;ondomready&#x22; callback function
            if (typeof arg === &#x27;function&#x27;) {
                return ready(function() {
                    arg.call(self);
                });
            } else if (typeof arg === &#x27;string&#x27;) {
                var match = idRegExp.exec(arg);
                //Reset the search to 0 so the next call to exec will start from the beginning for the new string
                if (match != null) {
                    var componentElId = match[1];
                    if (match[2] == null) {
                        return jQuery(self.getEl(componentElId));
                    } else {
                        return jQuery(&#x27;#&#x27; + self.getElId(componentElId) + match[2]);
                    }
                } else {
                    var rootEl = self.getEl();
                    if (!rootEl) {
                        throw new Error(&#x27;Root element is not defined for component&#x27;);
                    }
                    if (rootEl) {
                        return jQuery(arg, rootEl);
                    }
                }
            }
        } else if (args.length === 2 &#x26;&#x26; typeof args[1] === &#x27;string&#x27;) {
            return jQuery(arg, self.getEl(args[1]));
        } else if (args.length === 0) {
            return jQuery(self.el);
        }
        return jQuery.apply(window, arguments);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.load" id="apidoc.module.marko.load">module marko.load</a></h1>


    <h2>
        <a href="#apidoc.element.marko.load.load" id="apidoc.element.marko.load.load">
        function <span class="apidocSignatureSpan">marko.</span>load
        <span class="apidocSignatureSpan">(templatePath, templateSrc, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(templatePath, templateSrc, options) {
    if (typeof templatePath === &#x27;string&#x27; &#x26;&#x26; nodePath.extname(templatePath) === &#x27;.js&#x27;) {
        // assume compiled template
        return require(templatePath);
    }

    if (arguments.length === 1) {
        return doLoad(templatePath);
    } else if (arguments.length === 2) {
        // see if second argument is templateSrc (a String)
        // or options (an Object)
        var lastArg = arguments[arguments.length - 1];
        if (typeof lastArg === &#x27;string&#x27;) {
            return doLoad(templatePath, templateSrc);
        } else {
            var finalOptions = templateSrc;
            return doLoad(templatePath, null, finalOptions);
        }
    } else if (arguments.length === 3) {
        // assume function called according to function signature
        return doLoad(templatePath, templateSrc, options);
    } else {
        throw new Error(&#x27;Illegal arguments&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function defineRenderer(def) {
var template = def.template;
var getTemplateData = def.getTemplateData;
var renderer = def.renderer;

if (typeof template === &#x27;string&#x27;) {
    template = marko.<span class="apidocCodeKeywordSpan">load</span>(template);
}

var createOut;

if (template) {
    createOut = template.createOut;
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.loadComponent" id="apidoc.module.marko.loadComponent">module marko.loadComponent</a></h1>


    <h2>
        <a href="#apidoc.element.marko.loadComponent.loadComponent" id="apidoc.element.marko.loadComponent.loadComponent">
        function <span class="apidocSignatureSpan">marko.</span>loadComponent
        <span class="apidocSignatureSpan">(typeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(typeName) {
    throw new Error(&#x27;Not found: &#x27; + typeName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.loadComponent_dynamic" id="apidoc.module.marko.loadComponent_dynamic">module marko.loadComponent_dynamic</a></h1>


    <h2>
        <a href="#apidoc.element.marko.loadComponent_dynamic.loadComponent_dynamic" id="apidoc.element.marko.loadComponent_dynamic.loadComponent_dynamic">
        function <span class="apidocSignatureSpan">marko.</span>loadComponent_dynamic
        <span class="apidocSignatureSpan">(typeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(typeName) {
    // We make the assumption that the component type name is a path to a
    // fully resolved module path and that the module exists
    // as a CommonJS module
    return require(typeName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.modules" id="apidoc.module.marko.modules">module marko.modules</a></h1>


    <h2>
        <a href="#apidoc.element.marko.modules.deresolve" id="apidoc.element.marko.modules.deresolve">
        function <span class="apidocSignatureSpan">marko.modules.</span>deresolve
        <span class="apidocSignatureSpan">(targetFilename, from)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deresolve = function (targetFilename, from) {
    return deresolve(targetFilename, from, deresolveOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

getErrors() {
    return this._errors;
}

getRequirePath(targetFilename) {
    return markoModules.<span class="apidocCodeKeywordSpan">deresolve</span>(targetFilename, this.dirname);
}

importModule(varName, path) {
    if (typeof path !== &#x27;string&#x27;) {
        throw new Error(&#x27;&#x22;path&#x22; should be a string&#x27;);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.modules.require" id="apidoc.element.marko.modules.require">
        function <span class="apidocSignatureSpan">marko.modules.</span>require
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require = function (path) {
    return nativeRequire(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        throw new Error(&#x27;&#x22;path&#x22; should be a string&#x27;);
    }

    var varId = this._imports[path];

    if (!varId) {
        var builder = this.builder;
        var requireFuncCall = this.builder.<span class="apidocCodeKeywordSpan">require</span>(builder.literal(path));
        this._imports[path] = varId = this.addStaticVar(varName, requireFuncCall);
    }

    return varId;
}

addVar(name, init) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.modules.resolve" id="apidoc.element.marko.modules.resolve">
        function <span class="apidocSignatureSpan">marko.modules.</span>resolve
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (path) {
    return nativeRequire.resolve(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var templateVar;

if (this.options.browser || this.options.requireTemplates) {
    // When compiling a Marko template for the browser we just use `require(&#x27;./template.marko&#x27;)`
    templateVar = this.addStaticVar(varName, builder.require(builder.literal(relativePath)));
} else {
    // When compiling a Marko template for the server we just use `loadTemplate(require.<span class="apidocCodeKeywordSpan">resolve
</span>(&#x27;./template.marko&#x27;))`
    let loadTemplateArg = requireResolve(builder, builder.literal(relativePath));
    let loadFunctionCall = builder.functionCall(this.helper(&#x27;loadTemplate&#x27;), [ loadTemplateArg ]);
    templateVar = this.addStaticVar(varName, loadFunctionCall);
}

this.pushMeta(&#x27;tags&#x27;, builder.literal(relativePath), true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.modules.resolveFrom" id="apidoc.element.marko.modules.resolveFrom">
        function <span class="apidocSignatureSpan">marko.modules.</span>resolveFrom
        <span class="apidocSignatureSpan">(from, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveFrom = function (from, target) {
    return resolveFrom(from, target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.nextRepeatedId" id="apidoc.module.marko.nextRepeatedId">module marko.nextRepeatedId</a></h1>


    <h2>
        <a href="#apidoc.element.marko.nextRepeatedId.nextRepeatedId" id="apidoc.element.marko.nextRepeatedId.nextRepeatedId">
        function <span class="apidocSignatureSpan">marko.</span>nextRepeatedId
        <span class="apidocSignatureSpan">(out, parentId, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextRepeatedId(out, parentId, id) {
    var nextIdLookup = out.global[REPEATED_ID_KEY] || (out.global[REPEATED_ID_KEY] = {});

    var indexLookupKey = parentId + &#x27;-&#x27; + id;
    var currentIndex = nextIdLookup[indexLookupKey];
    if (currentIndex == null) {
        currentIndex = nextIdLookup[indexLookupKey] = 0;
    } else {
        currentIndex = ++nextIdLookup[indexLookupKey];
    }

    return indexLookupKey.slice(0, -2) + &#x27;[&#x27; + currentIndex + &#x27;]&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.nextTick" id="apidoc.module.marko.nextTick">module marko.nextTick</a></h1>


    <h2>
        <a href="#apidoc.element.marko.nextTick.nextTick" id="apidoc.element.marko.nextTick.nextTick">
        function <span class="apidocSignatureSpan">marko.</span>nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
  if (typeof callback !== &#x27;function&#x27;)
    throw new TypeError(&#x27;callback is not a function&#x27;);
  // on the way out, don&#x27;t bother. it won&#x27;t get fired anyway.
  if (process._exiting)
    return;

  var args;
  if (arguments.length &#x3e; 1) {
    args = new Array(arguments.length - 1);
    for (var i = 1; i &#x3c; arguments.length; i++)
      args[i - 1] = arguments[i];
  }

  nextTickQueue.push({
    callback,
    domain: process.domain || null,
    args
  });
  tickInfo[kLength]++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.node_require" id="apidoc.module.marko.node_require">module marko.node_require</a></h1>


    <h2>
        <a href="#apidoc.element.marko.node_require.getExtensions" id="apidoc.element.marko.node_require.getExtensions">
        function <span class="apidocSignatureSpan">marko.node_require.</span>getExtensions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getExtensions = function () {
    return require.extensions[MARKO_EXTENSIONS];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.node_require.install" id="apidoc.element.marko.node_require.install">
        function <span class="apidocSignatureSpan">marko.node_require.</span>install
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function install(options) {
    options = options || {};

    var requireExtensions = options.require ? // options.require introduced for testing
        options.require.extensions :
        require.extensions;

    var compilerOptions = options.compilerOptions;

    if (compilerOptions) {
        require(&#x27;./compiler&#x27;).configure(compilerOptions);
    } else {
        compilerOptions = {};
    }

    var extensions = [];

    if (options.extension) {
        extensions.push(options.extension);
    }

    if (options.extensions) {
        extensions = extensions.concat(options.extensions);
    }

    if (extensions.length === 0) {
        extensions.push(&#x27;.marko&#x27;);
    }

    function markoRequireExtension(module, filename) {
        var targetFile = filename + &#x27;.js&#x27;;
        var cachedTemplate = getLoadedTemplate(targetFile) || getLoadedTemplate(filename);
        if (cachedTemplate) {
            // The template has already been loaded so use the exports of the already loaded template
            module.exports = cachedTemplate;
            return;
        }

        // Resolve the appropriate compiler relative to the location of the
        // marko template file on disk using the &#x22;resolve-from&#x22; module.
        var dirname = path.dirname(filename);
        var markoCompilerModulePath = resolveFrom(dirname, &#x27;marko/compiler&#x27;);
        var markoCompiler = require(markoCompilerModulePath);

        // Now use the appropriate Marko compiler to compile the Marko template
        // file to JavaScript source code:
        var compiledSrc = compile(filename, markoCompiler, compilerOptions);

        // Append &#x22;.js&#x22; to the filename since that is where we write the compiled
        // source code that is being loaded. This allows stack traces to match up.
        module._compile(compiledSrc, targetFile);
    }

    requireExtensions[MARKO_EXTENSIONS] = requireExtensions[MARKO_EXTENSIONS] ||
        (requireExtensions[MARKO_EXTENSIONS] = []);

    extensions.forEach((extension) =&#x3e; {
        extension = normalizeExtension(extension);
        requireExtensions[extension] = markoRequireExtension;
        requireExtensions[MARKO_EXTENSIONS].push(extension);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.node_require_browser" id="apidoc.module.marko.node_require_browser">module marko.node_require_browser</a></h1>


    <h2>
        <a href="#apidoc.element.marko.node_require_browser.install" id="apidoc.element.marko.node_require_browser.install">
        function <span class="apidocSignatureSpan">marko.node_require_browser.</span>install
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.notEmpty" id="apidoc.module.marko.notEmpty">module marko.notEmpty</a></h1>


    <h2>
        <a href="#apidoc.element.marko.notEmpty.notEmpty" id="apidoc.element.marko.notEmpty.notEmpty">
        function <span class="apidocSignatureSpan">marko.</span>notEmpty
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notEmpty(o) {
    if (o == null) {
        return false;
    } else if (Array.isArray(o)) {
        return !!o.length;
    } else if (o === &#x27;&#x27;) {
        return false;
    }

    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.ready" id="apidoc.module.marko.ready">module marko.ready</a></h1>


    <h2>
        <a href="#apidoc.element.marko.ready.ready" id="apidoc.element.marko.ready.ready">
        function <span class="apidocSignatureSpan">marko.</span>ready
        <span class="apidocSignatureSpan">(callback, thisObj, doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ready(callback, thisObj, doc) {
    if (isReady) {
        return callback.call(thisObj);
    }

    listeners.push([callback, thisObj]);

    if (!readyBound) {
        readyBound = true;
        bindReady(doc || defaultDocument);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.ready.patchComponent" id="apidoc.element.marko.ready.patchComponent">
        function <span class="apidocSignatureSpan">marko.ready.</span>patchComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patchComponent = function () {
    require(&#x27;./components/Component&#x27;).prototype.ready = function (callback) {
        var document = this.el.ownerDocument;
        ready(callback, this, document);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.registry" id="apidoc.module.marko.registry">module marko.registry</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.registry_browser" id="apidoc.module.marko.registry_browser">module marko.registry_browser</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.renderable" id="apidoc.module.marko.renderable">module marko.renderable</a></h1>


    <h2>
        <a href="#apidoc.element.marko.renderable.renderable" id="apidoc.element.marko.renderable.renderable">
        function <span class="apidocSignatureSpan">marko.</span>renderable
        <span class="apidocSignatureSpan">(target, renderer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderable = function (target, renderer) {
    var renderFunc = renderer &#x26;&#x26; (renderer.renderer || renderer.render || renderer);
    var createOut = target.createOut || renderer.createOut || defaultCreateOut;

    return extend(target, {
        createOut: createOut,

        renderToString: function(data, callback) {
            var localData = data || {};
            var render = renderFunc || this._;
            var globalData = localData.$global;
            var out = createOut(globalData);

            out.global.template = this;

            if (globalData) {
                localData.$global = undefined;
            }

            if (callback) {
                out.on(&#x27;finish&#x27;, function() {
                       callback(null, out.toString(), out);
                   })
                   .once(&#x27;error&#x27;, callback);

                return safeRender(render, localData, out, true);
            } else {
                out.sync();
                render(localData, out);
                return out.toString();
            }
        },

        renderSync: function(data) {
            var localData = data || {};
            var render = renderFunc || this._;
            var globalData = localData.$global;
            var out = createOut(globalData);
            out.sync();

            out.global.template = this;

            if (globalData) {
                localData.$global = undefined;
            }

            render(localData, out);
            return out.$__getResult();
        },

<span class="apidocCodeCommentSpan">        /**
         * Renders a template to either a stream (if the last
         * argument is a Stream instance) or
         * provides the output to a callback function (if the last
         * argument is a Function).
         *
         * Supported signatures:
         *
         * render(data)
         * render(data, out)
         * render(data, stream)
         * render(data, callback)
         *
         * @param  {Object} data The view model data for the template
         * @param  {AsyncStream/AsyncVDOMBuilder} out A Stream, an AsyncStream/AsyncVDOMBuilder instance, or a callback function
         * @return {AsyncStream/AsyncVDOMBuilder} Returns the AsyncStream/AsyncVDOMBuilder instance that the template is rendered
 to
         */
</span>        render: function(data, out) {
            var callback;
            var finalOut;
            var finalData;
            var globalData;
            var render = renderFunc || this._;
            var shouldBuffer = this.$__shouldBuffer;
            var shouldEnd = true;

            if (data) {
                finalData = data;
                if ((globalData = data.$global)) {
                    finalData.$global = undefined;
                }
            } else {
                finalData = {};
            }

            if (out &#x26;&#x26; out.$__isOut) {
                finalOut = out;
                shouldEnd = false;
                extend(out.global, globalData);
            } else if (typeof out == &#x27;function&#x27;) {
                finalOut = createOut(globalData);
                callback = out;
            } else {
                finalOut = createOut(
                    globalData, // global
                    out, // writer(AsyncStream) or parentNode(AsyncVDOMBuilder)
                    null, // state
                    shouldBuffer // ignored by AsyncVDOMBuilder
                );
            }

            if (callback) {
                finalOut
                    .on(&#x27;finish&#x27;, function() {
                        callback(null, finalOut.$__getResult());
                    })
                    .once(&#x27;error&#x27;, callback);
            }

            globalData = finalOut.global;

            globalData.template = globalData.template || this;

            return safeRender(render, finalData, finalOut, shouldEnd);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.renderer" id="apidoc.module.marko.renderer">module marko.renderer</a></h1>


    <h2>
        <a href="#apidoc.element.marko.renderer.renderer" id="apidoc.element.marko.renderer.renderer">
        function <span class="apidocSignatureSpan">marko.</span>renderer
        <span class="apidocSignatureSpan">(templateRenderFunc, componentProps, renderingLogic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createRendererFunc(templateRenderFunc, componentProps, renderingLogic) {
    renderingLogic = renderingLogic || {};
    var onInput = renderingLogic.onInput;
    var typeName = componentProps.type;
    var roots = componentProps.roots;
    var assignedId = componentProps.id;
    var split = componentProps.split;

    return function renderer(input, out) {
        var outGlobal = out.global;

        if (out.isSync() === false) {
            if (!outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY]) {
                outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY] = true;
                out.on(&#x27;beginAsync&#x27;, handleBeginAsync);
            }
        }

        var component = outGlobal.$w;
        var isRerender = component !== undefined;
        var id = assignedId;
        var isExisting;
        var customEvents;
        var scope;

        if (component) {
            id = component.id;
            isExisting = true;
            outGlobal.$w = null;
        } else {
            var componentArgs = out.$c;

            if (componentArgs) {
                out.$c = null;

                scope = componentArgs[0];

                if (scope) {
                    scope = scope.id;
                }

                var key = componentArgs[1];
                if (key != null) {
                    key = key.toString();
                }
                id = id || resolveComponentKey(out, key, scope);
                customEvents = componentArgs[2];
            }
        }

        var componentsContext = getComponentsContext(out);
        id = id || componentsContext.$__nextComponentId();

        if (registry.$__isServer) {
            component = registry.$__createComponent(
                renderingLogic,
                id,
                input,
                out,
                typeName,
                customEvents,
                scope);
            input = component.$__updatedInput;
            component.$__updatedInput = undefined; // We don&#x27;t want $__updatedInput to be serialized to the browser
        } else {
            if (!component) {
                if (isRerender) {
                    // Look in in the DOM to see if a component with the same ID and type already exists.
                    component = componentLookup[id];
                    if (component &#x26;&#x26; component.$__type !== typeName) {
                        component = undefined;
                    }
                }

                if (component) {
                    isExisting = true;
                } else {
                    isExisting = false;
                    // We need to create a new instance of the component
                    component = registry.$__createComponent(typeName, id);

                    if (split) {
                        split = false;

                        var renderingLogicProps = typeof renderingLogic == &#x27;function&#x27; ?
                            renderingLogic.prototype :
                            renderingLogic;

                        copyProps(renderingLogicProps, component.constructor.prototype);
                    }
                }

                // Set this flag to prevent the component from being queued for update
                // based on the new input. The component is about to be rerendered
                // so we don&#x27;t want to queue it up as a result of calling `setInput()`
                component.$__updateQueued = true;

                if (customEvents !== undefined) {
                    component.$__setCustomEvents(customEvents, scope);
                }


                if (isExisting === false) {
                    emitLifecycleEvent(component, &#x27;create&#x27;, input, out);
                }

                input = component.$__setInput(input, onInput, out);

                if (isExisting === true) {
                    if (component.$__isDirty === false || component.shouldUpdate(input, component.$__state) === false) {
                        preserveComponentEls(component, out, componentsContext);
                        return;
                    }
                } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }
}
}

function createDeferredRenderer(handler) {
function deferredRenderer(input, out) {
    deferredRenderer.<span class="apidocCodeKeywordSpan">renderer</span>(input, out);
}

// This is the initial function that will do the rendering. We replace
// the renderer with the actual renderer func on the first render
deferredRenderer.renderer = function(input, out) {
    var rendererFunc = handler.renderer || handler._ || handler.render;
    if (!isFunction(rendererFunc)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.specialElHandlers" id="apidoc.module.marko.specialElHandlers">module marko.specialElHandlers</a></h1>


    <h2>
        <a href="#apidoc.element.marko.specialElHandlers.INPUT" id="apidoc.element.marko.specialElHandlers.INPUT">
        function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>INPUT
        <span class="apidocSignatureSpan">(fromEl, toEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">INPUT = function (fromEl, toEl) {
    syncBooleanAttrProp(fromEl, toEl, &#x27;checked&#x27;);
    syncBooleanAttrProp(fromEl, toEl, &#x27;disabled&#x27;);

    if (fromEl.value != toEl.value) {
        fromEl.value = toEl.value;
    }

    if (!toEl.$__hasAttribute(&#x27;value&#x27;)) {
        fromEl.removeAttribute(&#x27;value&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.specialElHandlers.OPTION" id="apidoc.element.marko.specialElHandlers.OPTION">
        function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>OPTION
        <span class="apidocSignatureSpan">(fromEl, toEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">OPTION = function (fromEl, toEl) {
    syncBooleanAttrProp(fromEl, toEl, &#x27;selected&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.specialElHandlers.SELECT" id="apidoc.element.marko.specialElHandlers.SELECT">
        function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>SELECT
        <span class="apidocSignatureSpan">(fromEl, toEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SELECT = function (fromEl, toEl) {
    if (!toEl.$__hasAttribute(&#x27;multiple&#x27;)) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = toEl.firstChild;
        while(curChild) {
            if (curChild.$__nodeName == &#x27;OPTION&#x27;) {
                if (curChild.$__hasAttribute(&#x27;selected&#x27;)) {
                    selectedIndex = i;
                    break;
                }
                i++;
            }
            curChild = curChild.nextSibling;
        }

        fromEl.selectedIndex = i;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.specialElHandlers.TEXTAREA" id="apidoc.element.marko.specialElHandlers.TEXTAREA">
        function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>TEXTAREA
        <span class="apidocSignatureSpan">(fromEl, toEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TEXTAREA = function (fromEl, toEl) {
    var newValue = toEl.value;
    if (fromEl.value != newValue) {
        fromEl.value = newValue;
    }

    var firstChild = fromEl.firstChild;
    if (firstChild) {
        // Needed for IE. Apparently IE sets the placeholder as the
        // node value and vise versa. This ignores an empty update.
        var oldValue = firstChild.nodeValue;

        if (oldValue == newValue || (!newValue &#x26;&#x26; oldValue == fromEl.placeholder)) {
            return;
        }

        firstChild.nodeValue = newValue;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.update_manager" id="apidoc.module.marko.update_manager">module marko.update_manager</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.util" id="apidoc.module.marko.util">module marko.util</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.vdom" id="apidoc.module.marko.vdom">module marko.vdom</a></h1>


    <h2>
        <a href="#apidoc.element.marko.vdom.Template" id="apidoc.element.marko.vdom.Template">
        function <span class="apidocSignatureSpan">marko.vdom.</span>Template
        <span class="apidocSignatureSpan">(path, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Template(path, func) {
    this.path = path;
    this._ = func;
    this.meta = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.vdom.t" id="apidoc.element.marko.vdom.t">
        function <span class="apidocSignatureSpan">marko.vdom.</span>t
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTemplate(path) {
     return new Template(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
