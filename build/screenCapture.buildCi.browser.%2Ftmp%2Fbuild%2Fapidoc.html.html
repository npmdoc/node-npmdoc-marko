<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://markojs.com/">marko (v4.2.8)</a>
</h1>
<h4>Marko is an extensible, streaming, asynchronous, high performance, HTML-based templating language that can be used in Node.js or in the browser.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko">module marko</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream">
            function <span class="apidocSignatureSpan">marko.</span>AsyncStream
            <span class="apidocSignatureSpan">(global, writer, state, shouldBuffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder">
            function <span class="apidocSignatureSpan">marko.</span>AsyncVDOMBuilder
            <span class="apidocSignatureSpan">(globalData, parentNode, state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.BufferedWriter">
            function <span class="apidocSignatureSpan">marko.</span>BufferedWriter
            <span class="apidocSignatureSpan">(wrappedStream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component">
            function <span class="apidocSignatureSpan">marko.</span>Component
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentDef">
            function <span class="apidocSignatureSpan">marko.</span>ComponentDef
            <span class="apidocSignatureSpan">(component, componentId, out, componentStack, componentStackLen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentsContext">
            function <span class="apidocSignatureSpan">marko.</span>ComponentsContext
            <span class="apidocSignatureSpan">(out, parentComponentsContext, shouldAddGlobalRoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult">
            function <span class="apidocSignatureSpan">marko.</span>RenderResult
            <span class="apidocSignatureSpan">(out)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.State">
            function <span class="apidocSignatureSpan">marko.</span>State
            <span class="apidocSignatureSpan">(component)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.State_legacy">
            function <span class="apidocSignatureSpan">marko.</span>State_legacy
            <span class="apidocSignatureSpan">(component)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.StringWriter">
            function <span class="apidocSignatureSpan">marko.</span>StringWriter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Template">
            function <span class="apidocSignatureSpan">marko.</span>Template
            <span class="apidocSignatureSpan">(path, renderFunc, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VComment">
            function <span class="apidocSignatureSpan">marko.</span>VComment
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VDocumentFragment">
            function <span class="apidocSignatureSpan">marko.</span>VDocumentFragment
            <span class="apidocSignatureSpan">(documentFragment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VElement">
            function <span class="apidocSignatureSpan">marko.</span>VElement
            <span class="apidocSignatureSpan">(tagName, attrs, childCount, flags, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VNode">
            function <span class="apidocSignatureSpan">marko.</span>VNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VText">
            function <span class="apidocSignatureSpan">marko.</span>VText
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.componentArgs">
            function <span class="apidocSignatureSpan">marko.</span>componentArgs
            <span class="apidocSignatureSpan">( out, componentArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.createOut">
            function <span class="apidocSignatureSpan">marko.</span>createOut
            <span class="apidocSignatureSpan">(globalData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.load">
            function <span class="apidocSignatureSpan">marko.</span>load
            <span class="apidocSignatureSpan">(templatePath, templateSrc, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loadAttributeFromProps">
            function <span class="apidocSignatureSpan">marko.</span>loadAttributeFromProps
            <span class="apidocSignatureSpan">(attrName, attrProps, dependencyChain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loadTagFromProps">
            function <span class="apidocSignatureSpan">marko.</span>loadTagFromProps
            <span class="apidocSignatureSpan">(tag, tagProps, dependencyChain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ready">
            function <span class="apidocSignatureSpan">marko.</span>ready
            <span class="apidocSignatureSpan">(callback, thisObj, doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.renderer">
            function <span class="apidocSignatureSpan">marko.</span>renderer
            <span class="apidocSignatureSpan">(templateRenderFunc, componentProps, renderingLogic)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>AsyncStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>AsyncVDOMBuilder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>BufferedWriter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>Component.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>ComponentDef.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>ComponentsContext.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>RenderResult.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>State.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>State_legacy.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>StringWriter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>Template.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>VComment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>VDocumentFragment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>VElement.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>VNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>VText.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>cached_fragment_tag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>client_reorder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>default_cache_manager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>escape</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>event_delegation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>html</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>html_elements</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>jquery</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>json_file_reader</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>loaders</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>macros</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>modules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>node_require</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>node_require_browser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>registry_browser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>specialElHandlers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>tag_def_from_code</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>tokenizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>types</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>update_manager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">marko.</span>vdom</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.AsyncStream">module marko.AsyncStream</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">marko.AsyncStream.</span>INCLUDE_STACK</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.AsyncStream">
            function <span class="apidocSignatureSpan">marko.</span>AsyncStream
            <span class="apidocSignatureSpan">(global, writer, state, shouldBuffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.enableAsyncStackTrace">
            function <span class="apidocSignatureSpan">marko.AsyncStream.</span>enableAsyncStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">marko.AsyncStream.</span>DEFAULT_TIMEOUT</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.AsyncStream.prototype">module marko.AsyncStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.beginAsync">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>beginAsync
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.beginElement">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>beginElement
            <span class="apidocSignatureSpan">(name, elementAttrs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.catch">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>catch
            <span class="apidocSignatureSpan">(fnErr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.constructor">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>constructor
            <span class="apidocSignatureSpan">(global, writer, state, shouldBuffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.createOut">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>createOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.element">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>element
            <span class="apidocSignatureSpan">(tagName, elementAttrs, openTagOnly)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.emit">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>emit
            <span class="apidocSignatureSpan">(type, arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.end">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>end
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.endElement">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>endElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.error">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>error
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.flush">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.flushNext">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>flushNext
            <span class="apidocSignatureSpan">(currentWriter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.getOutput">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>getOutput
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.isSync">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>isSync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.on">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>on
            <span class="apidocSignatureSpan">(event, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.onLast">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>onLast
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.once">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>once
            <span class="apidocSignatureSpan">(event, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.pipe">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>pipe
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.prependListener">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.removeListener">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.sync">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>sync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.text">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>text
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.then">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>then
            <span class="apidocSignatureSpan">(fn, fnErr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.toString">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.w">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>w
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncStream.prototype.write">
            function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>write
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.AsyncVDOMBuilder">module marko.AsyncVDOMBuilder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.AsyncVDOMBuilder">
            function <span class="apidocSignatureSpan">marko.</span>AsyncVDOMBuilder
            <span class="apidocSignatureSpan">(globalData, parentNode, state)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.AsyncVDOMBuilder.prototype">module marko.AsyncVDOMBuilder.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>isVDOM</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.be">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>be
            <span class="apidocSignatureSpan">(name, attrs, childCount, flags, constId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.beginAsync">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>beginAsync
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.beginElement">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>beginElement
            <span class="apidocSignatureSpan">(name, attrs, childCount, flags, constId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.catch">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>catch
            <span class="apidocSignatureSpan">(fnErr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.comment">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>comment
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.createOut">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>createOut
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.e">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>e
            <span class="apidocSignatureSpan">(tagName, attrs, childCount, flags, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.ee">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>ee
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.element">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>element
            <span class="apidocSignatureSpan">(tagName, attrs, childCount, flags, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.emit">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>emit
            <span class="apidocSignatureSpan">(type, arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.end">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.endElement">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>endElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.error">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>error
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.flush">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.h">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>h
            <span class="apidocSignatureSpan">(html)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.html">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>html
            <span class="apidocSignatureSpan">(html)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.isSync">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>isSync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.n">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>n
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.node">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>node
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.on">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>on
            <span class="apidocSignatureSpan">(event, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.onLast">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>onLast
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.once">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>once
            <span class="apidocSignatureSpan">(event, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.removeListener">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.sync">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>sync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.t">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>t
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.text">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>text
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.then">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>then
            <span class="apidocSignatureSpan">(fn, fnErr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.toString">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.w">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>w
            <span class="apidocSignatureSpan">(html)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.write">
            function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>write
            <span class="apidocSignatureSpan">(html)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.BufferedWriter">module marko.BufferedWriter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.BufferedWriter.BufferedWriter">
            function <span class="apidocSignatureSpan">marko.</span>BufferedWriter
            <span class="apidocSignatureSpan">(wrappedStream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.BufferedWriter.prototype">module marko.BufferedWriter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.BufferedWriter.prototype.clear">
            function <span class="apidocSignatureSpan">marko.BufferedWriter.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.BufferedWriter.prototype.end">
            function <span class="apidocSignatureSpan">marko.BufferedWriter.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.BufferedWriter.prototype.flush">
            function <span class="apidocSignatureSpan">marko.BufferedWriter.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.BufferedWriter.prototype.write">
            function <span class="apidocSignatureSpan">marko.BufferedWriter.prototype.</span>write
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.Component">module marko.Component</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.Component">
            function <span class="apidocSignatureSpan">marko.</span>Component
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.Component.prototype">module marko.Component.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.appendTo">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>appendTo
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.destroy">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.elId">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>elId
            <span class="apidocSignatureSpan">(componentElId, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.emit">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>emit
            <span class="apidocSignatureSpan">(eventType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.forceUpdate">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>forceUpdate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.getComponent">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getComponent
            <span class="apidocSignatureSpan">(id, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.getComponents">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getComponents
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.getEl">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getEl
            <span class="apidocSignatureSpan">(componentElId, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.getElId">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getElId
            <span class="apidocSignatureSpan">(componentElId, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.getEls">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getEls
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.insertAfter">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>insertAfter
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.insertBefore">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>insertBefore
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.isDestroyed">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>isDestroyed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.prependTo">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>prependTo
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.replace">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>replace
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.replaceChildrenOf">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>replaceChildrenOf
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.replaceState">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>replaceState
            <span class="apidocSignatureSpan">(newState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.setState">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>setState
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.setStateDirty">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>setStateDirty
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.shouldUpdate">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>shouldUpdate
            <span class="apidocSignatureSpan">(newState, newProps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.subscribeTo">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>subscribeTo
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Component.prototype.update">
            function <span class="apidocSignatureSpan">marko.Component.prototype.</span>update
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.ComponentDef">module marko.ComponentDef</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentDef.ComponentDef">
            function <span class="apidocSignatureSpan">marko.</span>ComponentDef
            <span class="apidocSignatureSpan">(component, componentId, out, componentStack, componentStackLen)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.ComponentDef.prototype">module marko.ComponentDef.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentDef.prototype.d">
            function <span class="apidocSignatureSpan">marko.ComponentDef.prototype.</span>d
            <span class="apidocSignatureSpan">(handlerMethodName, extraArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentDef.prototype.e">
            function <span class="apidocSignatureSpan">marko.ComponentDef.prototype.</span>e
            <span class="apidocSignatureSpan">(type, targetMethod, elId, extraArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentDef.prototype.elId">
            function <span class="apidocSignatureSpan">marko.ComponentDef.prototype.</span>elId
            <span class="apidocSignatureSpan">(nestedId)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.ComponentsContext">module marko.ComponentsContext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ComponentsContext.ComponentsContext">
            function <span class="apidocSignatureSpan">marko.</span>ComponentsContext
            <span class="apidocSignatureSpan">(out, parentComponentsContext, shouldAddGlobalRoot)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.ComponentsContext.prototype">module marko.ComponentsContext.prototype</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.RenderResult">module marko.RenderResult</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.RenderResult">
            function <span class="apidocSignatureSpan">marko.</span>RenderResult
            <span class="apidocSignatureSpan">(out)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.RenderResult.prototype">module marko.RenderResult.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>document</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.afterInsert">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>afterInsert
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.appendTo">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>appendTo
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.getComponent">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.getComponents">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getComponents
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.getNode">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getNode
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.getOutput">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getOutput
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.insertAfter">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>insertAfter
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.insertBefore">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>insertBefore
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.prependTo">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>prependTo
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.replace">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>replace
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.replaceChildrenOf">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>replaceChildrenOf
            <span class="apidocSignatureSpan">(referenceEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.RenderResult.prototype.toString">
            function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.State">module marko.State</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.State.State">
            function <span class="apidocSignatureSpan">marko.</span>State
            <span class="apidocSignatureSpan">(component)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.State.prototype">module marko.State.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.State.prototype.toJSON">
            function <span class="apidocSignatureSpan">marko.State.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.State_legacy">module marko.State_legacy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.State_legacy.State_legacy">
            function <span class="apidocSignatureSpan">marko.</span>State_legacy
            <span class="apidocSignatureSpan">(component)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.State_legacy.prototype">module marko.State_legacy.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.State_legacy.prototype.toJSON">
            function <span class="apidocSignatureSpan">marko.State_legacy.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.StringWriter">module marko.StringWriter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.StringWriter.StringWriter">
            function <span class="apidocSignatureSpan">marko.</span>StringWriter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.StringWriter.prototype">module marko.StringWriter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.StringWriter.prototype.toString">
            function <span class="apidocSignatureSpan">marko.StringWriter.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.StringWriter.prototype.write">
            function <span class="apidocSignatureSpan">marko.StringWriter.prototype.</span>write
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.Template">module marko.Template</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Template.Template">
            function <span class="apidocSignatureSpan">marko.</span>Template
            <span class="apidocSignatureSpan">(path, renderFunc, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.Template.prototype">module marko.Template.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Template.prototype.createOut">
            function <span class="apidocSignatureSpan">marko.Template.prototype.</span>createOut
            <span class="apidocSignatureSpan">(globalData, parent, state, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Template.prototype.getDependencies">
            function <span class="apidocSignatureSpan">marko.Template.prototype.</span>getDependencies
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Template.prototype.render">
            function <span class="apidocSignatureSpan">marko.Template.prototype.</span>render
            <span class="apidocSignatureSpan">(data, out)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Template.prototype.renderSync">
            function <span class="apidocSignatureSpan">marko.Template.prototype.</span>renderSync
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Template.prototype.renderToString">
            function <span class="apidocSignatureSpan">marko.Template.prototype.</span>renderToString
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.Template.prototype.stream">
            function <span class="apidocSignatureSpan">marko.Template.prototype.</span>stream
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.VComment">module marko.VComment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VComment.VComment">
            function <span class="apidocSignatureSpan">marko.</span>VComment
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.VComment.prototype">module marko.VComment.prototype</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.VDocumentFragment">module marko.VDocumentFragment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VDocumentFragment.VDocumentFragment">
            function <span class="apidocSignatureSpan">marko.</span>VDocumentFragment
            <span class="apidocSignatureSpan">(documentFragment)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.VDocumentFragment.prototype">module marko.VDocumentFragment.prototype</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.VElement">module marko.VElement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VElement.VElement">
            function <span class="apidocSignatureSpan">marko.</span>VElement
            <span class="apidocSignatureSpan">(tagName, attrs, childCount, flags, props)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.VElement.prototype">module marko.VElement.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VElement.prototype.e">
            function <span class="apidocSignatureSpan">marko.VElement.prototype.</span>e
            <span class="apidocSignatureSpan">(tagName, attrs, childCount, flags, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VElement.prototype.n">
            function <span class="apidocSignatureSpan">marko.VElement.prototype.</span>n
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.VNode">module marko.VNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VNode.VNode">
            function <span class="apidocSignatureSpan">marko.</span>VNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.VNode.prototype">module marko.VNode.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VNode.prototype.actualize">
            function <span class="apidocSignatureSpan">marko.VNode.prototype.</span>actualize
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VNode.prototype.c">
            function <span class="apidocSignatureSpan">marko.VNode.prototype.</span>c
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VNode.prototype.t">
            function <span class="apidocSignatureSpan">marko.VNode.prototype.</span>t
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.VText">module marko.VText</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.VText.VText">
            function <span class="apidocSignatureSpan">marko.</span>VText
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.VText.prototype">module marko.VText.prototype</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.cache">module marko.cache</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.cache.clear">
            function <span class="apidocSignatureSpan">marko.cache.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.cache.get">
            function <span class="apidocSignatureSpan">marko.cache.</span>get
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.cache.put">
            function <span class="apidocSignatureSpan">marko.cache.</span>put
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.cached_fragment_tag">module marko.cached_fragment_tag</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.cached_fragment_tag.render">
            function <span class="apidocSignatureSpan">marko.cached_fragment_tag.</span>render
            <span class="apidocSignatureSpan">(input, out)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.client_reorder">module marko.client_reorder</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">marko.client_reorder.</span>isSupported</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.client_reorder.getCode">
            function <span class="apidocSignatureSpan">marko.client_reorder.</span>getCode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.componentArgs">module marko.componentArgs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.componentArgs.componentArgs">
            function <span class="apidocSignatureSpan">marko.</span>componentArgs
            <span class="apidocSignatureSpan">( out, componentArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.componentArgs.cleanup">
            function <span class="apidocSignatureSpan">marko.componentArgs.</span>cleanup
            <span class="apidocSignatureSpan">(out)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.createOut">module marko.createOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.createOut.createOut">
            function <span class="apidocSignatureSpan">marko.</span>createOut
            <span class="apidocSignatureSpan">(globalData)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.default_cache_manager">module marko.default_cache_manager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.default_cache_manager.getCache">
            function <span class="apidocSignatureSpan">marko.default_cache_manager.</span>getCache
            <span class="apidocSignatureSpan">(cacheName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.escape">module marko.escape</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.escape.escapeString">
            function <span class="apidocSignatureSpan">marko.escape.</span>escapeString
            <span class="apidocSignatureSpan">(str, regexpTest, regexpReplace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.escape.escapeXml">
            function <span class="apidocSignatureSpan">marko.escape.</span>escapeXml
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.escape.escapeXmlAttr">
            function <span class="apidocSignatureSpan">marko.escape.</span>escapeXmlAttr
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.event_delegation">module marko.event_delegation</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.helpers">module marko.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helpers.cl">
            function <span class="apidocSignatureSpan">marko.helpers.</span>cl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helpers.f">
            function <span class="apidocSignatureSpan">marko.helpers.</span>f
            <span class="apidocSignatureSpan">(array, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helpers.s">
            function <span class="apidocSignatureSpan">marko.helpers.</span>s
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.helpers.t">
            function <span class="apidocSignatureSpan">marko.helpers.</span>t
            <span class="apidocSignatureSpan">(renderer, targetProperty, isRepeated)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.html">module marko.html</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.html.AsyncStream">
            function <span class="apidocSignatureSpan">marko.html.</span>AsyncStream
            <span class="apidocSignatureSpan">(global, writer, state, shouldBuffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.html.Template">
            function <span class="apidocSignatureSpan">marko.html.</span>Template
            <span class="apidocSignatureSpan">(path, renderFunc, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.html.createWriter">
            function <span class="apidocSignatureSpan">marko.html.</span>createWriter
            <span class="apidocSignatureSpan">(writer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.html.enableAsyncStackTrace">
            function <span class="apidocSignatureSpan">marko.html.</span>enableAsyncStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.html.t">
            function <span class="apidocSignatureSpan">marko.html.</span>t
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.html_elements">module marko.html_elements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.html_elements.isRegisteredElement">
            function <span class="apidocSignatureSpan">marko.html_elements.</span>isRegisteredElement
            <span class="apidocSignatureSpan">(tagName, dir)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.index">module marko.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.index.enable">
            function <span class="apidocSignatureSpan">marko.index.</span>enable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.jquery">module marko.jquery</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.jquery.patchComponent">
            function <span class="apidocSignatureSpan">marko.jquery.</span>patchComponent
            <span class="apidocSignatureSpan">(jQuery)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.json_file_reader">module marko.json_file_reader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.json_file_reader.readFileSync">
            function <span class="apidocSignatureSpan">marko.json_file_reader.</span>readFileSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.loadAttributeFromProps">module marko.loadAttributeFromProps</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loadAttributeFromProps.loadAttributeFromProps">
            function <span class="apidocSignatureSpan">marko.</span>loadAttributeFromProps
            <span class="apidocSignatureSpan">(attrName, attrProps, dependencyChain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loadAttributeFromProps.isSupportedProperty">
            function <span class="apidocSignatureSpan">marko.loadAttributeFromProps.</span>isSupportedProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.loadTagFromProps">module marko.loadTagFromProps</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loadTagFromProps.loadTagFromProps">
            function <span class="apidocSignatureSpan">marko.</span>loadTagFromProps
            <span class="apidocSignatureSpan">(tag, tagProps, dependencyChain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loadTagFromProps.isSupportedProperty">
            function <span class="apidocSignatureSpan">marko.loadTagFromProps.</span>isSupportedProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.loaders">module marko.loaders</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loaders.createTaglib">
            function <span class="apidocSignatureSpan">marko.loaders.</span>createTaglib
            <span class="apidocSignatureSpan">(taglibPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loaders.isSupportedAttributeProperty">
            function <span class="apidocSignatureSpan">marko.loaders.</span>isSupportedAttributeProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loaders.isSupportedTagProperty">
            function <span class="apidocSignatureSpan">marko.loaders.</span>isSupportedTagProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loaders.loadAttributeFromProps">
            function <span class="apidocSignatureSpan">marko.loaders.</span>loadAttributeFromProps
            <span class="apidocSignatureSpan">(attrName, attrProps, dependencyChain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loaders.loadAttributes">
            function <span class="apidocSignatureSpan">marko.loaders.</span>loadAttributes
            <span class="apidocSignatureSpan">(value, parent, dependencyChain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loaders.loadTagFromFile">
            function <span class="apidocSignatureSpan">marko.loaders.</span>loadTagFromFile
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loaders.loadTagFromProps">
            function <span class="apidocSignatureSpan">marko.loaders.</span>loadTagFromProps
            <span class="apidocSignatureSpan">(tag, tagProps, dependencyChain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loaders.loadTaglibFromFile">
            function <span class="apidocSignatureSpan">marko.loaders.</span>loadTaglibFromFile
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.loaders.loadTaglibFromProps">
            function <span class="apidocSignatureSpan">marko.loaders.</span>loadTaglibFromProps
            <span class="apidocSignatureSpan">(taglib, taglibProps, dependencyChain)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.macros">module marko.macros</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.macros.createMacrosContext">
            function <span class="apidocSignatureSpan">marko.macros.</span>createMacrosContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.modules">module marko.modules</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.modules.deresolve">
            function <span class="apidocSignatureSpan">marko.modules.</span>deresolve
            <span class="apidocSignatureSpan">(targetFilename, from)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.modules.require">
            function <span class="apidocSignatureSpan">marko.modules.</span>require
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.modules.resolve">
            function <span class="apidocSignatureSpan">marko.modules.</span>resolve
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.modules.resolveFrom">
            function <span class="apidocSignatureSpan">marko.modules.</span>resolveFrom
            <span class="apidocSignatureSpan">(from, target)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.node_require">module marko.node_require</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.node_require.getExtensions">
            function <span class="apidocSignatureSpan">marko.node_require.</span>getExtensions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.node_require.install">
            function <span class="apidocSignatureSpan">marko.node_require.</span>install
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.node_require_browser">module marko.node_require_browser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.node_require_browser.install">
            function <span class="apidocSignatureSpan">marko.node_require_browser.</span>install
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.ready">module marko.ready</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ready.ready">
            function <span class="apidocSignatureSpan">marko.</span>ready
            <span class="apidocSignatureSpan">(callback, thisObj, doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.ready.patchComponent">
            function <span class="apidocSignatureSpan">marko.ready.</span>patchComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.registry">module marko.registry</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.registry_browser">module marko.registry_browser</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.renderer">module marko.renderer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.renderer.renderer">
            function <span class="apidocSignatureSpan">marko.</span>renderer
            <span class="apidocSignatureSpan">(templateRenderFunc, componentProps, renderingLogic)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.specialElHandlers">module marko.specialElHandlers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.specialElHandlers.INPUT">
            function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>INPUT
            <span class="apidocSignatureSpan">(fromEl, toEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.specialElHandlers.OPTION">
            function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>OPTION
            <span class="apidocSignatureSpan">(fromEl, toEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.specialElHandlers.SELECT">
            function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>SELECT
            <span class="apidocSignatureSpan">(fromEl, toEl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.specialElHandlers.TEXTAREA">
            function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>TEXTAREA
            <span class="apidocSignatureSpan">(fromEl, toEl)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.tag_def_from_code">module marko.tag_def_from_code</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.tag_def_from_code.extractTagDef">
            function <span class="apidocSignatureSpan">marko.tag_def_from_code.</span>extractTagDef
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.tokenizer">module marko.tokenizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.tokenizer.create">
            function <span class="apidocSignatureSpan">marko.tokenizer.</span>create
            <span class="apidocSignatureSpan">(tokens)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.types">module marko.types</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.types.Attribute">
            function <span class="apidocSignatureSpan">marko.types.</span>Attribute
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.types.ImportedVariable">
            function <span class="apidocSignatureSpan">marko.types.</span>ImportedVariable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.types.NestedVariable">
            function <span class="apidocSignatureSpan">marko.types.</span>NestedVariable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.types.Property">
            function <span class="apidocSignatureSpan">marko.types.</span>Property
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.types.Tag">
            function <span class="apidocSignatureSpan">marko.types.</span>Tag
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.types.Taglib">
            function <span class="apidocSignatureSpan">marko.types.</span>Taglib
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.types.Transformer">
            function <span class="apidocSignatureSpan">marko.types.</span>Transformer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.update_manager">module marko.update_manager</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.util">module marko.util</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.marko.vdom">module marko.vdom</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.vdom.Template">
            function <span class="apidocSignatureSpan">marko.vdom.</span>Template
            <span class="apidocSignatureSpan">(path, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.marko.vdom.t">
            function <span class="apidocSignatureSpan">marko.vdom.</span>t
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko" id="apidoc.module.marko">module marko</a></h1>


    <h2>
        <a href="#apidoc.element.marko.AsyncStream" id="apidoc.element.marko.AsyncStream">
        function <span class="apidocSignatureSpan">marko.</span>AsyncStream
        <span class="apidocSignatureSpan">(global, writer, state, shouldBuffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncStream(global, writer, state, shouldBuffer) {
    var finalGlobal = this.attributes = global || {};
    var originalStream;

    if (state) {
        originalStream = state.stream;
    } else {
        var events = finalGlobal.events /* deprecated */ = writer &amp;&amp; writer.on ? writer : new EventEmitter();

        if (writer) {
            originalStream = writer;
            if (shouldBuffer) {
                writer = new BufferedWriter(writer);
            }
        } else {
            writer = originalStream = new StringWriter();
        }

        state = new State(this, originalStream, writer, events);
    }

    this.global = finalGlobal;
    this.stream = originalStream;
    this._state = state;

    this.data = {};
    this.writer = writer;
    writer.stream = this;

    this._sync = false;
    this._stack = undefined;
    this.name = undefined;
    this._timeoutId = undefined;

    this._node = undefined;

    this._elStack = undefined; // Array

    this.$c = null; // Component args
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder" id="apidoc.element.marko.AsyncVDOMBuilder">
        function <span class="apidocSignatureSpan">marko.</span>AsyncVDOMBuilder
        <span class="apidocSignatureSpan">(globalData, parentNode, state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncVDOMBuilder(globalData, parentNode, state) {
    if (!parentNode) {
        parentNode = new VDocumentFragment();
    }

    if (state) {
        state.$__remaining++;
    } else {
        state = new State(parentNode);
    }

    this.data = {};
    this.$__state = state;
    this.$__parent = parentNode;
    this.global = globalData || {};
    this.$__stack = [parentNode];
    this.$__sync = false;
    this.$__vnode = undefined;
    this.$c = null; // Component args
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.BufferedWriter" id="apidoc.element.marko.BufferedWriter">
        function <span class="apidocSignatureSpan">marko.</span>BufferedWriter
        <span class="apidocSignatureSpan">(wrappedStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferedWriter(wrappedStream) {
    this._buffer = '';
    this._wrapped = wrappedStream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component" id="apidoc.element.marko.Component">
        function <span class="apidocSignatureSpan">marko.</span>Component
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Component(id) {
    EventEmitter.call(this);
    this.id = id;
    this.el = null;
    this.$__state = null;
    this.$__roots = null;
    this.$__subscriptions = null;
    this.$__domEventListenerHandles = null;
    this.$__bubblingDomEvents = null;
    this.$__customEvents = null;
    this.$__scope = null;
    this.$__renderInput = null;
    this.$__input = undefined;

    this.$__destroyed = false;
    this.$__updateQueued = false;
    this.$__dirty = false;
    this.$__settingInput = false;

    this.$__document = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.ComponentDef" id="apidoc.element.marko.ComponentDef">
        function <span class="apidocSignatureSpan">marko.</span>ComponentDef
        <span class="apidocSignatureSpan">(component, componentId, out, componentStack, componentStackLen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ComponentDef(component, componentId, out, componentStack, componentStackLen) {
    this.$__out = out; // The AsyncWriter that this component is associated with
    this.$__componentStack = componentStack;
    this.$__componentStackLen = componentStackLen;
    this.$__component = component;
    this.id = componentId;

    this.$__roots =  null;            // IDs of root elements if there are multiple root elements
    this.$__children = null;          // An array of nested ComponentDef instances
    this.$__domEvents = null;         // An array of DOM events that need to be added (in sets of three)
    this.$__bubblingDomEvents = null; // Used to keep track of bubbling DOM events for components rendered on the server

    this.$__isExisting = false;

    this.$__nextIdIndex = 0; // The unique integer to use for the next scoped ID
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.ComponentsContext" id="apidoc.element.marko.ComponentsContext">
        function <span class="apidocSignatureSpan">marko.</span>ComponentsContext
        <span class="apidocSignatureSpan">(out, parentComponentsContext, shouldAddGlobalRoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ComponentsContext(out, parentComponentsContext, shouldAddGlobalRoot) {
    var root;

    var globalComponentsContext;

    if (parentComponentsContext === undefined) {
        root = new ComponentDef(null, null, out);

        globalComponentsContext = out.global.components;
        if (globalComponentsContext === undefined) {
            out.global.components = globalComponentsContext = new GlobalComponentsContext(out);
        }

        if (shouldAddGlobalRoot !== false) {
            globalComponentsContext.$__roots.push(root);
        }
    } else {
        globalComponentsContext = parentComponentsContext.$__globalContext;
        var parentComponentStack = parentComponentsContext.$__componentStack;
        root = parentComponentStack[parentComponentStack.length-1];
    }

    this.$__globalContext = globalComponentsContext;
    this.$__out = out;
    this.$__componentStack = [root];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult" id="apidoc.element.marko.RenderResult">
        function <span class="apidocSignatureSpan">marko.</span>RenderResult
        <span class="apidocSignatureSpan">(out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RenderResult(out) {
   this.out = this.$__out = out;
   this.$__components = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.State" id="apidoc.element.marko.State">
        function <span class="apidocSignatureSpan">marko.</span>State
        <span class="apidocSignatureSpan">(component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function State(component) {
    this.$__component = component;
    this.$__raw = {};

    this.$__dirty = false;
    this.$__old = null;
    this.$__changes = null;
    this.$__forced = null; // An object that we use to keep tracking of state properties that were forced to be dirty

    Object.seal(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.State_legacy" id="apidoc.element.marko.State_legacy">
        function <span class="apidocSignatureSpan">marko.</span>State_legacy
        <span class="apidocSignatureSpan">(component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function State(component) {
    this.$__component = component;
    this.$__raw = {};

    this.$__dirty = false;
    this.$__old = null;
    this.$__changes = null;
    this.$__forced = null; // An object that we use to keep tracking of state properties that were forced to be dirty
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.StringWriter" id="apidoc.element.marko.StringWriter">
        function <span class="apidocSignatureSpan">marko.</span>StringWriter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StringWriter() {
    this.str = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Template" id="apidoc.element.marko.Template">
        function <span class="apidocSignatureSpan">marko.</span>Template
        <span class="apidocSignatureSpan">(path, renderFunc, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Template(path, renderFunc, options) {
    this.path = path;
    this._ = renderFunc;
    this.$__shouldBuffer = !options || options.shouldBuffer !== false;
    this.meta = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.VComment" id="apidoc.element.marko.VComment">
        function <span class="apidocSignatureSpan">marko.</span>VComment
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VComment(value) {
    this.$__VNode(-1 /* no children */);
    this.nodeValue = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.VDocumentFragment" id="apidoc.element.marko.VDocumentFragment">
        function <span class="apidocSignatureSpan">marko.</span>VDocumentFragment
        <span class="apidocSignatureSpan">(documentFragment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VDocumentFragment(documentFragment) {
    this.$__VNode(null /* childCount */);
    this.namespaceURI = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.VElement" id="apidoc.element.marko.VElement">
        function <span class="apidocSignatureSpan">marko.</span>VElement
        <span class="apidocSignatureSpan">(tagName, attrs, childCount, flags, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VElement(tagName, attrs, childCount, flags, props) {
    this.$__VNode(childCount);

    var constId;

    if (props) {
        constId = props.c;
    }

    var namespaceURI;

    if ((this.$__flags = flags || 0)) {
        if (flags &amp; FLAG_IS_SVG) {
            namespaceURI = 'http://www.w3.org/2000/svg';
        }
    }

    this.$__attributes = attrs || EMPTY_OBJECT;
    this.$__properties = props || EMPTY_OBJECT;
    this.$__namespaceURI = namespaceURI;
    this.$__nodeName = tagName;
    this.$__value = null;
    this.$__constId = constId;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.VNode" id="apidoc.element.marko.VNode">
        function <span class="apidocSignatureSpan">marko.</span>VNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VNode() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.VText" id="apidoc.element.marko.VText">
        function <span class="apidocSignatureSpan">marko.</span>VText
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VText(value) {
    this.$__VNode(-1 /* no children */);
    this.nodeValue = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.componentArgs" id="apidoc.element.marko.componentArgs">
        function <span class="apidocSignatureSpan">marko.</span>componentArgs
        <span class="apidocSignatureSpan">( out, componentArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function componentArgsHelper( out, componentArgs) {

    out.data.$w = componentArgs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.createOut" id="apidoc.element.marko.createOut">
        function <span class="apidocSignatureSpan">marko.</span>createOut
        <span class="apidocSignatureSpan">(globalData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createOut(globalData) {
    return actualCreateOut(globalData);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| `out` | `AsyncStream`/`AsyncVDOMBuilder` | The async `out` to render to |
| return value | `AsyncStream`/`AsyncVDOMBuilder` | The `out` that was passed |

The `render` method also allows passing an existing async `out`.  If you do this, `render` will not automatically end the async `
out` (this allows rendering a view in the middle of another view).  If the async `out` won't be ended by other means, you are
 responsible for ending it.

```js
var view = require('./view'); // Import `./view.marko`
var out = view.<span class="apidocCodeKeywordSpan">createOut</span>();

view.render({}, out);

out.on('finish', () =&gt; {
    console.log(out.getOutput());
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.load" id="apidoc.element.marko.load">
        function <span class="apidocSignatureSpan">marko.</span>load
        <span class="apidocSignatureSpan">(templatePath, templateSrc, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(templatePath, templateSrc, options) {
    if (typeof templatePath === 'string' &amp;&amp; nodePath.extname(templatePath) === '.js') {
        // assume compiled template
        return require(templatePath);
    }

    if (arguments.length === 1) {
        return doLoad(templatePath);
    } else if (arguments.length === 2) {
        // see if second argument is templateSrc (a String)
        // or options (an Object)
        var lastArg = arguments[arguments.length - 1];
        if (typeof lastArg === 'string') {
            return doLoad(templatePath, templateSrc);
        } else {
            var finalOptions = templateSrc;
            return doLoad(templatePath, null, finalOptions);
        }
    } else if (arguments.length === 3) {
        // assume function called according to function signature
        return doLoad(templatePath, templateSrc, options);
    } else {
        throw new Error('Illegal arguments');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Fixes #140 - Also de-dupe cached taglibs in finder

### 2.7.27

- Make loading template from String template source easier:

```javascript
var template = marko.<span class="apidocCodeKeywordSpan">load</span>(
    templatePath,
    'Hello $!{data.name}!');
```

_NOTE: Loading directly from source only works on the server_

See [Pull Request #153](https://github.com/marko-js/marko/pull/153)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loadAttributeFromProps" id="apidoc.element.marko.loadAttributeFromProps">
        function <span class="apidocSignatureSpan">marko.</span>loadAttributeFromProps
        <span class="apidocSignatureSpan">(attrName, attrProps, dependencyChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadAttributeFromProps(attrName, attrProps, dependencyChain) {
    assert.ok(typeof attrName === 'string');
    assert.ok(dependencyChain, '"dependencyChain" is required');

    var attr = new types.Attribute(attrName);

    var attrLoader = new AttrLoader(attr, dependencyChain);

    try {
        attrLoader.load(attrProps);
    } catch(err) {
        throw createError('Unable to load attribute "' + attrName + '" (' + dependencyChain + '): ' + err, err);
    }

    return attr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var loaders = require('./loaders');

module.exports = function loadAttributes(value, parent, dependencyChain) {
    ok(parent);
    ok(dependencyChain);

    forEachEntry(value, (attrName, attrProps) =&gt; {
        var attr = loaders.<span class="apidocCodeKeywordSpan">loadAttributeFromProps</span>(
            attrName,
            attrProps,
            dependencyChain.append('@' + attrName));

        parent.addAttribute(attr);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loadTagFromProps" id="apidoc.element.marko.loadTagFromProps">
        function <span class="apidocSignatureSpan">marko.</span>loadTagFromProps
        <span class="apidocSignatureSpan">(tag, tagProps, dependencyChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadTagFromProps(tag, tagProps, dependencyChain) {
    ok(typeof tagProps === 'object', 'Invalid "tagProps"');
    ok(dependencyChain, '"dependencyChain" is required');

    var tagLoader = new TagLoader(tag, dependencyChain);

    try {
        tagLoader.load(tagProps);
    } catch(err) {
        throw createError('Unable to load tag (' + dependencyChain + '): ' + err, err);
    }

    return tag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function createTaglib(filePath) {
    return new types.Taglib(filePath);
}

function loadTag(tagProps, filePath) {
    var tag = new types.Tag(filePath);
    loaders.<span class="apidocCodeKeywordSpan">loadTagFromProps</span>(tag, tagProps, new DependencyChain(filePath ? [filePath] : []));
    return tag;
}

exports.clearCache = clearCache;
exports.createTaglib = createTaglib;
exports.loadTaglibFromProps = loadTaglibFromProps;
exports.loadTaglibFromFile = loadTaglibFromFile;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.ready" id="apidoc.element.marko.ready">
        function <span class="apidocSignatureSpan">marko.</span>ready
        <span class="apidocSignatureSpan">(callback, thisObj, doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ready(callback, thisObj, doc) {
    if (isReady) {
        return callback.call(thisObj);
    }

    listeners.push([callback, thisObj]);

    if (!readyBound) {
        readyBound = true;
        bindReady(doc || defaultDocument);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.renderer" id="apidoc.element.marko.renderer">
        function <span class="apidocSignatureSpan">marko.</span>renderer
        <span class="apidocSignatureSpan">(templateRenderFunc, componentProps, renderingLogic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createRendererFunc(templateRenderFunc, componentProps, renderingLogic) {
    renderingLogic = renderingLogic || {};
    var onInput = renderingLogic.onInput;
    var typeName = componentProps.type;
    var roots = componentProps.roots;
    var assignedId = componentProps.id;
    var split = componentProps.split;

    return function renderer(input, out) {
        var outGlobal = out.global;

        if (out.isSync() === false) {
            if (!outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY]) {
                outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY] = true;
                out.on('beginAsync', handleBeginAsync);
            }
        }

        var component = outGlobal.$w;
        var isRerender = component !== undefined;
        var id = assignedId;
        var isExisting;
        var customEvents;
        var scope;

        if (component) {
            id = component.id;
            isExisting = true;
            outGlobal.$w = null;
        } else {
            var componentArgs = out.$c;

            if (componentArgs) {
                out.$c = null;

                scope = componentArgs[0];

                if (scope) {
                    scope = scope.id;
                }

                var key = componentArgs[1];
                if (key != null) {
                    key = key.toString();
                }
                id = id || resolveComponentKey(out, key, scope);
                customEvents = componentArgs[2];
            }
        }

        var componentsContext = getComponentsContext(out);
        id = id || componentsContext.$__nextComponentId();

        if (registry.$__isServer) {
            component = registry.$__createComponent(
                renderingLogic,
                id,
                input,
                out,
                typeName,
                customEvents,
                scope);
            input = component.$__updatedInput;
            component.$__updatedInput = undefined; // We don't want $__updatedInput to be serialized to the browser
        } else {
            if (!component) {
                if (isRerender) {
                    // Look in in the DOM to see if a component with the same ID and type already exists.
                    component = componentLookup[id];
                    if (component &amp;&amp; component.$__type !== typeName) {
                        component = undefined;
                    }
                }

                if (component) {
                    isExisting = true;
                } else {
                    isExisting = false;
                    // We need to create a new instance of the component
                    component = registry.$__createComponent(typeName, id);

                    if (split) {
                        split = false;

                        var renderingLogicProps = typeof renderingLogic == 'function' ?
                            renderingLogic.prototype :
                            renderingLogic;

                        copyProps(renderingLogicProps, component.constructor.prototype);
                    }
                }

                // Set this flag to prevent the component from being queued for update
                // based on the new input. The component is about to be rerendered
                // so we don't want to queue it up as a result of calling `setInput()`
                component.$__updateQueued = true;

                if (customEvents !== undefined) {
                    component.$__setCustomEvents(customEvents, scope);
                }


                if (isExisting === false) {
                    emitLifecycleEvent(component, 'create', input, out);
                }

                input = component.$__setInput(input, onInput, out);

                if (isExisting === true) {
                    if (component.$__isDirty === false || component.shouldUpdate(input, component.$__state) === false) {
                        preserveComponentEls(component, out, componentsContext);
                        return;
                    }
                } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;div&gt;Total: ${helpers.formatCurrency(data.total))&lt;/div&gt;
```

### Allow dynamic custom tags/components to be used with `&lt;include&gt;` ([#139](https://github.com/marko-js/marko/issues/
139))

**Old:**
```html
&lt;invoke data.myComponent.<span class="apidocCodeKeywordSpan">renderer</span>({name: 'Frank'}, out)/&gt;
```

**New:**
```html
&lt;include(data.myComponent) name='Frank' /&gt;
```
or
...</pre></li>
    </ul>
























































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.AsyncStream" id="apidoc.module.marko.AsyncStream">module marko.AsyncStream</a></h1>




    <h2>
        <a href="#apidoc.element.marko.AsyncStream.AsyncStream" id="apidoc.element.marko.AsyncStream.AsyncStream">
        function <span class="apidocSignatureSpan">marko.</span>AsyncStream
        <span class="apidocSignatureSpan">(global, writer, state, shouldBuffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncStream(global, writer, state, shouldBuffer) {
    var finalGlobal = this.attributes = global || {};
    var originalStream;

    if (state) {
        originalStream = state.stream;
    } else {
        var events = finalGlobal.events /* deprecated */ = writer &amp;&amp; writer.on ? writer : new EventEmitter();

        if (writer) {
            originalStream = writer;
            if (shouldBuffer) {
                writer = new BufferedWriter(writer);
            }
        } else {
            writer = originalStream = new StringWriter();
        }

        state = new State(this, originalStream, writer, events);
    }

    this.global = finalGlobal;
    this.stream = originalStream;
    this._state = state;

    this.data = {};
    this.writer = writer;
    writer.stream = this;

    this._sync = false;
    this._stack = undefined;
    this.name = undefined;
    this._timeoutId = undefined;

    this._node = undefined;

    this._elStack = undefined; // Array

    this.$c = null; // Component args
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.enableAsyncStackTrace" id="apidoc.element.marko.AsyncStream.enableAsyncStackTrace">
        function <span class="apidocSignatureSpan">marko.AsyncStream.</span>enableAsyncStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableAsyncStackTrace = function () {
    AsyncStream.INCLUDE_STACK = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.AsyncStream.prototype" id="apidoc.module.marko.AsyncStream.prototype">module marko.AsyncStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.beginAsync" id="apidoc.element.marko.AsyncStream.prototype.beginAsync">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>beginAsync
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginAsync = function (options) {
    if (this._sync) {
        throw new Error('beginAsync() not allowed when using renderSync()');
    }

    var state = this._state;

    var currentWriter = this.writer;

<span class="apidocCodeCommentSpan">    /*                this
        WAS                
         prevWriter  currentWriter  nextWriter  */
</span>
    var newWriter = new StringWriter();
    var newStream = new AsyncStream(this.global, currentWriter, state);

    this.writer = newWriter;
    newWriter.stream = this;

    newWriter.next = currentWriter.next;
    currentWriter.next = newWriter;

    /*                newStream       this
        NOW                              
         prevWriter  currentWriter  newWriter  nextWriter  */

   var timeout;
   var name;

   state.remaining++;

   if (options != null) {
       if (typeof options === 'number') {
           timeout = options;
       } else {
           timeout = options.timeout;

           if (options.last === true) {
               if (timeout == null) {
                   // Don't assign a timeout to last flush fragments
                   // unless it is explicitly given a timeout
                   timeout = 0;
               }

               state.lastCount++;
           }

           name = options.name;
       }
   }

   if (timeout == null) {
       timeout = AsyncStream.DEFAULT_TIMEOUT;
   }

   newStream.stack = AsyncStream.INCLUDE_STACK ? new Error().stack : null;
   newStream.name = name;

   if (timeout &gt; 0) {
       newStream._timeoutId = setTimeout(function() {
           newStream.error(new Error('Async fragment ' + (name ? '(' + name + ') ': '') + 'timed out after ' + timeout + 'ms'));
       }, timeout);
   }

   state.events.emit('beginAsync', {
       writer: newStream, // Legacy
       parentWriter: this, // Legacy
       out: newStream,
       parentOut: this
   });

    return newStream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

}
        }
    };

    function doWalk(dir) {
        context.<span class="apidocCodeKeywordSpan">beginAsync</span>();
        fs.readdir(dir, function(err, list) {
if (err) {
    return context.endAsync(err);
}

if (list.length) {
    list.forEach(function(basename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.beginElement" id="apidoc.element.marko.AsyncStream.prototype.beginElement">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>beginElement
        <span class="apidocSignatureSpan">(name, elementAttrs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginElement = function (name, elementAttrs) {

    var str = '&lt;' + name +
        attrsHelper(elementAttrs) +
        '&gt;';

    this.write(str);

    if (this._elStack) {
        this._elStack.push(name);
    } else {
        this._elStack = [name];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.catch" id="apidoc.element.marko.AsyncStream.prototype.catch">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>catch
        <span class="apidocSignatureSpan">(fnErr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catch = function (fnErr) {
    return this.then(undefined, fnErr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
template.render({}, function(err, html, out) {});
```

**New:**
```js
template.render({})
        .then(function(result){})
        .<span class="apidocCodeKeywordSpan">catch</span>(function(err) {});

// render() can now be used with async/await
var out = await template.render({});
out.appendTo(document.body);
```

NOTE: callback/events still work as well
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.constructor" id="apidoc.element.marko.AsyncStream.prototype.constructor">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>constructor
        <span class="apidocSignatureSpan">(global, writer, state, shouldBuffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncStream(global, writer, state, shouldBuffer) {
    var finalGlobal = this.attributes = global || {};
    var originalStream;

    if (state) {
        originalStream = state.stream;
    } else {
        var events = finalGlobal.events /* deprecated */ = writer &amp;&amp; writer.on ? writer : new EventEmitter();

        if (writer) {
            originalStream = writer;
            if (shouldBuffer) {
                writer = new BufferedWriter(writer);
            }
        } else {
            writer = originalStream = new StringWriter();
        }

        state = new State(this, originalStream, writer, events);
    }

    this.global = finalGlobal;
    this.stream = originalStream;
    this._state = state;

    this.data = {};
    this.writer = writer;
    writer.stream = this;

    this._sync = false;
    this._stack = undefined;
    this.name = undefined;
    this._timeoutId = undefined;

    this._node = undefined;

    this._elStack = undefined; // Array

    this.$c = null; // Component args
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.createOut" id="apidoc.element.marko.AsyncStream.prototype.createOut">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>createOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOut = function () {
    return new AsyncStream(this.global);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| `out` | `AsyncStream`/`AsyncVDOMBuilder` | The async `out` to render to |
| return value | `AsyncStream`/`AsyncVDOMBuilder` | The `out` that was passed |

The `render` method also allows passing an existing async `out`.  If you do this, `render` will not automatically end the async `
out` (this allows rendering a view in the middle of another view).  If the async `out` won't be ended by other means, you are
 responsible for ending it.

```js
var view = require('./view'); // Import `./view.marko`
var out = view.<span class="apidocCodeKeywordSpan">createOut</span>();

view.render({}, out);

out.on('finish', () =&gt; {
    console.log(out.getOutput());
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.element" id="apidoc.element.marko.AsyncStream.prototype.element">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>element
        <span class="apidocSignatureSpan">(tagName, elementAttrs, openTagOnly)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">element = function (tagName, elementAttrs, openTagOnly) {
    var str = '&lt;' + tagName +
        attrsHelper(elementAttrs) +
        '&gt;';

    if (openTagOnly !== true) {
        str += '&lt;/' + tagName + '&gt;';
    }

    this.write(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var rootEls = existingComponent.$__getRootEls({});

    for (var elId in rootEls) {
        var el = rootEls[elId];

        // We put a placeholder element in the output stream to ensure that the existing
        // DOM node is matched up correctly when using morphdom.
        out.<span class="apidocCodeKeywordSpan">element</span>(el.tagName, { id: elId });

        componentsContext.$__globalContext.$__preserveDOMNode(elId); // Mark the element as being preserved (for morphdom)
    }

    existingComponent.$__reset(); // The component is no longer dirty so reset internal flags
    return true;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.emit" id="apidoc.element.marko.AsyncStream.prototype.emit">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>emit
        <span class="apidocSignatureSpan">(type, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (type, arg) {
    var events = this._state.events;
    switch(arguments.length) {
        case 1:
            events.emit(type);
            break;
        case 2:
            events.emit(type, arg);
            break;
        default:
            events.emit.apply(events, arguments);
            break;
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var isWhitespacePreserved = node.isPreserveWhitespace();

if (isWhitespacePreserved) {
    this.context.beginPreserveWhitespace();
}

beforeAfterEvent.isBefore = true;
beforeAfterEvent.node.<span class="apidocCodeKeywordSpan">emit</span>('beforeGenerateCode', beforeAfterEvent);
this.context.emit('beforeGenerateCode:' + beforeAfterEvent.node.type, beforeAfterEvent);
this.context.emit('beforeGenerateCode', beforeAfterEvent);

if (beforeAfterEvent.insertedNodes) {
    this._generateCode(beforeAfterEvent.insertedNodes, finalNodes);
    beforeAfterEvent.insertedNodes = null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.end" id="apidoc.element.marko.AsyncStream.prototype.end">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>end
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (data) {
    if (data) {
        this.write(data);
    }

    var currentWriter = this.writer;

<span class="apidocCodeCommentSpan">    /*   this            nextStream
        WAS                 
         currentWriter  nextWriter  futureWriter  */
</span>
    // Prevent any more writes to the current steam
    this.writer = voidWriter;
    currentWriter.stream = null;

    // Flush the contents of nextWriter to the currentWriter
    this.flushNext(currentWriter);

    /*     this          nextStream
                             
        NOW     voidWriter    currentWriter  futureWriter
              
           Flushed &amp; garbage collected: nextWriter  */


   var state = this._state;

   if (state.finished) {
       return;
   }

   var remaining;

   if (this === state.root) {
       remaining = state.remaining;
       state.ended = true;
   } else {
       var timeoutId = this._timeoutId;

       if (timeoutId) {
           clearTimeout(timeoutId);
       }

       remaining = --state.remaining;
   }

   if (state.ended) {
       if (!state.lastFired &amp;&amp; (state.remaining - state.lastCount === 0)) {
           state.lastFired = true;
           state.lastCount = 0;
           state.events.emit('last');
       }

       if (remaining === 0) {
           state.finished = true;

           if (state.writer.end) {
               state.writer.end();
           } else {
               state.events.emit('finish', this.$__getResult());
           }
       }
   }

   return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            template.render(templateData, out);
        };
    }

    renderer.render = function(input) {
        var out = createOut();
        renderer(input, out);
        return out.<span class="apidocCodeKeywordSpan">end</span>();
    };

    return renderer;
}

module.exports = defineRenderer;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.endElement" id="apidoc.element.marko.AsyncStream.prototype.endElement">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>endElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endElement = function () {
    var tagName = this._elStack.pop();
    this.write('&lt;/' + tagName + '&gt;');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.error" id="apidoc.element.marko.AsyncStream.prototype.error">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>error
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (e) {
    var stack = this._stack;
    var name = this.name;

    var message;

    if (name) {
        message = 'Render async fragment error (' + name + ')';
    } else {
        message = 'Render error';
    }

    message += '. Exception: ' + (e.stack || e);

    if (stack) {
        message += '\nCreation stack trace: ' + stack;
    }

    e = new Error(message);

    try {
        this.emit('error', e);
    } finally {
        // If there is no listener for the error event then it will
        // throw a new here. In order to ensure that the async fragment
        // is still properly ended we need to put the end() in a `finally`
        // block
        this.end();
    }

    if (console) {
        console.error(message);
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        compile(file, context);
    }
}
            },
            function(err) {
if (err) {
    if (failed.length) {
        console.<span class="apidocCodeKeywordSpan">error</span>('The following errors occurred:\n- ' + failed.join(&amp;#
x27;\n- '));
    } else {
        console.error(err);
    }

    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.flush" id="apidoc.element.marko.AsyncStream.prototype.flush">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {
    var state = this._state;

    if (!state.finished) {
        var writer = state.writer;
        if (writer &amp;&amp; writer.flush) {
            writer.flush();
        }
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            // Yes, we are monkey-patching http. This method should never have been added and it was introduced on
            // the iojs fork. It was quickly deprecated and I'm 99% sure no one is actually using it.
            // See:
            // - https://github.com/marko-js/async-writer/issues/3
            // - https://github.com/nodejs/node/issues/2920
            //
            // This method causes problems since marko looks for the flush method and calls it found.
            // The `res.<span class="apidocCodeKeywordSpan">flush</span>()` method is introduced by the [compression](https://www
.npmjs.com/package/compression)
            // middleware, but, otherwise, it should typically not exist.
            delete require('http').OutgoingMessage.prototype.flush;
        }
    } catch(e) {}
}

fixFlush();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.flushNext" id="apidoc.element.marko.AsyncStream.prototype.flushNext">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>flushNext
        <span class="apidocSignatureSpan">(currentWriter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flushNext = function (currentWriter) {
    // It is possible that currentWriter is the
    // last writer in the chain, so let's make
    // sure there is a nextWriter to flush.
    var nextWriter = currentWriter.next;
    if (nextWriter) {
        // Flush the contents of nextWriter
        // to the currentWriter
        currentWriter.write(nextWriter.toString());

        // Remove nextWriter from the chain.
        // It has been flushed and can now be
        // garbage collected.
        currentWriter.next = nextWriter.next;

        // It's possible that nextWriter is the last
        // writer in the chain and its stream already
        // ended, so let's make sure nextStream exists.
        var nextStream = nextWriter.stream;
        if (nextStream) {
            // Point the nextStream to currentWriter
            nextStream.writer = currentWriter;
            currentWriter.stream = nextStream;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     currentWriter  nextWriter  futureWriter  */

// Prevent any more writes to the current steam
this.writer = voidWriter;
currentWriter.stream = null;

// Flush the contents of nextWriter to the currentWriter
this.<span class="apidocCodeKeywordSpan">flushNext</span>(currentWriter);

/*     this          nextStream
                         
    NOW     voidWriter    currentWriter  futureWriter
          
       Flushed &amp; garbage collected: nextWriter  */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.getOutput" id="apidoc.element.marko.AsyncStream.prototype.getOutput">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>getOutput
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOutput = function () {
    return this.$__getOutput();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var view = require('./view'); // Import `./view.marko`
var out = view.createOut();

view.render({}, out);

out.on('finish', () =&gt; {
    console.log(out.<span class="apidocCodeKeywordSpan">getOutput</span>());
});

out.end();
```


### `renderToString(input)`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.isSync" id="apidoc.element.marko.AsyncStream.prototype.isSync">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>isSync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSync = function () {
    return this._sync === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var roots = componentProps.roots;
    var assignedId = componentProps.id;
    var split = componentProps.split;

    return function renderer(input, out) {
var outGlobal = out.global;

if (out.<span class="apidocCodeKeywordSpan">isSync</span>() === false) {
    if (!outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY]) {
        outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY] = true;
        out.on('beginAsync', handleBeginAsync);
    }
}

var component = outGlobal.$w;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.on" id="apidoc.element.marko.AsyncStream.prototype.on">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>on
        <span class="apidocSignatureSpan">(event, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (event, callback) {
    var state = this._state;

    if (event === 'finish' &amp;&amp; state.finished) {
        callback(this.$__getResult());
        return this;
    }

    state.events.on(event, callback);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var target = getEventFromEl(node, 'onattach');
        if (target) {
var data = out.data;

var attachTargets = data.$__attachTargets;
if (!attachTargets) {
    attachTargets = data.$__attachTargets = [];
    out.<span class="apidocCodeKeywordSpan">on</span>('$__componentsInitialized', function() {
        for (var i=0; i&lt;attachTargets.length; i+=2) {
            var node = attachTargets[i];
            var target = attachTargets[i+1];
            delegateEvent(node, target, {});
        }
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.onLast" id="apidoc.element.marko.AsyncStream.prototype.onLast">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>onLast
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onLast = function (callback) {
    var state = this._state;

    var lastArray = state.last;

    if (!lastArray) {
        lastArray = state.last = [];
        var i = 0;
        var next = function next() {
            if (i === lastArray.length) {
                return;
            }
            var _next = lastArray[i++];
            _next(next);
        };

        this.once('last', function() {
            next();
        });
    }

    lastArray.push(callback);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            // rendered synchronously
            writeInitComponentsCode(out, true);
        } else {
            // Generate initialization code for any of the UI components that were
            // rendered asynchronously, but were outside an `&lt;await&gt;` tag
            // (each `&lt;await&gt;` tag will have its own component initialization block)
            var asyncOut = out.beginAsync({ last: true, timeout: -1 });
            out.<span class="apidocCodeKeywordSpan">onLast</span>(function(next) {
                writeInitComponentsCode(asyncOut, true);
                asyncOut.end();
                next();
            });
        }
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.once" id="apidoc.element.marko.AsyncStream.prototype.once">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>once
        <span class="apidocSignatureSpan">(event, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (event, callback) {
    var state = this._state;

    if (event === 'finish' &amp;&amp; state.finished) {
        callback(this.$__getResult());
        return this;
    }

    state.events.once(event, callback);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var express = module.parent.require('express');
patchResponse(express.response);
delete require.cache[__filename];

module.exports = function markoAppMiddleware() {
var sacrificialApp = express();

sacrificialApp.<span class="apidocCodeKeywordSpan">once</span>('mount', function onmount(parent) {
    // Patch the response
    patchResponse(parent.response);

    // Remove sacrificial express app
    parent._router.stack.pop();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.pipe" id="apidoc.element.marko.AsyncStream.prototype.pipe">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>pipe
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (stream) {
    this._state.stream.pipe(stream);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        count: 30,
        colors: ['red', 'green', 'blue']
    });

    ctx.vary('Accept-Encoding');
    if (ctx.acceptsEncodings('gzip')) {
        ctx.set('Content-Encoding', 'gzip');
        ctx.body = ctx.body.<span class="apidocCodeKeywordSpan">pipe</span>(createGzip());
    }
});

app.listen(8080);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.prependListener" id="apidoc.element.marko.AsyncStream.prototype.prependListener">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () {
    var events = this._state.events;
    events.prependListener.apply(events, arguments);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.removeListener" id="apidoc.element.marko.AsyncStream.prototype.removeListener">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () {
    var events = this._state.events;
    events.removeListener.apply(events, arguments);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.sync" id="apidoc.element.marko.AsyncStream.prototype.sync">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>sync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sync = function () {
    this._sync = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var fromEls = self.$__getRootEls({});
        var doc = self.$__document;
        input = this.$__renderInput || this.$__input;

        updateManager.$__batchUpdate(function() {
var createOut = renderer.createOut || marko.createOut;
var out = createOut(globalData);
out.<span class="apidocCodeKeywordSpan">sync</span>();
out.$__document = self.$__document;
renderer(input, out);
var result = new RenderResult(out);
var targetNode = out.$__getOutput();

var globalComponentsContext = out.global.components;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.text" id="apidoc.element.marko.AsyncStream.prototype.text">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>text
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">text = function (str) {
    this.write(escapeXml(str));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // NOTE: If parseMode is 'static-text' or 'parsed-text' then that means that special
    //       HTML characters may not have been escaped on the way in so we need to escape
    //       them on the way out

    if (this.prevTextNode &amp;&amp; this.prevTextNode.isLiteral() &amp;&amp; this.prevTextNode.escape === escape) {
        this.prevTextNode.argument.value += text;
    } else {
        this.prevTextNode = builder.<span class="apidocCodeKeywordSpan">text</span>(builder.literal(text), escape);
        this.parentNode.appendChild(this.prevTextNode);
    }
}

handleStartElement(el, parser) {
    var context = this.context;
    var builder = context.builder;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.then" id="apidoc.element.marko.AsyncStream.prototype.then">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>then
        <span class="apidocSignatureSpan">(fn, fnErr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (fn, fnErr) {
    var out = this;
    var promise = new Promise(function(resolve, reject) {
        out.on('error', reject);
        out.on('finish', function(result) {
            resolve(result);
        });
    });

    return Promise.resolve(promise).then(fn, fnErr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
template.render({}, function(err, html, out) {});
```

**New:**
```js
template.render({})
        .<span class="apidocCodeKeywordSpan">then</span>(function(result){})
        .catch(function(err) {});

// render() can now be used with async/await
var out = await template.render({});
out.appendTo(document.body);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.toString" id="apidoc.element.marko.AsyncStream.prototype.toString">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return this._state.writer.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
component.render(data); // returns `out`
component.render(data, (err, out) =&gt; {});
component.renderSync(data); // returns `out`
```

Also, `out` has been updated to implement DOM manipulation methods like `appendTo` that were previously only available from the `
RenderResult` returned from component renders.

NOTE: We will implement `out.<span class="apidocCodeKeywordSpan">toString</span>()` and `out.toJSON()` so in many cases the `out
` can be used as a string.

### Remove support for deprecated `empty`/`notEmpty` helpers ([#357](https://github.com/marko-js/marko/issues/357))

&gt; Already deprecated in v3

The `empty`/`notEmpty` helpers were automatically being added to every compiled
template. While they can be helpful, we feel it is better if the developer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.w" id="apidoc.element.marko.AsyncStream.prototype.w">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>w
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">w = function (str) {
    if (str != null) {
        this.writer.write(str.toString());
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_Compiled for HTML output (server-side):_

```javascript
function render(data, out) {
  var colors = data.colors;

  if (colors &amp;&amp; colors.length) {
out.<span class="apidocCodeKeywordSpan">w</span>("&lt;ul&gt;");

marko_forEach(colors, function(color) {
  out.w("&lt;li class=\"color\"&gt;" +
    marko_escapeXml(color) +
    "&lt;/li&gt;");
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncStream.prototype.write" id="apidoc.element.marko.AsyncStream.prototype.write">
        function <span class="apidocSignatureSpan">marko.AsyncStream.prototype.</span>write
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (str) {
    if (str != null) {
        this.writer.write(str.toString());
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    getCode() {
return this._code;
    }

    writeBlock(body) {
if (!body) {
    this.<span class="apidocCodeKeywordSpan">write</span>('{}');
    return;
}

if (typeof body === 'function') {
    body = body();
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.AsyncVDOMBuilder" id="apidoc.module.marko.AsyncVDOMBuilder">module marko.AsyncVDOMBuilder</a></h1>


    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.AsyncVDOMBuilder" id="apidoc.element.marko.AsyncVDOMBuilder.AsyncVDOMBuilder">
        function <span class="apidocSignatureSpan">marko.</span>AsyncVDOMBuilder
        <span class="apidocSignatureSpan">(globalData, parentNode, state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncVDOMBuilder(globalData, parentNode, state) {
    if (!parentNode) {
        parentNode = new VDocumentFragment();
    }

    if (state) {
        state.$__remaining++;
    } else {
        state = new State(parentNode);
    }

    this.data = {};
    this.$__state = state;
    this.$__parent = parentNode;
    this.global = globalData || {};
    this.$__stack = [parentNode];
    this.$__sync = false;
    this.$__vnode = undefined;
    this.$c = null; // Component args
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.AsyncVDOMBuilder.prototype" id="apidoc.module.marko.AsyncVDOMBuilder.prototype">module marko.AsyncVDOMBuilder.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.be" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.be">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>be
        <span class="apidocSignatureSpan">(name, attrs, childCount, flags, constId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">be = function (name, attrs, childCount, flags, constId) {
    var element = new VElement(name, attrs, childCount, flags, constId);
    var parent = this.$__parent;
    if (parent !== undefined) {
        parent.$__appendChild(element);
        this.$__stack.push(element);
        this.$__parent = element;
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
marko_node0 = marko_createElement("div", null, 1, marko_const_nextId())
  .t("No colors!");

function render(data, out) {
  var colors = data.colors;

  if (colors &amp;&amp; colors.length) {
out.<span class="apidocCodeKeywordSpan">be</span>("ul");

marko_forEach(colors, function(color) {
  out.e("li", marko_attrs0, 1)
    .t(marko_str(color));
});

out.ee();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.beginAsync" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.beginAsync">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>beginAsync
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginAsync = function (options) {
    if (this.$__sync) {
        throw Error('Not allowed');
    }

    var state = this.$__state;

    if (options) {
        if (options.last) {
            state.$__lastCount++;
        }
    }

    var documentFragment = this.$__parent.$__appendDocumentFragment();
    var asyncOut = new AsyncVDOMBuilder(this.global, documentFragment, state);

    state.$__events.emit('beginAsync', {
       out: asyncOut,
       parentOut: this
   });

   return asyncOut;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

}
        }
    };

    function doWalk(dir) {
        context.<span class="apidocCodeKeywordSpan">beginAsync</span>();
        fs.readdir(dir, function(err, list) {
if (err) {
    return context.endAsync(err);
}

if (list.length) {
    list.forEach(function(basename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.beginElement" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.beginElement">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>beginElement
        <span class="apidocSignatureSpan">(name, attrs, childCount, flags, constId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginElement = function (name, attrs, childCount, flags, constId) {
    var element = new VElement(name, attrs, childCount, flags, constId);
    var parent = this.$__parent;
    if (parent !== undefined) {
        parent.$__appendChild(element);
        this.$__stack.push(element);
        this.$__parent = element;
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.catch" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.catch">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>catch
        <span class="apidocSignatureSpan">(fnErr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catch = function (fnErr) {
    return this.then(undefined, fnErr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
template.render({}, function(err, html, out) {});
```

**New:**
```js
template.render({})
        .then(function(result){})
        .<span class="apidocCodeKeywordSpan">catch</span>(function(err) {});

// render() can now be used with async/await
var out = await template.render({});
out.appendTo(document.body);
```

NOTE: callback/events still work as well
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.comment" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.comment">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>comment
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comment = function (comment) {
    return this.node(new VComment(comment));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };
});
}

function _buildVersionComment(builder, context) {
const version = context.compilerVersion;
const compilerType = context.compilerType;
return builder.<span class="apidocCodeKeywordSpan">comment</span>(`Compiled using ${compilerType}@${version} - DO NOT EDIT`);
}

class TemplateRoot extends Node {
constructor(def) {
    super('TemplateRoot');
    this.body = this.makeContainer(def.body);
    this.extraRenderParams = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.createOut" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.createOut">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>createOut
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOut = function (callback) {
    return new AsyncVDOMBuilder(this.global);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| `out` | `AsyncStream`/`AsyncVDOMBuilder` | The async `out` to render to |
| return value | `AsyncStream`/`AsyncVDOMBuilder` | The `out` that was passed |

The `render` method also allows passing an existing async `out`.  If you do this, `render` will not automatically end the async `
out` (this allows rendering a view in the middle of another view).  If the async `out` won't be ended by other means, you are
 responsible for ending it.

```js
var view = require('./view'); // Import `./view.marko`
var out = view.<span class="apidocCodeKeywordSpan">createOut</span>();

view.render({}, out);

out.on('finish', () =&gt; {
    console.log(out.getOutput());
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.e" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.e">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>e
        <span class="apidocSignatureSpan">(tagName, attrs, childCount, flags, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">e = function (tagName, attrs, childCount, flags, props) {
    var element = new VElement(tagName, attrs, childCount, flags, props);

    var parent = this.$__parent;

    if (parent !== undefined) {
        parent.$__appendChild(element);
    }

    return childCount === 0 ? this : element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function render(data, out) {
var colors = data.colors;

if (colors &amp;&amp; colors.length) {
  out.be("ul");

  marko_forEach(colors, function(color) {
    out.<span class="apidocCodeKeywordSpan">e</span>("li", marko_attrs0, 1)
      .t(marko_str(color));
  });

  out.ee();
} else {
  out.n(marko_node0);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.ee" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.ee">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>ee
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ee = function () {
    var stack = this.$__stack;
    stack.pop();
    this.$__parent = stack[stack.length-1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    out.be("ul");

    marko_forEach(colors, function(color) {
      out.e("li", marko_attrs0, 1)
        .t(marko_str(color));
    });

    out.<span class="apidocCodeKeywordSpan">ee</span>();
  } else {
    out.n(marko_node0);
  }
}
```

The VDOM output allows optimizations that were previously not possible:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.element" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.element">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>element
        <span class="apidocSignatureSpan">(tagName, attrs, childCount, flags, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">element = function (tagName, attrs, childCount, flags, props) {
    var element = new VElement(tagName, attrs, childCount, flags, props);

    var parent = this.$__parent;

    if (parent !== undefined) {
        parent.$__appendChild(element);
    }

    return childCount === 0 ? this : element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var rootEls = existingComponent.$__getRootEls({});

    for (var elId in rootEls) {
        var el = rootEls[elId];

        // We put a placeholder element in the output stream to ensure that the existing
        // DOM node is matched up correctly when using morphdom.
        out.<span class="apidocCodeKeywordSpan">element</span>(el.tagName, { id: elId });

        componentsContext.$__globalContext.$__preserveDOMNode(elId); // Mark the element as being preserved (for morphdom)
    }

    existingComponent.$__reset(); // The component is no longer dirty so reset internal flags
    return true;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.emit" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.emit">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>emit
        <span class="apidocSignatureSpan">(type, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (type, arg) {
    var events = this.$__state.$__events;
    switch(arguments.length) {
        case 1:
            events.emit(type);
            break;
        case 2:
            events.emit(type, arg);
            break;
        default:
            events.emit.apply(events, arguments);
            break;
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var isWhitespacePreserved = node.isPreserveWhitespace();

if (isWhitespacePreserved) {
    this.context.beginPreserveWhitespace();
}

beforeAfterEvent.isBefore = true;
beforeAfterEvent.node.<span class="apidocCodeKeywordSpan">emit</span>('beforeGenerateCode', beforeAfterEvent);
this.context.emit('beforeGenerateCode:' + beforeAfterEvent.node.type, beforeAfterEvent);
this.context.emit('beforeGenerateCode', beforeAfterEvent);

if (beforeAfterEvent.insertedNodes) {
    this._generateCode(beforeAfterEvent.insertedNodes, finalNodes);
    beforeAfterEvent.insertedNodes = null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.end" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.end">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
    var state = this.$__state;

    this.$__parent = undefined;

    var remaining = --state.$__remaining;

    if (!(state.$__flags &amp; FLAG_LAST_FIRED) &amp;&amp; (remaining - state.$__lastCount === 0)) {
        state.$__flags |= FLAG_LAST_FIRED;
        state.$__lastCount = 0;
        state.$__events.emit('last');
    }

    if (remaining === 0) {
        state.$__flags |= FLAG_FINISHED;
        state.$__events.emit(EVENT_FINISH, this.$__getResult());
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            template.render(templateData, out);
        };
    }

    renderer.render = function(input) {
        var out = createOut();
        renderer(input, out);
        return out.<span class="apidocCodeKeywordSpan">end</span>();
    };

    return renderer;
}

module.exports = defineRenderer;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.endElement" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.endElement">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>endElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endElement = function () {
    var stack = this.$__stack;
    stack.pop();
    this.$__parent = stack[stack.length-1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.error" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.error">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>error
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (e) {
    try {
        this.emit('error', e);
    } finally {
        // If there is no listener for the error event then it will
        // throw a new Error here. In order to ensure that the async fragment
        // is still properly ended we need to put the end() in a `finally`
        // block
        this.end();
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        compile(file, context);
    }
}
            },
            function(err) {
if (err) {
    if (failed.length) {
        console.<span class="apidocCodeKeywordSpan">error</span>('The following errors occurred:\n- ' + failed.join(&amp;#
x27;\n- '));
    } else {
        console.error(err);
    }

    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.flush" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.flush">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {
    var events = this.$__state.$__events;

    if (events.listenerCount(EVENT_UPDATE)) {
        events.emit(EVENT_UPDATE, new RenderResult(this));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            // Yes, we are monkey-patching http. This method should never have been added and it was introduced on
            // the iojs fork. It was quickly deprecated and I'm 99% sure no one is actually using it.
            // See:
            // - https://github.com/marko-js/async-writer/issues/3
            // - https://github.com/nodejs/node/issues/2920
            //
            // This method causes problems since marko looks for the flush method and calls it found.
            // The `res.<span class="apidocCodeKeywordSpan">flush</span>()` method is introduced by the [compression](https://www
.npmjs.com/package/compression)
            // middleware, but, otherwise, it should typically not exist.
            delete require('http').OutgoingMessage.prototype.flush;
        }
    } catch(e) {}
}

fixFlush();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.h" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.h">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>h
        <span class="apidocSignatureSpan">(html)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">h = function (html) {
    if (html != null) {
        var vdomNode = virtualizeHTML(html, this.$__document);
        this.node(vdomNode);
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var type = typeof text;

if (type != 'string') {
    if (text == null) {
        return;
    } else if (type === 'object') {
        if (text.toHTML) {
            return this.<span class="apidocCodeKeywordSpan">h</span>(text.toHTML());
        }
    }

    text = text.toString();
}

var parent = this.$__parent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.html" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.html">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>html
        <span class="apidocSignatureSpan">(html)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">html = function (html) {
    if (html != null) {
        var vdomNode = virtualizeHTML(html, this.$__document);
        this.node(vdomNode);
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

generateHTMLCode(codegen) {
    var builder = codegen.builder;

    return [
        builder.htmlLiteral('&lt;!'),
        builder.<span class="apidocCodeKeywordSpan">html</span>(codegen.generateCode(this.documentType)),
        builder.htmlLiteral('&gt;')
    ];
}

generateVDOMCode(codegen) {
    return null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.isSync" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.isSync">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>isSync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSync = function () {
    return this.$__sync;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var roots = componentProps.roots;
    var assignedId = componentProps.id;
    var split = componentProps.split;

    return function renderer(input, out) {
var outGlobal = out.global;

if (out.<span class="apidocCodeKeywordSpan">isSync</span>() === false) {
    if (!outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY]) {
        outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY] = true;
        out.on('beginAsync', handleBeginAsync);
    }
}

var component = outGlobal.$w;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.n" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.n">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>n
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">n = function (node) {
    // NOTE: We do a shallow clone since we assume the node is being reused
    //       and a node can only have one parent node.
    return this.node(node.$__cloneNode());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    marko_forEach(colors, function(color) {
      out.e("li", marko_attrs0, 1)
        .t(marko_str(color));
    });

    out.ee();
  } else {
    out.<span class="apidocCodeKeywordSpan">n</span>(marko_node0);
  }
}
```

The VDOM output allows optimizations that were previously not possible:

- Static subtrees are pulled into variables that are only initialized once and reused for every render
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.node" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.node">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>node
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">node = function (node) {
    var parent = this.$__parent;
    if (parent !== undefined) {
        parent.$__appendChild(node);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    return childCount === 0 ? this : element;
},

n: function(node) {
    // NOTE: We do a shallow clone since we assume the node is being reused
    //       and a node can only have one parent node.
    return this.<span class="apidocCodeKeywordSpan">node</span>(node.$__cloneNode());
},

node: function(node) {
    var parent = this.$__parent;
    if (parent !== undefined) {
        parent.$__appendChild(node);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.on" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.on">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>on
        <span class="apidocSignatureSpan">(event, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (event, callback) {
    var state = this.$__state;

    if (event === EVENT_FINISH &amp;&amp; (state.$__flags &amp; FLAG_FINISHED)) {
        callback(this.$__getResult());
    } else {
        state.$__events.on(event, callback);
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var target = getEventFromEl(node, 'onattach');
        if (target) {
var data = out.data;

var attachTargets = data.$__attachTargets;
if (!attachTargets) {
    attachTargets = data.$__attachTargets = [];
    out.<span class="apidocCodeKeywordSpan">on</span>('$__componentsInitialized', function() {
        for (var i=0; i&lt;attachTargets.length; i+=2) {
            var node = attachTargets[i];
            var target = attachTargets[i+1];
            delegateEvent(node, target, {});
        }
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.onLast" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.onLast">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>onLast
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onLast = function (callback) {
    var state = this.$__state;

    var lastArray = state.$__last;

    if (!lastArray) {
        lastArray = state.$__last = [];
        var i = 0;
        var next = function() {
            if (i === lastArray.length) {
                return;
            }
            var _next = lastArray[i++];
            _next(next);
        };

        this.once('last', function() {
            next();
        });
    }

    lastArray.push(callback);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            // rendered synchronously
            writeInitComponentsCode(out, true);
        } else {
            // Generate initialization code for any of the UI components that were
            // rendered asynchronously, but were outside an `&lt;await&gt;` tag
            // (each `&lt;await&gt;` tag will have its own component initialization block)
            var asyncOut = out.beginAsync({ last: true, timeout: -1 });
            out.<span class="apidocCodeKeywordSpan">onLast</span>(function(next) {
                writeInitComponentsCode(asyncOut, true);
                asyncOut.end();
                next();
            });
        }
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.once" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.once">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>once
        <span class="apidocSignatureSpan">(event, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (event, callback) {
    var state = this.$__state;

    if (event === EVENT_FINISH &amp;&amp; (state.$__flags &amp; FLAG_FINISHED)) {
        callback(this.$__getResult());
        return this;
    }

    state.$__events.once(event, callback);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var express = module.parent.require('express');
patchResponse(express.response);
delete require.cache[__filename];

module.exports = function markoAppMiddleware() {
var sacrificialApp = express();

sacrificialApp.<span class="apidocCodeKeywordSpan">once</span>('mount', function onmount(parent) {
    // Patch the response
    patchResponse(parent.response);

    // Remove sacrificial express app
    parent._router.stack.pop();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.removeListener" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.removeListener">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () {
    var events = this.$__state.$__events;
    events.removeListener.apply(events, arguments);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.sync" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.sync">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>sync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sync = function () {
    this.$__sync = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var fromEls = self.$__getRootEls({});
        var doc = self.$__document;
        input = this.$__renderInput || this.$__input;

        updateManager.$__batchUpdate(function() {
var createOut = renderer.createOut || marko.createOut;
var out = createOut(globalData);
out.<span class="apidocCodeKeywordSpan">sync</span>();
out.$__document = self.$__document;
renderer(input, out);
var result = new RenderResult(out);
var targetNode = out.$__getOutput();

var globalComponentsContext = out.global.components;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.t" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.t">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>t
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">t = function (text) {
    var type = typeof text;

    if (type != 'string') {
        if (text == null) {
            return;
        } else if (type === 'object') {
            if (text.toHTML) {
                return this.h(text.toHTML());
            }
        }

        text = text.toString();
    }

    var parent = this.$__parent;
    if (parent !== undefined) {
        var lastChild = parent.lastChild;
        if (lastChild &amp;&amp; lastChild.$__Text) {
            lastChild.nodeValue += text;
        } else {
            parent.$__appendChild(new VText(text));
        }
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_Compiled for VDOM output (browser-side):_

```javascript
var marko_attrs0 = {
      "class": "color"
    },
  marko_node0 = marko_createElement("div", null, 1, marko_const_nextId())
    .<span class="apidocCodeKeywordSpan">t</span>("No colors!");

function render(data, out) {
var colors = data.colors;

if (colors &amp;&amp; colors.length) {
  out.be("ul");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.text" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.text">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>text
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">text = function (text) {
    var type = typeof text;

    if (type != 'string') {
        if (text == null) {
            return;
        } else if (type === 'object') {
            if (text.toHTML) {
                return this.h(text.toHTML());
            }
        }

        text = text.toString();
    }

    var parent = this.$__parent;
    if (parent !== undefined) {
        var lastChild = parent.lastChild;
        if (lastChild &amp;&amp; lastChild.$__Text) {
            lastChild.nodeValue += text;
        } else {
            parent.$__appendChild(new VText(text));
        }
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // NOTE: If parseMode is 'static-text' or 'parsed-text' then that means that special
    //       HTML characters may not have been escaped on the way in so we need to escape
    //       them on the way out

    if (this.prevTextNode &amp;&amp; this.prevTextNode.isLiteral() &amp;&amp; this.prevTextNode.escape === escape) {
        this.prevTextNode.argument.value += text;
    } else {
        this.prevTextNode = builder.<span class="apidocCodeKeywordSpan">text</span>(builder.literal(text), escape);
        this.parentNode.appendChild(this.prevTextNode);
    }
}

handleStartElement(el, parser) {
    var context = this.context;
    var builder = context.builder;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.then" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.then">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>then
        <span class="apidocSignatureSpan">(fn, fnErr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (fn, fnErr) {
    var out = this;
    var promise = new Promise(function(resolve, reject) {
        out.on('error', reject)
            .on(EVENT_FINISH, function(result) {
                resolve(result);
            });
    });

    return Promise.resolve(promise).then(fn, fnErr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
template.render({}, function(err, html, out) {});
```

**New:**
```js
template.render({})
        .<span class="apidocCodeKeywordSpan">then</span>(function(result){})
        .catch(function(err) {});

// render() can now be used with async/await
var out = await template.render({});
out.appendTo(document.body);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.toString" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.toString">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return this.$__getNode().outerHTML;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
component.render(data); // returns `out`
component.render(data, (err, out) =&gt; {});
component.renderSync(data); // returns `out`
```

Also, `out` has been updated to implement DOM manipulation methods like `appendTo` that were previously only available from the `
RenderResult` returned from component renders.

NOTE: We will implement `out.<span class="apidocCodeKeywordSpan">toString</span>()` and `out.toJSON()` so in many cases the `out
` can be used as a string.

### Remove support for deprecated `empty`/`notEmpty` helpers ([#357](https://github.com/marko-js/marko/issues/357))

&gt; Already deprecated in v3

The `empty`/`notEmpty` helpers were automatically being added to every compiled
template. While they can be helpful, we feel it is better if the developer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.w" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.w">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>w
        <span class="apidocSignatureSpan">(html)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">w = function (html) {
    if (html != null) {
        var vdomNode = virtualizeHTML(html, this.$__document);
        this.node(vdomNode);
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_Compiled for HTML output (server-side):_

```javascript
function render(data, out) {
  var colors = data.colors;

  if (colors &amp;&amp; colors.length) {
out.<span class="apidocCodeKeywordSpan">w</span>("&lt;ul&gt;");

marko_forEach(colors, function(color) {
  out.w("&lt;li class=\"color\"&gt;" +
    marko_escapeXml(color) +
    "&lt;/li&gt;");
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.AsyncVDOMBuilder.prototype.write" id="apidoc.element.marko.AsyncVDOMBuilder.prototype.write">
        function <span class="apidocSignatureSpan">marko.AsyncVDOMBuilder.prototype.</span>write
        <span class="apidocSignatureSpan">(html)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (html) {
    if (html != null) {
        var vdomNode = virtualizeHTML(html, this.$__document);
        this.node(vdomNode);
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    getCode() {
return this._code;
    }

    writeBlock(body) {
if (!body) {
    this.<span class="apidocCodeKeywordSpan">write</span>('{}');
    return;
}

if (typeof body === 'function') {
    body = body();
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.BufferedWriter" id="apidoc.module.marko.BufferedWriter">module marko.BufferedWriter</a></h1>


    <h2>
        <a href="#apidoc.element.marko.BufferedWriter.BufferedWriter" id="apidoc.element.marko.BufferedWriter.BufferedWriter">
        function <span class="apidocSignatureSpan">marko.</span>BufferedWriter
        <span class="apidocSignatureSpan">(wrappedStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferedWriter(wrappedStream) {
    this._buffer = '';
    this._wrapped = wrappedStream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.BufferedWriter.prototype" id="apidoc.module.marko.BufferedWriter.prototype">module marko.BufferedWriter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.BufferedWriter.prototype.clear" id="apidoc.element.marko.BufferedWriter.prototype.clear">
        function <span class="apidocSignatureSpan">marko.BufferedWriter.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
    this._buffer = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function loadTaglibFromFile(filePath) {
    return loaders.loadTaglibFromFile(filePath);
}

function clearCache() {
    cache.<span class="apidocCodeKeywordSpan">clear</span>();
}

function createTaglib(filePath) {
    return new types.Taglib(filePath);
}

function loadTag(tagProps, filePath) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.BufferedWriter.prototype.end" id="apidoc.element.marko.BufferedWriter.prototype.end">
        function <span class="apidocSignatureSpan">marko.BufferedWriter.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
    this.flush();
    if (!this._wrapped.isTTY) {
        this._wrapped.end();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            template.render(templateData, out);
        };
    }

    renderer.render = function(input) {
        var out = createOut();
        renderer(input, out);
        return out.<span class="apidocCodeKeywordSpan">end</span>();
    };

    return renderer;
}

module.exports = defineRenderer;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.BufferedWriter.prototype.flush" id="apidoc.element.marko.BufferedWriter.prototype.flush">
        function <span class="apidocSignatureSpan">marko.BufferedWriter.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {
    if (this._buffer.length !== 0) {
        this._wrapped.write(this._buffer);
        this._buffer = '';
        if (this._wrapped.flush) {
            this._wrapped.flush();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            // Yes, we are monkey-patching http. This method should never have been added and it was introduced on
            // the iojs fork. It was quickly deprecated and I'm 99% sure no one is actually using it.
            // See:
            // - https://github.com/marko-js/async-writer/issues/3
            // - https://github.com/nodejs/node/issues/2920
            //
            // This method causes problems since marko looks for the flush method and calls it found.
            // The `res.<span class="apidocCodeKeywordSpan">flush</span>()` method is introduced by the [compression](https://www
.npmjs.com/package/compression)
            // middleware, but, otherwise, it should typically not exist.
            delete require('http').OutgoingMessage.prototype.flush;
        }
    } catch(e) {}
}

fixFlush();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.BufferedWriter.prototype.write" id="apidoc.element.marko.BufferedWriter.prototype.write">
        function <span class="apidocSignatureSpan">marko.BufferedWriter.prototype.</span>write
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (str) {
    this._buffer += str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    getCode() {
return this._code;
    }

    writeBlock(body) {
if (!body) {
    this.<span class="apidocCodeKeywordSpan">write</span>('{}');
    return;
}

if (typeof body === 'function') {
    body = body();
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.Component" id="apidoc.module.marko.Component">module marko.Component</a></h1>


    <h2>
        <a href="#apidoc.element.marko.Component.Component" id="apidoc.element.marko.Component.Component">
        function <span class="apidocSignatureSpan">marko.</span>Component
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Component(id) {
    EventEmitter.call(this);
    this.id = id;
    this.el = null;
    this.$__state = null;
    this.$__roots = null;
    this.$__subscriptions = null;
    this.$__domEventListenerHandles = null;
    this.$__bubblingDomEvents = null;
    this.$__customEvents = null;
    this.$__scope = null;
    this.$__renderInput = null;
    this.$__input = undefined;

    this.$__destroyed = false;
    this.$__updateQueued = false;
    this.$__dirty = false;
    this.$__settingInput = false;

    this.$__document = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.Component.prototype" id="apidoc.module.marko.Component.prototype">module marko.Component.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.Component.prototype.appendTo" id="apidoc.element.marko.Component.prototype.appendTo">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>appendTo
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendTo = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.appendChild(el);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var myCounter = require('./src/components/my-counter');

var component = myCounter.renderSync({
        value: 10
    })
    .<span class="apidocCodeKeywordSpan">appendTo</span>(document.body)
    .getComponent();

component.increment();
```

Of course, a single file component can also be embedded in another template as a custom tag:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.destroy" id="apidoc.element.marko.Component.prototype.destroy">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
    if (this.$__destroyed) {
        return;
    }

    var els = this.els;

    this.$__destroyShallow();

    var rootComponents = this.$__rootComponents;
    if (rootComponents) {
        rootComponents.forEach(function(rootComponent) {
            rootComponent.$__destroy();
        });
    }

    els.forEach(function(el) {
        destroyElRecursive(el);

        var parentNode = el.parentNode;
        if (parentNode) {
            parentNode.removeChild(el);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| ------- | ---- | ------- | ----------- |
| `removeNode` | `Boolean` | `true` | `false` will keep the component in the DOM while still unsubscribing all events from it |
| `recursive` | `Boolean` | `true` | `false` will prevent child components from being destroyed |

Destroys the component by unsubscribing from all listeners made using the `subscribeTo` method and then detaching the component&amp;#
x27;s root element from the DOM. All nested components (discovered by querying the DOM) are also destroyed.

```javascript
component.<span class="apidocCodeKeywordSpan">destroy</span>({
	removeNode: true, //true by default
	recursive: true //true by default
})
```

### `forceUpdate()`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.elId" id="apidoc.element.marko.Component.prototype.elId">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>elId
        <span class="apidocSignatureSpan">(componentElId, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">elId = function (componentElId, index) {
    return getElIdHelper(this, componentElId, index);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.emit" id="apidoc.element.marko.Component.prototype.emit">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>emit
        <span class="apidocSignatureSpan">(eventType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (eventType) {
    var customEvents = this.$__customEvents;
    var target;

    if (customEvents &amp;&amp; (target = customEvents[eventType])) {
        var targetMethodName = target[0];
        var extraArgs = target[1];
        var args = slice.call(arguments, 1);

        handleCustomEventWithMethodListener(this, targetMethodName, args, extraArgs);
    }

    if (this.listenerCount(eventType)) {
        return emit.apply(this, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var isWhitespacePreserved = node.isPreserveWhitespace();

if (isWhitespacePreserved) {
    this.context.beginPreserveWhitespace();
}

beforeAfterEvent.isBefore = true;
beforeAfterEvent.node.<span class="apidocCodeKeywordSpan">emit</span>('beforeGenerateCode', beforeAfterEvent);
this.context.emit('beforeGenerateCode:' + beforeAfterEvent.node.type, beforeAfterEvent);
this.context.emit('beforeGenerateCode', beforeAfterEvent);

if (beforeAfterEvent.insertedNodes) {
    this._generateCode(beforeAfterEvent.insertedNodes, finalNodes);
    beforeAfterEvent.insertedNodes = null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.forceUpdate" id="apidoc.element.marko.Component.prototype.forceUpdate">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>forceUpdate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forceUpdate = function () {
    this.$__dirty = true;
    this.$__queueUpdate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### `forceUpdate()`

Queue the component to re-render and skip all checks to see if it actually needs it.

&gt; When using `forceUpdate()` the updating of the DOM will be queued up. If you want to immediately update the DOM
&gt; then call `this.update()` after calling `this.<span class="apidocCodeKeywordSpan">forceUpdate</span>()`.

### `getEl([key, index])`

| params  | type | description |
| ------- | ---- | ----------- |
| `key` | `String` | _optional_ the scoped identifier for the element |
| `index` | `Number` | _optional_ the index of the component, if `key` references a repeated component |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.getComponent" id="apidoc.element.marko.Component.prototype.getComponent">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getComponent
        <span class="apidocSignatureSpan">(id, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComponent = function (id, index) {
    return componentLookup[getElIdHelper(this, id, index)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var myCounter = require('./src/components/my-counter');

var component = myCounter.renderSync({
        value: 10
    })
    .appendTo(document.body)
    .<span class="apidocCodeKeywordSpan">getComponent</span>();

component.increment();
```

Of course, a single file component can also be embedded in another template as a custom tag:

```xml
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.getComponents" id="apidoc.element.marko.Component.prototype.getComponents">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getComponents
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComponents = function (id) {
    var components = [];
    var i = 0;
    var component;
    while((component = componentLookup[getElIdHelper(this, id, i)])) {
        components.push(component);
        i++;
    }
    return components;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   this.$__components = undefined;
}

module.exports = RenderResult;

var proto = RenderResult.prototype = {
    getComponent: function() {
return this.<span class="apidocCodeKeywordSpan">getComponents</span>()[0];
    },
    getComponents: function(selector) {
if (this.$__components === undefined) {
    throw Error('Not added to DOM');
}

var componentDefs = getComponentDefs(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.getEl" id="apidoc.element.marko.Component.prototype.getEl">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getEl
        <span class="apidocSignatureSpan">(componentElId, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEl = function (componentElId, index) {
    var doc = this.$__document;

    if (componentElId != null) {
        return getElementById(doc, getElIdHelper(this, componentElId, index));
    } else {
        return this.el || getElementById(doc, getElIdHelper(this));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
} else if (typeof arg === 'string') {
    var match = idRegExp.exec(arg);
    //Reset the search to 0 so the next call to exec will start from the beginning for the new string
    if (match != null) {
        var componentElId = match[1];
        if (match[2] == null) {
            return jQuery(self.<span class="apidocCodeKeywordSpan">getEl</span>(componentElId));
        } else {
            return jQuery('#' + self.getElId(componentElId) + match[2]);
        }
    } else {
        var rootEl = self.getEl();
        if (!rootEl) {
            throw new Error('Root element is not defined for component');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.getElId" id="apidoc.element.marko.Component.prototype.getElId">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getElId
        <span class="apidocSignatureSpan">(componentElId, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getElId = function (componentElId, index) {
    return getElIdHelper(this, componentElId, index);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var match = idRegExp.exec(arg);
//Reset the search to 0 so the next call to exec will start from the beginning for the new string
if (match != null) {
    var componentElId = match[1];
    if (match[2] == null) {
        return jQuery(self.getEl(componentElId));
    } else {
        return jQuery('#' + self.<span class="apidocCodeKeywordSpan">getElId</span>(componentElId) + match[2]);
    }
} else {
    var rootEl = self.getEl();
    if (!rootEl) {
        throw new Error('Root element is not defined for component');
    }
    if (rootEl) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.getEls" id="apidoc.element.marko.Component.prototype.getEls">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>getEls
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEls = function (id) {
    var els = [];
    var i = 0;
    var el;
    while((el = this.getEl(id, i))) {
        els.push(el);
        i++;
    }
    return els;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &lt;li key="colors[1]"&gt;green&lt;/li&gt;
    &lt;li key="colors[2]"&gt;blue&lt;/li&gt;
&lt;/ul&gt;
```

The containing component can reference the repeated DOM elements using the following code:
```js
var colorLIs = this.<span class="apidocCodeKeywordSpan">getEls</span>('colors'); // Returns an Array of HTMLElement nodes
```

### `for-key`

The [HTML `&lt;label&gt;`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label) `for` attribute takes an `id` as
 its value.  `for-key` allows you to reference a labelable element via its `key`:

```marko
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.insertAfter" id="apidoc.element.marko.Component.prototype.insertAfter">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>insertAfter
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertAfter = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    el = el;
    var nextSibling = referenceEl.nextSibling;
    var parentNode = referenceEl.parentNode;
    if (nextSibling) {
        parentNode.insertBefore(el, nextSibling);
    } else {
        parentNode.appendChild(el);
    }
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.insertBefore" id="apidoc.element.marko.Component.prototype.insertBefore">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>insertBefore
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertBefore = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.parentNode.insertBefore(el, referenceEl);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// it.

// NOTE: We use insertBefore instead of replaceChild because we want to go through
// the `removeNode()` function for the node that is being discarded so that
// all lifecycle hooks are correctly invoked


fromEl.<span class="apidocCodeKeywordSpan">insertBefore</span>(matchingFromEl, curFromNodeChild);

var curToNodeChildNextSibling = curToNodeChild.nextSibling;
if (curToNodeChildNextSibling &amp;&amp; curToNodeChildNextSibling.id === curFromNodeKey) {
    fromNextSibling = curFromNodeChild;
} else {
    fromNextSibling = curFromNodeChild.nextSibling;
    removalList.push(curFromNodeChild);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.isDestroyed" id="apidoc.element.marko.Component.prototype.isDestroyed">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>isDestroyed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDestroyed = function () {
    return this.$__destroyed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.prependTo" id="apidoc.element.marko.Component.prototype.prependTo">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>prependTo
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependTo = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.insertBefore(el, referenceEl.firstChild || null);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.replace" id="apidoc.element.marko.Component.prototype.replace">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>replace
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    beforeRemove(referenceEl);
    referenceEl.parentNode.replaceChild(el, referenceEl);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
require('./template.marko')
    .renderSync({ name: 'Frank '})
    .appendTo(document.body);

// Replace an existing DOM node:
require('./template.marko')
    .renderSync({ name: 'Frank '})
    .<span class="apidocCodeKeywordSpan">replace</span>(document.getElementById('foo'));
```

## Other Improvements

### Only diff attributes that are rendered by Marko ([#417](https://github.com/marko-js/marko/issues/417))

Previously, when diffing the DOM, all of the attributes on a real HTML element node were diffed with all of the attributes on a
newly rendered HTML element node. This posed a problem when using Marko with third party libraries, such as animation libraries,
that added HTML attributes that should have been left alone. The proposed workaround was to add the `w-preserve-attrs` attribute
 wherever needed.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.replaceChildrenOf" id="apidoc.element.marko.Component.prototype.replaceChildrenOf">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>replaceChildrenOf
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceChildrenOf = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);

    var curChild = referenceEl.firstChild;
    while(curChild) {
        var nextSibling = curChild.nextSibling; // Just in case the DOM changes while removing
        if (curChild.nodeType == 1) {
            beforeRemove(curChild);
        }
        curChild = nextSibling;
    }

    referenceEl.innerHTML = '';
    referenceEl.appendChild(el);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.replaceState" id="apidoc.element.marko.Component.prototype.replaceState">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>replaceState
        <span class="apidocSignatureSpan">(newState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceState = function (newState) {
    this.$__state.$__replace(newState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.setState" id="apidoc.element.marko.Component.prototype.setState">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>setState
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setState = function (name, value) {
    var state = this.$__state;

    if (typeof name == 'object') {
        // Merge in the new state with the old state
        var newState = name;
        for (var k in newState) {
            if (newState.hasOwnProperty(k)) {
                state.$__set(k, newState[k], true /* ensure:true */);
            }
        }
    } else {
        state.$__set(name, value, true /* ensure:true */);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
{
    getInitialState(input) {
        return {
            count: input.count || 0
        };
    }
    increment() {
        this.<span class="apidocCodeKeywordSpan">setState</span>('count', this.state.count+1);
    }
}
```

**New:**

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.setStateDirty" id="apidoc.element.marko.Component.prototype.setStateDirty">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>setStateDirty
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setStateDirty = function (name, value) {
    var state = this.$__state;

    if (arguments.length == 1) {
        value = state[name];
    }

    state.$__set(name, value, true /* ensure:true */, true /* forceDirty:true */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
We recommend using [immutable](https://wecodetheweb.com/2016/02/12/immutable-javascript-using-es6-and-beyond/) data structures,
but if you want to mutate a state property (perhaps push a new item into an array) you can mark it as dirty using `setStateDirty
`.

```js
this.state.numbers.push(num);

// mark numbers as dirty, because a `push`
// won't be automatically detected by Marko
this.<span class="apidocCodeKeywordSpan">setStateDirty</span>('numbers');
```

### `this.input`

The current input for the component.  Setting `this.input` will result in the component being re-rendered.

## Variables
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.shouldUpdate" id="apidoc.element.marko.Component.prototype.shouldUpdate">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>shouldUpdate
        <span class="apidocSignatureSpan">(newState, newProps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shouldUpdate = function (newState, newProps) {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }

    if (this.$__isDirty === true) {
        // The UI component is still dirty after process state handlers
        // then we should rerender

        if (this.<span class="apidocCodeKeywordSpan">shouldUpdate</span>(input, state) !== false) {
            this.$__rerender();
        }
    }

    this.$__reset();
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.subscribeTo" id="apidoc.element.marko.Component.prototype.subscribeTo">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>subscribeTo
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeTo = function (target) {
    if (!target) {
        throw TypeError();
    }

    var subscriptions = this.$__subscriptions || (this.$__subscriptions = new SubscriptionTracker());

    var subscribeToOptions = target.$__isComponent ?
        COMPONENT_SUBSCRIBE_TO_OPTIONS :
        NON_COMPONENT_SUBSCRIBE_TO_OPTIONS;

    return subscriptions.subscribeTo(target, subscribeToOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var subscriptions = this.$__subscriptions || (this.$__subscriptions = new SubscriptionTracker());

var subscribeToOptions = target.$__isComponent ?
    COMPONENT_SUBSCRIBE_TO_OPTIONS :
    NON_COMPONENT_SUBSCRIBE_TO_OPTIONS;

return subscriptions.<span class="apidocCodeKeywordSpan">subscribeTo</span>(target, subscribeToOptions);
    },

    emit: function(eventType) {
var customEvents = this.$__customEvents;
var target;

if (customEvents &amp;&amp; (target = customEvents[eventType])) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Component.prototype.update" id="apidoc.element.marko.Component.prototype.update">
        function <span class="apidocSignatureSpan">marko.Component.prototype.</span>update
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function () {
    if (this.$__destroyed === true || this.$__isDirty === false) {
        return;
    }

    var input = this.$__input;
    var state = this.$__state;

    if (this.$__dirty === false &amp;&amp; state !== null &amp;&amp; state.$__dirty === true) {
        if (processUpdateHandlers(this, state.$__changes, state.$__old, state)) {
            state.$__dirty = false;
        }
    }

    if (this.$__isDirty === true) {
        // The UI component is still dirty after process state handlers
        // then we should rerender

        if (this.shouldUpdate(input, state) !== false) {
            this.$__rerender();
        }
    }

    this.$__reset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### `forceUpdate()`

Queue the component to re-render and skip all checks to see if it actually needs it.

&gt; When using `forceUpdate()` the updating of the DOM will be queued up. If you want to immediately update the DOM
&gt; then call `this.<span class="apidocCodeKeywordSpan">update</span>()` after calling `this.forceUpdate()`.

### `getEl([key, index])`

| params  | type | description |
| ------- | ---- | ----------- |
| `key` | `String` | _optional_ the scoped identifier for the element |
| `index` | `Number` | _optional_ the index of the component, if `key` references a repeated component |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.ComponentDef" id="apidoc.module.marko.ComponentDef">module marko.ComponentDef</a></h1>


    <h2>
        <a href="#apidoc.element.marko.ComponentDef.ComponentDef" id="apidoc.element.marko.ComponentDef.ComponentDef">
        function <span class="apidocSignatureSpan">marko.</span>ComponentDef
        <span class="apidocSignatureSpan">(component, componentId, out, componentStack, componentStackLen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ComponentDef(component, componentId, out, componentStack, componentStackLen) {
    this.$__out = out; // The AsyncWriter that this component is associated with
    this.$__componentStack = componentStack;
    this.$__componentStackLen = componentStackLen;
    this.$__component = component;
    this.id = componentId;

    this.$__roots =  null;            // IDs of root elements if there are multiple root elements
    this.$__children = null;          // An array of nested ComponentDef instances
    this.$__domEvents = null;         // An array of DOM events that need to be added (in sets of three)
    this.$__bubblingDomEvents = null; // Used to keep track of bubbling DOM events for components rendered on the server

    this.$__isExisting = false;

    this.$__nextIdIndex = 0; // The unique integer to use for the next scoped ID
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.ComponentDef.prototype" id="apidoc.module.marko.ComponentDef.prototype">module marko.ComponentDef.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.ComponentDef.prototype.d" id="apidoc.element.marko.ComponentDef.prototype.d">
        function <span class="apidocSignatureSpan">marko.ComponentDef.prototype.</span>d
        <span class="apidocSignatureSpan">(handlerMethodName, extraArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">d = function (handlerMethodName, extraArgs) {
    return attachBubblingEvent(this, handlerMethodName, extraArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.ComponentDef.prototype.e" id="apidoc.element.marko.ComponentDef.prototype.e">
        function <span class="apidocSignatureSpan">marko.ComponentDef.prototype.</span>e
        <span class="apidocSignatureSpan">(type, targetMethod, elId, extraArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">e = function (type, targetMethod, elId, extraArgs) {
    if (targetMethod) {
        // The event handler method is allowed to be conditional. At render time if the target
        // method is null then we do not attach any direct event listeners.
        (this.$__domEvents || (this.$__domEvents = [])).push([
            type,
            targetMethod,
            elId,
            extraArgs]);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function render(data, out) {
var colors = data.colors;

if (colors &amp;&amp; colors.length) {
  out.be("ul");

  marko_forEach(colors, function(color) {
    out.<span class="apidocCodeKeywordSpan">e</span>("li", marko_attrs0, 1)
      .t(marko_str(color));
  });

  out.ee();
} else {
  out.n(marko_node0);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.ComponentDef.prototype.elId" id="apidoc.element.marko.ComponentDef.prototype.elId">
        function <span class="apidocSignatureSpan">marko.ComponentDef.prototype.</span>elId
        <span class="apidocSignatureSpan">(nestedId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">elId = function (nestedId) {
    var id = this.id;
    if (nestedId == null) {
        return id;
    } else {
        if (typeof nestedId == 'string' &amp;&amp; repeatedRegExp.test(nestedId)) {
            return nextRepeatedId(this.$__out, id, nestedId);
        } else {
            return id + '-' + nestedId;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.ComponentsContext" id="apidoc.module.marko.ComponentsContext">module marko.ComponentsContext</a></h1>


    <h2>
        <a href="#apidoc.element.marko.ComponentsContext.ComponentsContext" id="apidoc.element.marko.ComponentsContext.ComponentsContext">
        function <span class="apidocSignatureSpan">marko.</span>ComponentsContext
        <span class="apidocSignatureSpan">(out, parentComponentsContext, shouldAddGlobalRoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ComponentsContext(out, parentComponentsContext, shouldAddGlobalRoot) {
    var root;

    var globalComponentsContext;

    if (parentComponentsContext === undefined) {
        root = new ComponentDef(null, null, out);

        globalComponentsContext = out.global.components;
        if (globalComponentsContext === undefined) {
            out.global.components = globalComponentsContext = new GlobalComponentsContext(out);
        }

        if (shouldAddGlobalRoot !== false) {
            globalComponentsContext.$__roots.push(root);
        }
    } else {
        globalComponentsContext = parentComponentsContext.$__globalContext;
        var parentComponentStack = parentComponentsContext.$__componentStack;
        root = parentComponentStack[parentComponentStack.length-1];
    }

    this.$__globalContext = globalComponentsContext;
    this.$__out = out;
    this.$__componentStack = [root];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.ComponentsContext.prototype" id="apidoc.module.marko.ComponentsContext.prototype">module marko.ComponentsContext.prototype</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.RenderResult" id="apidoc.module.marko.RenderResult">module marko.RenderResult</a></h1>


    <h2>
        <a href="#apidoc.element.marko.RenderResult.RenderResult" id="apidoc.element.marko.RenderResult.RenderResult">
        function <span class="apidocSignatureSpan">marko.</span>RenderResult
        <span class="apidocSignatureSpan">(out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RenderResult(out) {
   this.out = this.$__out = out;
   this.$__components = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.RenderResult.prototype" id="apidoc.module.marko.RenderResult.prototype">module marko.RenderResult.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.afterInsert" id="apidoc.element.marko.RenderResult.prototype.afterInsert">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>afterInsert
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterInsert = function (doc) {
    var out = this.$__out;
    var globalComponentsContext = out.global.components;
    if (globalComponentsContext) {
        this.$__components = globalComponentsContext.$__initComponents(doc);
    } else {
        this.$__components = null;
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        onBeforeElChildrenUpdated);
                }
            }

            targetEl = targetEl.nextSibling;
        }

        result.<span class="apidocCodeKeywordSpan">afterInsert</span>(doc);

        out.emit('$__componentsInitialized');
    });

    this.$__reset();
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.appendTo" id="apidoc.element.marko.RenderResult.prototype.appendTo">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>appendTo
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendTo = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.appendChild(el);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var myCounter = require('./src/components/my-counter');

var component = myCounter.renderSync({
        value: 10
    })
    .<span class="apidocCodeKeywordSpan">appendTo</span>(document.body)
    .getComponent();

component.increment();
```

Of course, a single file component can also be embedded in another template as a custom tag:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.getComponent" id="apidoc.element.marko.RenderResult.prototype.getComponent">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComponent = function () {
    return this.getComponents()[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var myCounter = require('./src/components/my-counter');

var component = myCounter.renderSync({
        value: 10
    })
    .appendTo(document.body)
    .<span class="apidocCodeKeywordSpan">getComponent</span>();

component.increment();
```

Of course, a single file component can also be embedded in another template as a custom tag:

```xml
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.getComponents" id="apidoc.element.marko.RenderResult.prototype.getComponents">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getComponents
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComponents = function (selector) {
    if (this.$__components === undefined) {
        throw Error('Not added to DOM');
    }

    var componentDefs = getComponentDefs(this);

    var components = [];

    componentDefs.forEach(function(componentDef) {
        var component = componentDef.$__component;
        if (!selector || selector(component)) {
            components.push(component);
        }
    });

    return components;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   this.$__components = undefined;
}

module.exports = RenderResult;

var proto = RenderResult.prototype = {
    getComponent: function() {
return this.<span class="apidocCodeKeywordSpan">getComponents</span>()[0];
    },
    getComponents: function(selector) {
if (this.$__components === undefined) {
    throw Error('Not added to DOM');
}

var componentDefs = getComponentDefs(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.getNode" id="apidoc.element.marko.RenderResult.prototype.getNode">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getNode
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNode = function (doc) {
    return this.$__out.$__getNode(doc);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// - replaceChildrenOf(referenceEl)
// - insertBefore(referenceEl)
// - insertAfter(referenceEl)
// - prependTo(referenceEl)
domInsert(
proto,
function getEl(renderResult, referenceEl) {
    return renderResult.<span class="apidocCodeKeywordSpan">getNode</span>(referenceEl.ownerDocument);
},
function afterInsert(renderResult, referenceEl) {
    return renderResult.afterInsert(referenceEl.ownerDocument);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.getOutput" id="apidoc.element.marko.RenderResult.prototype.getOutput">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>getOutput
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOutput = function () {
    return this.$__out.$__getOutput();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var view = require('./view'); // Import `./view.marko`
var out = view.createOut();

view.render({}, out);

out.on('finish', () =&gt; {
    console.log(out.<span class="apidocCodeKeywordSpan">getOutput</span>());
});

out.end();
```


### `renderToString(input)`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.insertAfter" id="apidoc.element.marko.RenderResult.prototype.insertAfter">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>insertAfter
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertAfter = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    el = el;
    var nextSibling = referenceEl.nextSibling;
    var parentNode = referenceEl.parentNode;
    if (nextSibling) {
        parentNode.insertBefore(el, nextSibling);
    } else {
        parentNode.appendChild(el);
    }
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.insertBefore" id="apidoc.element.marko.RenderResult.prototype.insertBefore">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>insertBefore
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertBefore = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.parentNode.insertBefore(el, referenceEl);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// it.

// NOTE: We use insertBefore instead of replaceChild because we want to go through
// the `removeNode()` function for the node that is being discarded so that
// all lifecycle hooks are correctly invoked


fromEl.<span class="apidocCodeKeywordSpan">insertBefore</span>(matchingFromEl, curFromNodeChild);

var curToNodeChildNextSibling = curToNodeChild.nextSibling;
if (curToNodeChildNextSibling &amp;&amp; curToNodeChildNextSibling.id === curFromNodeKey) {
    fromNextSibling = curFromNodeChild;
} else {
    fromNextSibling = curFromNodeChild.nextSibling;
    removalList.push(curFromNodeChild);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.prependTo" id="apidoc.element.marko.RenderResult.prototype.prependTo">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>prependTo
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependTo = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    referenceEl.insertBefore(el, referenceEl.firstChild || null);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.replace" id="apidoc.element.marko.RenderResult.prototype.replace">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>replace
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);
    beforeRemove(referenceEl);
    referenceEl.parentNode.replaceChild(el, referenceEl);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
require('./template.marko')
    .renderSync({ name: 'Frank '})
    .appendTo(document.body);

// Replace an existing DOM node:
require('./template.marko')
    .renderSync({ name: 'Frank '})
    .<span class="apidocCodeKeywordSpan">replace</span>(document.getElementById('foo'));
```

## Other Improvements

### Only diff attributes that are rendered by Marko ([#417](https://github.com/marko-js/marko/issues/417))

Previously, when diffing the DOM, all of the attributes on a real HTML element node were diffed with all of the attributes on a
newly rendered HTML element node. This posed a problem when using Marko with third party libraries, such as animation libraries,
that added HTML attributes that should have been left alone. The proposed workaround was to add the `w-preserve-attrs` attribute
 wherever needed.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.replaceChildrenOf" id="apidoc.element.marko.RenderResult.prototype.replaceChildrenOf">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>replaceChildrenOf
        <span class="apidocSignatureSpan">(referenceEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceChildrenOf = function (referenceEl) {
    referenceEl = resolveEl(referenceEl);
    var el = getEl(this, referenceEl);

    var curChild = referenceEl.firstChild;
    while(curChild) {
        var nextSibling = curChild.nextSibling; // Just in case the DOM changes while removing
        if (curChild.nodeType == 1) {
            beforeRemove(curChild);
        }
        curChild = nextSibling;
    }

    referenceEl.innerHTML = '';
    referenceEl.appendChild(el);
    return afterInsert(this, referenceEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.RenderResult.prototype.toString" id="apidoc.element.marko.RenderResult.prototype.toString">
        function <span class="apidocSignatureSpan">marko.RenderResult.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return this.$__out.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
component.render(data); // returns `out`
component.render(data, (err, out) =&gt; {});
component.renderSync(data); // returns `out`
```

Also, `out` has been updated to implement DOM manipulation methods like `appendTo` that were previously only available from the `
RenderResult` returned from component renders.

NOTE: We will implement `out.<span class="apidocCodeKeywordSpan">toString</span>()` and `out.toJSON()` so in many cases the `out
` can be used as a string.

### Remove support for deprecated `empty`/`notEmpty` helpers ([#357](https://github.com/marko-js/marko/issues/357))

&gt; Already deprecated in v3

The `empty`/`notEmpty` helpers were automatically being added to every compiled
template. While they can be helpful, we feel it is better if the developer
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.State" id="apidoc.module.marko.State">module marko.State</a></h1>


    <h2>
        <a href="#apidoc.element.marko.State.State" id="apidoc.element.marko.State.State">
        function <span class="apidocSignatureSpan">marko.</span>State
        <span class="apidocSignatureSpan">(component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function State(component) {
    this.$__component = component;
    this.$__raw = {};

    this.$__dirty = false;
    this.$__old = null;
    this.$__changes = null;
    this.$__forced = null; // An object that we use to keep tracking of state properties that were forced to be dirty

    Object.seal(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.State.prototype" id="apidoc.module.marko.State.prototype">module marko.State.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.State.prototype.toJSON" id="apidoc.element.marko.State.prototype.toJSON">
        function <span class="apidocSignatureSpan">marko.State.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
    return this.$__raw;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
component.render(data); // returns `out`
component.render(data, (err, out) =&gt; {});
component.renderSync(data); // returns `out`
```

Also, `out` has been updated to implement DOM manipulation methods like `appendTo` that were previously only available from the `
RenderResult` returned from component renders.

NOTE: We will implement `out.toString()` and `out.<span class="apidocCodeKeywordSpan">toJSON</span>()` so in many cases the `out
` can be used as a string.

### Remove support for deprecated `empty`/`notEmpty` helpers ([#357](https://github.com/marko-js/marko/issues/357))

&gt; Already deprecated in v3

The `empty`/`notEmpty` helpers were automatically being added to every compiled
template. While they can be helpful, we feel it is better if the developer
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.State_legacy" id="apidoc.module.marko.State_legacy">module marko.State_legacy</a></h1>


    <h2>
        <a href="#apidoc.element.marko.State_legacy.State_legacy" id="apidoc.element.marko.State_legacy.State_legacy">
        function <span class="apidocSignatureSpan">marko.</span>State_legacy
        <span class="apidocSignatureSpan">(component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function State(component) {
    this.$__component = component;
    this.$__raw = {};

    this.$__dirty = false;
    this.$__old = null;
    this.$__changes = null;
    this.$__forced = null; // An object that we use to keep tracking of state properties that were forced to be dirty
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.State_legacy.prototype" id="apidoc.module.marko.State_legacy.prototype">module marko.State_legacy.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.State_legacy.prototype.toJSON" id="apidoc.element.marko.State_legacy.prototype.toJSON">
        function <span class="apidocSignatureSpan">marko.State_legacy.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
    return this.$__raw;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
component.render(data); // returns `out`
component.render(data, (err, out) =&gt; {});
component.renderSync(data); // returns `out`
```

Also, `out` has been updated to implement DOM manipulation methods like `appendTo` that were previously only available from the `
RenderResult` returned from component renders.

NOTE: We will implement `out.toString()` and `out.<span class="apidocCodeKeywordSpan">toJSON</span>()` so in many cases the `out
` can be used as a string.

### Remove support for deprecated `empty`/`notEmpty` helpers ([#357](https://github.com/marko-js/marko/issues/357))

&gt; Already deprecated in v3

The `empty`/`notEmpty` helpers were automatically being added to every compiled
template. While they can be helpful, we feel it is better if the developer
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.StringWriter" id="apidoc.module.marko.StringWriter">module marko.StringWriter</a></h1>


    <h2>
        <a href="#apidoc.element.marko.StringWriter.StringWriter" id="apidoc.element.marko.StringWriter.StringWriter">
        function <span class="apidocSignatureSpan">marko.</span>StringWriter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StringWriter() {
    this.str = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.StringWriter.prototype" id="apidoc.module.marko.StringWriter.prototype">module marko.StringWriter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.StringWriter.prototype.toString" id="apidoc.element.marko.StringWriter.prototype.toString">
        function <span class="apidocSignatureSpan">marko.StringWriter.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return this.str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
component.render(data); // returns `out`
component.render(data, (err, out) =&gt; {});
component.renderSync(data); // returns `out`
```

Also, `out` has been updated to implement DOM manipulation methods like `appendTo` that were previously only available from the `
RenderResult` returned from component renders.

NOTE: We will implement `out.<span class="apidocCodeKeywordSpan">toString</span>()` and `out.toJSON()` so in many cases the `out
` can be used as a string.

### Remove support for deprecated `empty`/`notEmpty` helpers ([#357](https://github.com/marko-js/marko/issues/357))

&gt; Already deprecated in v3

The `empty`/`notEmpty` helpers were automatically being added to every compiled
template. While they can be helpful, we feel it is better if the developer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.StringWriter.prototype.write" id="apidoc.element.marko.StringWriter.prototype.write">
        function <span class="apidocSignatureSpan">marko.StringWriter.prototype.</span>write
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (str) {
    this.str += str;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    getCode() {
return this._code;
    }

    writeBlock(body) {
if (!body) {
    this.<span class="apidocCodeKeywordSpan">write</span>('{}');
    return;
}

if (typeof body === 'function') {
    body = body();
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.Template" id="apidoc.module.marko.Template">module marko.Template</a></h1>


    <h2>
        <a href="#apidoc.element.marko.Template.Template" id="apidoc.element.marko.Template.Template">
        function <span class="apidocSignatureSpan">marko.</span>Template
        <span class="apidocSignatureSpan">(path, renderFunc, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Template(path, renderFunc, options) {
    this.path = path;
    this._ = renderFunc;
    this.$__shouldBuffer = !options || options.shouldBuffer !== false;
    this.meta = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.Template.prototype" id="apidoc.module.marko.Template.prototype">module marko.Template.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.Template.prototype.createOut" id="apidoc.element.marko.Template.prototype.createOut">
        function <span class="apidocSignatureSpan">marko.Template.prototype.</span>createOut
        <span class="apidocSignatureSpan">(globalData, parent, state, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createOut(globalData, parent, state, buffer) {
    return new AsyncStream(globalData, parent, state, buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| `out` | `AsyncStream`/`AsyncVDOMBuilder` | The async `out` to render to |
| return value | `AsyncStream`/`AsyncVDOMBuilder` | The `out` that was passed |

The `render` method also allows passing an existing async `out`.  If you do this, `render` will not automatically end the async `
out` (this allows rendering a view in the middle of another view).  If the async `out` won't be ended by other means, you are
 responsible for ending it.

```js
var view = require('./view'); // Import `./view.marko`
var out = view.<span class="apidocCodeKeywordSpan">createOut</span>();

view.render({}, out);

out.on('finish', () =&gt; {
    console.log(out.getOutput());
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Template.prototype.getDependencies" id="apidoc.element.marko.Template.prototype.getDependencies">
        function <span class="apidocSignatureSpan">marko.Template.prototype.</span>getDependencies
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDependencies = function (context) {
    context = context || {};

    return getDeps(this, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Template.prototype.render" id="apidoc.element.marko.Template.prototype.render">
        function <span class="apidocSignatureSpan">marko.Template.prototype.</span>render
        <span class="apidocSignatureSpan">(data, out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (data, out) {
    var callback;
    var finalOut;
    var finalData;
    var globalData;
    var render = renderFunc || this._;
    var shouldBuffer = this.$__shouldBuffer;
    var shouldEnd = true;

    if (data) {
        finalData = data;
        if ((globalData = data.$global)) {
            finalData.$global = undefined;
        }
    } else {
        finalData = {};
    }

    if (out &amp;&amp; out.$__isOut) {
        finalOut = out;
        shouldEnd = false;
        extend(out.global, globalData);
    } else if (typeof out == 'function') {
        finalOut = createOut(globalData);
        callback = out;
    } else {
        finalOut = createOut(
            globalData, // global
            out, // writer(AsyncStream) or parentNode(AsyncVDOMBuilder)
            null, // state
            shouldBuffer // ignored by AsyncVDOMBuilder
        );
    }

    if (callback) {
        finalOut
            .on('finish', function() {
                callback(null, finalOut.$__getResult());
            })
            .once('error', callback);
    }

    globalData = finalOut.global;

    globalData.template = globalData.template || this;

    return safeRender(render, finalData, finalOut, shouldEnd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    //     {
    //         title: 'Messages',
    //         renderBody: function(out) { ... }
    //     }
    // ]
    console.log(tabs.length); // Output: 3

    template.<span class="apidocCodeKeywordSpan">render</span>({
        tabs: tabs
    }, out);

};
```

___ui-tabs/template.marko___
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Template.prototype.renderSync" id="apidoc.element.marko.Template.prototype.renderSync">
        function <span class="apidocSignatureSpan">marko.Template.prototype.</span>renderSync
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderSync = function (data) {
    var localData = data || {};
    var render = renderFunc || this._;
    var globalData = localData.$global;
    var out = createOut(globalData);
    out.sync();

    out.global.template = this;

    if (globalData) {
        localData.$global = undefined;
    }

    render(localData, out);
    return out.$__getResult();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
// Install the Node.js require extension in your application's main script (server-side only)
require('marko/node-require').install();

// Now you can require `*.marko` files just like any other JavaScript module
var template = require('./hello.marko');
var html = template.<span class="apidocCodeKeywordSpan">renderSync</span>({ name: 'Frank' });
```

- Compiled templates now export a loaded Template instance. In the previous version of marko, compiled templates exported a function
 that could be used to create a loaded Template instance.

## 2.4.x

### 2.4.3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Template.prototype.renderToString" id="apidoc.element.marko.Template.prototype.renderToString">
        function <span class="apidocSignatureSpan">marko.Template.prototype.</span>renderToString
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderToString = function (data, callback) {
    var localData = data || {};
    var render = renderFunc || this._;
    var globalData = localData.$global;
    var out = createOut(globalData);

    out.global.template = this;

    if (globalData) {
        localData.$global = undefined;
    }

    if (callback) {
        out.on('finish', function() {
               callback(null, out.toString(), out);
           })
           .once('error', callback);

        return safeRender(render, localData, out, true);
    } else {
        out.sync();
        render(localData, out);
        return out.toString();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&gt; **Note:** If you are targeting node.js, you will need to enable the [require extension](./installing.md#require-marko-views
) in order to require `.marko` files or you will need to precompile all of your templates using [Marko DevTools](https://github.
com/marko-js/marko-devtools).  If you are targeting the browser, you will need to use a bundler like [`lasso`](./lasso.md), [`webpack
`](./webpack.md), [`browserify`](./browserify.md) or [`rollup`](./rollup.md).

Once you have a view, you can pass input data and render it:

_example.js_
```js
var button = require('./components/fancy-button');
var html = button.<span class="apidocCodeKeywordSpan">renderToString</span>({ label:'Click me!' });

console.log(html);
```

The input data becomes available as `input` within a view, so if `fancy-button.marko` looked like this:

_./components/fancy-button.marko_
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.Template.prototype.stream" id="apidoc.element.marko.Template.prototype.stream">
        function <span class="apidocSignatureSpan">marko.Template.prototype.</span>stream
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stream = function (data) {
    return new Readable(this, data, this._options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### 3.11.8

- Fixes [#382](https://github.com/marko-js/marko/issues/382) - Local variable for tag should have prefix or suffix to avoid conflict

### 3.11.7

- Fixes [#381](https://github.com/marko-js/marko/issues/381) - `$global` broken when using `template.<span class="apidocCodeKeywordSpan
">stream</span>()`

### 3.11.6

- Internal change: `AsyncWriter`  `AsyncStream`

### 3.11.5
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.VComment" id="apidoc.module.marko.VComment">module marko.VComment</a></h1>


    <h2>
        <a href="#apidoc.element.marko.VComment.VComment" id="apidoc.element.marko.VComment.VComment">
        function <span class="apidocSignatureSpan">marko.</span>VComment
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VComment(value) {
    this.$__VNode(-1 /* no children */);
    this.nodeValue = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.VComment.prototype" id="apidoc.module.marko.VComment.prototype">module marko.VComment.prototype</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.VDocumentFragment" id="apidoc.module.marko.VDocumentFragment">module marko.VDocumentFragment</a></h1>


    <h2>
        <a href="#apidoc.element.marko.VDocumentFragment.VDocumentFragment" id="apidoc.element.marko.VDocumentFragment.VDocumentFragment">
        function <span class="apidocSignatureSpan">marko.</span>VDocumentFragment
        <span class="apidocSignatureSpan">(documentFragment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VDocumentFragment(documentFragment) {
    this.$__VNode(null /* childCount */);
    this.namespaceURI = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.VDocumentFragment.prototype" id="apidoc.module.marko.VDocumentFragment.prototype">module marko.VDocumentFragment.prototype</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.VElement" id="apidoc.module.marko.VElement">module marko.VElement</a></h1>


    <h2>
        <a href="#apidoc.element.marko.VElement.VElement" id="apidoc.element.marko.VElement.VElement">
        function <span class="apidocSignatureSpan">marko.</span>VElement
        <span class="apidocSignatureSpan">(tagName, attrs, childCount, flags, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VElement(tagName, attrs, childCount, flags, props) {
    this.$__VNode(childCount);

    var constId;

    if (props) {
        constId = props.c;
    }

    var namespaceURI;

    if ((this.$__flags = flags || 0)) {
        if (flags &amp; FLAG_IS_SVG) {
            namespaceURI = 'http://www.w3.org/2000/svg';
        }
    }

    this.$__attributes = attrs || EMPTY_OBJECT;
    this.$__properties = props || EMPTY_OBJECT;
    this.$__namespaceURI = namespaceURI;
    this.$__nodeName = tagName;
    this.$__value = null;
    this.$__constId = constId;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.VElement.prototype" id="apidoc.module.marko.VElement.prototype">module marko.VElement.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.VElement.prototype.e" id="apidoc.element.marko.VElement.prototype.e">
        function <span class="apidocSignatureSpan">marko.VElement.prototype.</span>e
        <span class="apidocSignatureSpan">(tagName, attrs, childCount, flags, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">e = function (tagName, attrs, childCount, flags, props) {
    var child = this.$__appendChild(new VElement(tagName, attrs, childCount, flags, props));

    if (childCount === 0) {
        return this.$__finishChild();
    } else {
        return child;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function render(data, out) {
var colors = data.colors;

if (colors &amp;&amp; colors.length) {
  out.be("ul");

  marko_forEach(colors, function(color) {
    out.<span class="apidocCodeKeywordSpan">e</span>("li", marko_attrs0, 1)
      .t(marko_str(color));
  });

  out.ee();
} else {
  out.n(marko_node0);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.VElement.prototype.n" id="apidoc.element.marko.VElement.prototype.n">
        function <span class="apidocSignatureSpan">marko.VElement.prototype.</span>n
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">n = function (node) {
    this.$__appendChild(node.$__cloneNode());
    return this.$__finishChild();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    marko_forEach(colors, function(color) {
      out.e("li", marko_attrs0, 1)
        .t(marko_str(color));
    });

    out.ee();
  } else {
    out.<span class="apidocCodeKeywordSpan">n</span>(marko_node0);
  }
}
```

The VDOM output allows optimizations that were previously not possible:

- Static subtrees are pulled into variables that are only initialized once and reused for every render
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.VNode" id="apidoc.module.marko.VNode">module marko.VNode</a></h1>


    <h2>
        <a href="#apidoc.element.marko.VNode.VNode" id="apidoc.element.marko.VNode.VNode">
        function <span class="apidocSignatureSpan">marko.</span>VNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VNode() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.VNode.prototype" id="apidoc.module.marko.VNode.prototype">module marko.VNode.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.marko.VNode.prototype.actualize" id="apidoc.element.marko.VNode.prototype.actualize">
        function <span class="apidocSignatureSpan">marko.VNode.prototype.</span>actualize
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">actualize = function (doc) {
    var actualNode = this.$__actualize(doc);

    var curChild = this.firstChild;

    while(curChild) {
        actualNode.appendChild(curChild.actualize(doc));
        curChild = curChild.nextSibling;
    }

    if (this.$__nodeType === 1) {
        var elHandler = specialElHandlers[this.$__nodeName];
        if (elHandler !== undefined) {
            elHandler(actualNode, this);
        }
    }

    return actualNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

$__getNode: function(doc) {
    var node = this.$__vnode;
    if (!node) {
        var vdomTree = this.$__getOutput();

        node = this.$__vnode = vdomTree.<span class="apidocCodeKeywordSpan">actualize</span>(doc || this.$__document);
    }
    return node;
},

toString: function() {
    return this.$__getNode().outerHTML;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.VNode.prototype.c" id="apidoc.element.marko.VNode.prototype.c">
        function <span class="apidocSignatureSpan">marko.VNode.prototype.</span>c
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">c = function (value) {
    this.$__appendChild(new VComment(value));
    return this.$__finishChild();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.VNode.prototype.t" id="apidoc.element.marko.VNode.prototype.t">
        function <span class="apidocSignatureSpan">marko.VNode.prototype.</span>t
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">t = function (value) {
    var type = typeof value;
    var vdomNode;

    if (type !== 'string') {
        if (value == null) {
            value = '';
        } else if (type === 'object') {
            if (value.toHTML) {
                vdomNode = virtualizeHTML(value.toHTML(), document);
            }
        }
    }

    this.$__appendChild(vdomNode || new VText(value.toString()));
    return this.$__finishChild();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_Compiled for VDOM output (browser-side):_

```javascript
var marko_attrs0 = {
      "class": "color"
    },
  marko_node0 = marko_createElement("div", null, 1, marko_const_nextId())
    .<span class="apidocCodeKeywordSpan">t</span>("No colors!");

function render(data, out) {
var colors = data.colors;

if (colors &amp;&amp; colors.length) {
  out.be("ul");
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.VText" id="apidoc.module.marko.VText">module marko.VText</a></h1>


    <h2>
        <a href="#apidoc.element.marko.VText.VText" id="apidoc.element.marko.VText.VText">
        function <span class="apidocSignatureSpan">marko.</span>VText
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VText(value) {
    this.$__VNode(-1 /* no children */);
    this.nodeValue = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.VText.prototype" id="apidoc.module.marko.VText.prototype">module marko.VText.prototype</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.cache" id="apidoc.module.marko.cache">module marko.cache</a></h1>


    <h2>
        <a href="#apidoc.element.marko.cache.clear" id="apidoc.element.marko.cache.clear">
        function <span class="apidocSignatureSpan">marko.cache.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clear() {
    cache = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function loadTaglibFromFile(filePath) {
    return loaders.loadTaglibFromFile(filePath);
}

function clearCache() {
    cache.<span class="apidocCodeKeywordSpan">clear</span>();
}

function createTaglib(filePath) {
    return new types.Taglib(filePath);
}

function loadTag(tagProps, filePath) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.cache.get" id="apidoc.element.marko.cache.get">
        function <span class="apidocSignatureSpan">marko.cache.</span>get
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(key) {
    return cache[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var markoExpress = require('marko/express');
var template = require('./template');

var app = express();

app.use(markoExpress()); //enable res.marko(template, data)

app.<span class="apidocCodeKeywordSpan">get</span>('/', function(req, res) {
    res.marko(template, {
        name: 'Frank',
        count: 30,
        colors: ['red', 'green', 'blue']
    });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.cache.put" id="apidoc.element.marko.cache.put">
        function <span class="apidocSignatureSpan">marko.cache.</span>put
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function put(key, value) {
    cache[key] = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var tag = cache.get(filePath);

// Only load a tag once by caching the loaded tags using the file
// system file path as the key
if (!tag) {
    tag = new types.Tag(filePath);
    cache.<span class="apidocCodeKeywordSpan">put</span>(filePath, tag);

    var tagProps = jsonFileReader.readFileSync(filePath);
    loaders.loadTagFromProps(tag, tagProps);

}

return tag;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.cached_fragment_tag" id="apidoc.module.marko.cached_fragment_tag">module marko.cached_fragment_tag</a></h1>


    <h2>
        <a href="#apidoc.element.marko.cached_fragment_tag.render" id="apidoc.element.marko.cached_fragment_tag.render">
        function <span class="apidocSignatureSpan">marko.cached_fragment_tag.</span>render
        <span class="apidocSignatureSpan">(input, out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (input, out) {
    var cacheKey = input.cacheKey;
    if (!cacheKey) {
        throw new Error('cache-key is required for &lt;cached-fragment&gt;');
    }

    var cacheManager = input.cacheManager;

    var cache = cacheManager.getCache(input.cacheName || 'marko/cached-fragment');

    var asyncOut = out.beginAsync();

    cache.get(cacheKey,
        {
            builder: function(callback) {
                var nestedOut = out.createOut();

                if (input.renderBody) {
                    input.renderBody(nestedOut);
                }

                nestedOut
                    .on('error', callback)
                    .on('finish', function(result) {
                        callback(null, result.getOutput());
                    });

                nestedOut.end();
            }
        }, function(err, result) {
            if (err) {
                return asyncOut.error(err);
            }

            if (result.$__cloneNode) {
                var curChild = result.firstChild;
                while(curChild) {
                    asyncOut.node(curChild.$__cloneNode());
                    curChild = curChild.nextSibling;
                }
                asyncOut.end();
            } else {
                asyncOut.end(result);
            }


        });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    //     {
    //         title: 'Messages',
    //         renderBody: function(out) { ... }
    //     }
    // ]
    console.log(tabs.length); // Output: 3

    template.<span class="apidocCodeKeywordSpan">render</span>({
        tabs: tabs
    }, out);

};
```

___ui-tabs/template.marko___
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.client_reorder" id="apidoc.module.marko.client_reorder">module marko.client_reorder</a></h1>




    <h2>
        <a href="#apidoc.element.marko.client_reorder.getCode" id="apidoc.element.marko.client_reorder.getCode">
        function <span class="apidocSignatureSpan">marko.client_reorder.</span>getCode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCode = function () {
    if (!code) {
        code = fs.readFileSync(require.resolve('./client-reorder-runtime.min.js'), 'utf8');
        code = '&lt;script type="text/javascript"&gt;' + code + '&lt;/script&gt;';
    }
    return code;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // console.log(module.id, 'FINAL AST:' + JSON.stringify(finalAST, null, 4));
    var codeWriter = new CodeWriter(this.context.options, this.context.builder);
    codeWriter.write(this.ast);

    handleErrors(this.context);

    // Return the generated code as the compiled output:
    var compiledSrc = codeWriter.<span class="apidocCodeKeywordSpan">getCode</span>();
    return compiledSrc;
}
}

class Compiler {
constructor(options, userOptions, inline) {
    ok(options, '"options" is required');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.componentArgs" id="apidoc.module.marko.componentArgs">module marko.componentArgs</a></h1>


    <h2>
        <a href="#apidoc.element.marko.componentArgs.componentArgs" id="apidoc.element.marko.componentArgs.componentArgs">
        function <span class="apidocSignatureSpan">marko.</span>componentArgs
        <span class="apidocSignatureSpan">( out, componentArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function componentArgsHelper( out, componentArgs) {

    out.data.$w = componentArgs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.componentArgs.cleanup" id="apidoc.element.marko.componentArgs.cleanup">
        function <span class="apidocSignatureSpan">marko.componentArgs.</span>cleanup
        <span class="apidocSignatureSpan">(out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanup = function (out) {
    delete out.data.$w;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.createOut" id="apidoc.module.marko.createOut">module marko.createOut</a></h1>


    <h2>
        <a href="#apidoc.element.marko.createOut.createOut" id="apidoc.element.marko.createOut.createOut">
        function <span class="apidocSignatureSpan">marko.</span>createOut
        <span class="apidocSignatureSpan">(globalData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createOut(globalData) {
    return actualCreateOut(globalData);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| `out` | `AsyncStream`/`AsyncVDOMBuilder` | The async `out` to render to |
| return value | `AsyncStream`/`AsyncVDOMBuilder` | The `out` that was passed |

The `render` method also allows passing an existing async `out`.  If you do this, `render` will not automatically end the async `
out` (this allows rendering a view in the middle of another view).  If the async `out` won't be ended by other means, you are
 responsible for ending it.

```js
var view = require('./view'); // Import `./view.marko`
var out = view.<span class="apidocCodeKeywordSpan">createOut</span>();

view.render({}, out);

out.on('finish', () =&gt; {
    console.log(out.getOutput());
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.default_cache_manager" id="apidoc.module.marko.default_cache_manager">module marko.default_cache_manager</a></h1>


    <h2>
        <a href="#apidoc.element.marko.default_cache_manager.getCache" id="apidoc.element.marko.default_cache_manager.getCache">
        function <span class="apidocSignatureSpan">marko.default_cache_manager.</span>getCache
        <span class="apidocSignatureSpan">(cacheName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCache = function (cacheName) {
    return caches[cacheName] || (caches[cacheName] = createCache());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.escape" id="apidoc.module.marko.escape">module marko.escape</a></h1>


    <h2>
        <a href="#apidoc.element.marko.escape.escapeString" id="apidoc.element.marko.escape.escapeString">
        function <span class="apidocSignatureSpan">marko.escape.</span>escapeString
        <span class="apidocSignatureSpan">(str, regexpTest, regexpReplace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeString(str, regexpTest, regexpReplace) {
    return regexpTest.test(str) ? str.replace(regexpReplace, replaceChar) : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.escape.escapeXml" id="apidoc.element.marko.escape.escapeXml">
        function <span class="apidocSignatureSpan">marko.escape.</span>escapeXml
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeXml(value) {
    return escapeXmlHelper(value, elTest, elTestReplace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.escape.escapeXmlAttr" id="apidoc.element.marko.escape.escapeXmlAttr">
        function <span class="apidocSignatureSpan">marko.escape.</span>escapeXmlAttr
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeXmlAttr(value) {
    return escapeXmlHelper(value, attrTest, attrReplace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.event_delegation" id="apidoc.module.marko.event_delegation">module marko.event_delegation</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.helpers" id="apidoc.module.marko.helpers">module marko.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.marko.helpers.cl" id="apidoc.element.marko.helpers.cl">
        function <span class="apidocSignatureSpan">marko.helpers.</span>cl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function classListHelper() {
    var classNames = [];
    classList(arguments, classNames);
    return classNames.join(' ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helpers.f" id="apidoc.element.marko.helpers.f">
        function <span class="apidocSignatureSpan">marko.helpers.</span>f
        <span class="apidocSignatureSpan">(array, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachHelper(array, callback) {
    if (isArray(array)) {
        for (var i=0; i&lt;array.length; i++) {
            callback(array[i]);
        }
    } else if (isFunction(array)) {
        // Also allow the first argument to be a custom iterator function
        array(callback);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helpers.s" id="apidoc.element.marko.helpers.s">
        function <span class="apidocSignatureSpan">marko.helpers.</span>s
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function strHelper(str) {
    return (str == null) ? '' : str.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.helpers.t" id="apidoc.element.marko.helpers.t">
        function <span class="apidocSignatureSpan">marko.helpers.</span>t
        <span class="apidocSignatureSpan">(renderer, targetProperty, isRepeated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadTagHelper(renderer, targetProperty, isRepeated) {
    if (renderer) {
        renderer = resolveRenderer(renderer);
    }

    return renderer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_Compiled for VDOM output (browser-side):_

```javascript
var marko_attrs0 = {
      "class": "color"
    },
  marko_node0 = marko_createElement("div", null, 1, marko_const_nextId())
    .<span class="apidocCodeKeywordSpan">t</span>("No colors!");

function render(data, out) {
var colors = data.colors;

if (colors &amp;&amp; colors.length) {
  out.be("ul");
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.html" id="apidoc.module.marko.html">module marko.html</a></h1>


    <h2>
        <a href="#apidoc.element.marko.html.AsyncStream" id="apidoc.element.marko.html.AsyncStream">
        function <span class="apidocSignatureSpan">marko.html.</span>AsyncStream
        <span class="apidocSignatureSpan">(global, writer, state, shouldBuffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncStream(global, writer, state, shouldBuffer) {
    var finalGlobal = this.attributes = global || {};
    var originalStream;

    if (state) {
        originalStream = state.stream;
    } else {
        var events = finalGlobal.events /* deprecated */ = writer &amp;&amp; writer.on ? writer : new EventEmitter();

        if (writer) {
            originalStream = writer;
            if (shouldBuffer) {
                writer = new BufferedWriter(writer);
            }
        } else {
            writer = originalStream = new StringWriter();
        }

        state = new State(this, originalStream, writer, events);
    }

    this.global = finalGlobal;
    this.stream = originalStream;
    this._state = state;

    this.data = {};
    this.writer = writer;
    writer.stream = this;

    this._sync = false;
    this._stack = undefined;
    this.name = undefined;
    this._timeoutId = undefined;

    this._node = undefined;

    this._elStack = undefined; // Array

    this.$c = null; // Component args
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.html.Template" id="apidoc.element.marko.html.Template">
        function <span class="apidocSignatureSpan">marko.html.</span>Template
        <span class="apidocSignatureSpan">(path, renderFunc, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Template(path, renderFunc, options) {
    this.path = path;
    this._ = renderFunc;
    this.$__shouldBuffer = !options || options.shouldBuffer !== false;
    this.meta = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.html.createWriter" id="apidoc.element.marko.html.createWriter">
        function <span class="apidocSignatureSpan">marko.html.</span>createWriter
        <span class="apidocSignatureSpan">(writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createWriter = function (writer) {
    return new AsyncStream(null, writer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.html.enableAsyncStackTrace" id="apidoc.element.marko.html.enableAsyncStackTrace">
        function <span class="apidocSignatureSpan">marko.html.</span>enableAsyncStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableAsyncStackTrace = function () {
    AsyncStream.INCLUDE_STACK = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.html.t" id="apidoc.element.marko.html.t">
        function <span class="apidocSignatureSpan">marko.html.</span>t
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTemplate(path) {
     return new Template(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_Compiled for VDOM output (browser-side):_

```javascript
var marko_attrs0 = {
      "class": "color"
    },
  marko_node0 = marko_createElement("div", null, 1, marko_const_nextId())
    .<span class="apidocCodeKeywordSpan">t</span>("No colors!");

function render(data, out) {
var colors = data.colors;

if (colors &amp;&amp; colors.length) {
  out.be("ul");
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.html_elements" id="apidoc.module.marko.html_elements">module marko.html_elements</a></h1>


    <h2>
        <a href="#apidoc.element.marko.html_elements.isRegisteredElement" id="apidoc.element.marko.html_elements.isRegisteredElement">
        function <span class="apidocSignatureSpan">marko.html_elements.</span>isRegisteredElement
        <span class="apidocSignatureSpan">(tagName, dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRegisteredElement(tagName, dir) {
    var packageRootDir = getPackageRootDir(dir);

    var currentDir = dir;

    while (true) {
        var filePath = path.join(currentDir, 'html-elements.json');
        if (lassoCachingFS.existsSync(filePath)) {
            var tags = cache[filePath];
            if (!tags) {
                tags = cache[filePath] = loadTags(filePath);
            }

            if (tags[tagName]) {
                return true;
            }
        }


        var parentDir = path.dirname(currentDir);
        if (!parentDir || parentDir === currentDir || parentDir === packageRootDir) {
            break;
        }
        currentDir = parentDir;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            node.body = node.makeContainer(node.body.items);
        } else {
            if (typeof tagName === 'string') {
                tagDef = taglibLookup.getTag(tagName);
                if (!tagDef &amp;&amp;
    !this.isMacro(tagName) &amp;&amp;
    tagName.indexOf(':') === -1 &amp;&amp;
    !htmlElements.<span class="apidocCodeKeywordSpan">isRegisteredElement</span>(tagName, this.dirname)) {

if (this._parsingFinished) {
    this.addErrorUnrecognizedTag(tagName, elNode);
} else {
    // We don't throw an error right away since the tag
    // may be a macro that gets registered later
    this.unrecognizedTags.push({
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.index" id="apidoc.module.marko.index">module marko.index</a></h1>


    <h2>
        <a href="#apidoc.element.marko.index.enable" id="apidoc.element.marko.index.enable">
        function <span class="apidocSignatureSpan">marko.index.</span>enable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enable = function () {
    if (!browserRefreshClient.isBrowserRefreshEnabled()) {
        return;
    }

    if (enabled) {
        return;
    }

    enabled = true;

    // We set an environment variable so that _all_ marko modules
    // installed in the project will have browser refresh enabled.
    process.env.MARKO_BROWSER_REFRESH = 'true';

    var hotReload = require('../hot-reload');
    hotReload.enable();

    browserRefreshClient
        .enableSpecialReload('*.marko marko.json marko-tag.json')
        .onFileModified(function(path) {
            hotReload.handleFileModified(path);
        });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    enabled = true;

    // We set an environment variable so that _all_ marko modules
    // installed in the project will have browser refresh enabled.
    process.env.MARKO_BROWSER_REFRESH = 'true';

    var hotReload = require('../hot-reload');
    hotReload.<span class="apidocCodeKeywordSpan">enable</span>();

    browserRefreshClient
        .enableSpecialReload('*.marko marko.json marko-tag.json')
        .onFileModified(function(path) {
            hotReload.handleFileModified(path);
        });
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.jquery" id="apidoc.module.marko.jquery">module marko.jquery</a></h1>


    <h2>
        <a href="#apidoc.element.marko.jquery.patchComponent" id="apidoc.element.marko.jquery.patchComponent">
        function <span class="apidocSignatureSpan">marko.jquery.</span>patchComponent
        <span class="apidocSignatureSpan">(jQuery)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patchComponent = function (jQuery) {
<span class="apidocCodeCommentSpan">    /* globals window */
</span>
    if (!jQuery) {
        jQuery = window.$;
        if (!jQuery) {
            throw new Error('jQuery not found');
        }
    }

    require('./components/Component').prototype.$ = function jqueryProxy(arg) {
        var args = arguments;
        var self = this;

        if (args.length === 1) {
            //Handle an "ondomready" callback function
            if (typeof arg === 'function') {
                return ready(function() {
                    arg.call(self);
                });
            } else if (typeof arg === 'string') {
                var match = idRegExp.exec(arg);
                //Reset the search to 0 so the next call to exec will start from the beginning for the new string
                if (match != null) {
                    var componentElId = match[1];
                    if (match[2] == null) {
                        return jQuery(self.getEl(componentElId));
                    } else {
                        return jQuery('#' + self.getElId(componentElId) + match[2]);
                    }
                } else {
                    var rootEl = self.getEl();
                    if (!rootEl) {
                        throw new Error('Root element is not defined for component');
                    }
                    if (rootEl) {
                        return jQuery(arg, rootEl);
                    }
                }
            }
        } else if (args.length === 2 &amp;&amp; typeof args[1] === 'string') {
            return jQuery(arg, self.getEl(args[1]));
        } else if (args.length === 0) {
            return jQuery(self.el);
        }
        return jQuery.apply(window, arguments);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return Component;
};

BaseState = require('./State-legacy');
BaseComponent = require('../Component');
inherit = require('raptor-util/inherit');

require('../../jquery').<span class="apidocCodeKeywordSpan">patchComponent</span>();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.json_file_reader" id="apidoc.module.marko.json_file_reader">module marko.json_file_reader</a></h1>


    <h2>
        <a href="#apidoc.element.marko.json_file_reader.readFileSync" id="apidoc.element.marko.json_file_reader.readFileSync">
        function <span class="apidocSignatureSpan">marko.json_file_reader.</span>readFileSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFileSync = function (path) {
    var json = fs.readFileSync(path, fsReadOptions);

    try {
        var taglibProps = JSON.parse(stripJsonComments(json));
        return taglibProps;
    } catch(e) {
        throw new Error('Unable to parse JSON file at path "' + path + '". Error: ' + e);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var templateSrc;
    var compiledSrc;

    if (writeToDisk === false) {
// Don't write the compiled template to disk. Instead, load it
// directly from the compiled source using the internals of the
// Node.js module loading system.
templateSrc = fs.<span class="apidocCodeKeywordSpan">readFileSync</span>(templatePath, fsReadOptions);
compiledSrc = markoCompiler.compile(templateSrc, templatePath);
    } else {
var targetFile = templatePath + '.js';

if (markoCompiler.defaultOptions.assumeUpToDate &amp;&amp; fs.existsSync(targetFile)) {
    // If the target file already exists and "assumeUpToDate" then just use the previously
    // compiled template.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.loadAttributeFromProps" id="apidoc.module.marko.loadAttributeFromProps">module marko.loadAttributeFromProps</a></h1>


    <h2>
        <a href="#apidoc.element.marko.loadAttributeFromProps.loadAttributeFromProps" id="apidoc.element.marko.loadAttributeFromProps.loadAttributeFromProps">
        function <span class="apidocSignatureSpan">marko.</span>loadAttributeFromProps
        <span class="apidocSignatureSpan">(attrName, attrProps, dependencyChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadAttributeFromProps(attrName, attrProps, dependencyChain) {
    assert.ok(typeof attrName === 'string');
    assert.ok(dependencyChain, '"dependencyChain" is required');

    var attr = new types.Attribute(attrName);

    var attrLoader = new AttrLoader(attr, dependencyChain);

    try {
        attrLoader.load(attrProps);
    } catch(err) {
        throw createError('Unable to load attribute "' + attrName + '" (' + dependencyChain + '): ' + err, err);
    }

    return attr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var loaders = require('./loaders');

module.exports = function loadAttributes(value, parent, dependencyChain) {
    ok(parent);
    ok(dependencyChain);

    forEachEntry(value, (attrName, attrProps) =&gt; {
        var attr = loaders.<span class="apidocCodeKeywordSpan">loadAttributeFromProps</span>(
            attrName,
            attrProps,
            dependencyChain.append('@' + attrName));

        parent.addAttribute(attr);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loadAttributeFromProps.isSupportedProperty" id="apidoc.element.marko.loadAttributeFromProps.isSupportedProperty">
        function <span class="apidocSignatureSpan">marko.loadAttributeFromProps.</span>isSupportedProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSupportedProperty = function (name) {
    return AttrLoader.prototype.hasOwnProperty(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...




var types = require('./types');

function isSupportedAttributeProperty(propertyName) {
    return exports.loadAttributeFromProps.<span class="apidocCodeKeywordSpan">isSupportedProperty</span>(propertyName);
}

function isSupportedTagProperty(propertyName) {
    return exports.loadTagFromProps.isSupportedProperty(propertyName);
}

function createTaglib(taglibPath) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.loadTagFromProps" id="apidoc.module.marko.loadTagFromProps">module marko.loadTagFromProps</a></h1>


    <h2>
        <a href="#apidoc.element.marko.loadTagFromProps.loadTagFromProps" id="apidoc.element.marko.loadTagFromProps.loadTagFromProps">
        function <span class="apidocSignatureSpan">marko.</span>loadTagFromProps
        <span class="apidocSignatureSpan">(tag, tagProps, dependencyChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadTagFromProps(tag, tagProps, dependencyChain) {
    ok(typeof tagProps === 'object', 'Invalid "tagProps"');
    ok(dependencyChain, '"dependencyChain" is required');

    var tagLoader = new TagLoader(tag, dependencyChain);

    try {
        tagLoader.load(tagProps);
    } catch(err) {
        throw createError('Unable to load tag (' + dependencyChain + '): ' + err, err);
    }

    return tag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function createTaglib(filePath) {
    return new types.Taglib(filePath);
}

function loadTag(tagProps, filePath) {
    var tag = new types.Tag(filePath);
    loaders.<span class="apidocCodeKeywordSpan">loadTagFromProps</span>(tag, tagProps, new DependencyChain(filePath ? [filePath] : []));
    return tag;
}

exports.clearCache = clearCache;
exports.createTaglib = createTaglib;
exports.loadTaglibFromProps = loadTaglibFromProps;
exports.loadTaglibFromFile = loadTaglibFromFile;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loadTagFromProps.isSupportedProperty" id="apidoc.element.marko.loadTagFromProps.isSupportedProperty">
        function <span class="apidocSignatureSpan">marko.loadTagFromProps.</span>isSupportedProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSupportedProperty(name) {
    return TagLoader.prototype.hasOwnProperty(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...




var types = require('./types');

function isSupportedAttributeProperty(propertyName) {
    return exports.loadAttributeFromProps.<span class="apidocCodeKeywordSpan">isSupportedProperty</span>(propertyName);
}

function isSupportedTagProperty(propertyName) {
    return exports.loadTagFromProps.isSupportedProperty(propertyName);
}

function createTaglib(taglibPath) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.loaders" id="apidoc.module.marko.loaders">module marko.loaders</a></h1>


    <h2>
        <a href="#apidoc.element.marko.loaders.createTaglib" id="apidoc.element.marko.loaders.createTaglib">
        function <span class="apidocSignatureSpan">marko.loaders.</span>createTaglib
        <span class="apidocSignatureSpan">(taglibPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTaglib(taglibPath) {
    return new types.Taglib(taglibPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function buildTaglibLookup(dirname) {
    return taglibLookup.buildLookup(dirname);
}

exports.buildTaglibLookup = buildTaglibLookup;

function registerTaglib(taglibProps, taglibPath) {
    var taglib = taglibLoader.<span class="apidocCodeKeywordSpan">createTaglib</span>(taglibPath);
    taglibLoader.loadTaglibFromProps(taglib, taglibProps);
    taglibLookup.registerTaglib(taglib);
}

registerTaglib(require('../taglibs/core/marko.json'), require.resolve('../taglibs/core/marko.json'));
registerTaglib(require('../taglibs/layout/marko.json'), require.resolve('../taglibs/layout/marko.json'));
registerTaglib(require('../taglibs/html/marko.json'), require.resolve('../taglibs/html/marko.json'));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loaders.isSupportedAttributeProperty" id="apidoc.element.marko.loaders.isSupportedAttributeProperty">
        function <span class="apidocSignatureSpan">marko.loaders.</span>isSupportedAttributeProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSupportedAttributeProperty(propertyName) {
    return exports.loadAttributeFromProps.isSupportedProperty(propertyName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The property is not a shorthand attribute or shorthand
// tag so move it over to either the tag definition
// or the attribute definition or both the tag definition
// and attribute definition.
var propNameDashes = removeDashes(k);

if (isSupportedProperty(propNameDashes) &amp;&amp;
    loaders.<span class="apidocCodeKeywordSpan">isSupportedAttributeProperty</span>(propNameDashes)) {
    // Move over all of the properties that are associated with a tag
    // and attribute
    tagProps[k] = value[k];
    attrProps[k] = value[k];
    delete value[k];
} else if (isSupportedProperty(propNameDashes)) {
    // Move over all of the properties that are associated with a tag
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loaders.isSupportedTagProperty" id="apidoc.element.marko.loaders.isSupportedTagProperty">
        function <span class="apidocSignatureSpan">marko.loaders.</span>isSupportedTagProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSupportedTagProperty(propertyName) {
    return exports.loadTagFromProps.isSupportedProperty(propertyName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loaders.loadAttributeFromProps" id="apidoc.element.marko.loaders.loadAttributeFromProps">
        function <span class="apidocSignatureSpan">marko.loaders.</span>loadAttributeFromProps
        <span class="apidocSignatureSpan">(attrName, attrProps, dependencyChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadAttributeFromProps(attrName, attrProps, dependencyChain) {
    assert.ok(typeof attrName === 'string');
    assert.ok(dependencyChain, '"dependencyChain" is required');

    var attr = new types.Attribute(attrName);

    var attrLoader = new AttrLoader(attr, dependencyChain);

    try {
        attrLoader.load(attrProps);
    } catch(err) {
        throw createError('Unable to load attribute "' + attrName + '" (' + dependencyChain + '): ' + err, err);
    }

    return attr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var loaders = require('./loaders');

module.exports = function loadAttributes(value, parent, dependencyChain) {
    ok(parent);
    ok(dependencyChain);

    forEachEntry(value, (attrName, attrProps) =&gt; {
        var attr = loaders.<span class="apidocCodeKeywordSpan">loadAttributeFromProps</span>(
            attrName,
            attrProps,
            dependencyChain.append('@' + attrName));

        parent.addAttribute(attr);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loaders.loadAttributes" id="apidoc.element.marko.loaders.loadAttributes">
        function <span class="apidocSignatureSpan">marko.loaders.</span>loadAttributes
        <span class="apidocSignatureSpan">(value, parent, dependencyChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadAttributes(value, parent, dependencyChain) {
    ok(parent);
    ok(dependencyChain);

    forEachEntry(value, (attrName, attrProps) =&gt; {
        var attr = loaders.loadAttributeFromProps(
            attrName,
            attrProps,
            dependencyChain.append('@' + attrName));

        parent.addAttribute(attr);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         "bar": "expression"
 *     }
 * }
 */
attributes(value) {
    var tag = this.tag;

    loaders.<span class="apidocCodeKeywordSpan">loadAttributes</span>(value, tag, this.dependencyChain.append('attributes&amp;#
x27;));
}

/**
 * A custom tag can be mapped to module that is is used
 * to generate compile-time code for the custom tag. A
 * node type is created based on the methods and methods
 * exported by the code codegen module.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loaders.loadTagFromFile" id="apidoc.element.marko.loaders.loadTagFromFile">
        function <span class="apidocSignatureSpan">marko.loaders.</span>loadTagFromFile
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadTagFromFile(filePath) {
    ok(filePath, '"filePath" is required');

    var tag = cache.get(filePath);

    // Only load a tag once by caching the loaded tags using the file
    // system file path as the key
    if (!tag) {
        tag = new types.Tag(filePath);
        cache.put(filePath, tag);

        var tagProps = jsonFileReader.readFileSync(filePath);
        loaders.loadTagFromProps(tag, tagProps);

    }

    return tag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loaders.loadTagFromProps" id="apidoc.element.marko.loaders.loadTagFromProps">
        function <span class="apidocSignatureSpan">marko.loaders.</span>loadTagFromProps
        <span class="apidocSignatureSpan">(tag, tagProps, dependencyChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadTagFromProps(tag, tagProps, dependencyChain) {
    ok(typeof tagProps === 'object', 'Invalid "tagProps"');
    ok(dependencyChain, '"dependencyChain" is required');

    var tagLoader = new TagLoader(tag, dependencyChain);

    try {
        tagLoader.load(tagProps);
    } catch(err) {
        throw createError('Unable to load tag (' + dependencyChain + '): ' + err, err);
    }

    return tag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function createTaglib(filePath) {
    return new types.Taglib(filePath);
}

function loadTag(tagProps, filePath) {
    var tag = new types.Tag(filePath);
    loaders.<span class="apidocCodeKeywordSpan">loadTagFromProps</span>(tag, tagProps, new DependencyChain(filePath ? [filePath] : []));
    return tag;
}

exports.clearCache = clearCache;
exports.createTaglib = createTaglib;
exports.loadTaglibFromProps = loadTaglibFromProps;
exports.loadTaglibFromFile = loadTaglibFromFile;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loaders.loadTaglibFromFile" id="apidoc.element.marko.loaders.loadTaglibFromFile">
        function <span class="apidocSignatureSpan">marko.loaders.</span>loadTaglibFromFile
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadFromFile(filePath) {
    ok(filePath, '"filePath" is required');

    var taglib = cache.get(filePath);

    // Only load a taglib once by caching the loaded taglibs using the file
    // system file path as the key
    if (!taglib) {
        taglib = new types.Taglib(filePath);
        cache.put(filePath, taglib);

        var taglibProps = jsonFileReader.readFileSync(filePath);
        loaders.loadTaglibFromProps(taglib, taglibProps);
    }

    return taglib;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
registerTaglib(require('../taglibs/svg/marko.json'), require.resolve('../taglibs/svg/marko.json'));
registerTaglib(require('../taglibs/async/marko.json'), require.resolve('../taglibs/async/marko.json'));
registerTaglib(require('../taglibs/cache/marko.json'), require.resolve('../taglibs/cache/marko.json'));
registerTaglib(require('../components/taglib/marko.json'), require.resolve('../components/taglib/marko.json'));

exports.registerTaglib = function(filePath) {
    ok(typeof filePath === 'string', '"filePath" shouldbe a string');
    var taglib = taglibLoader.<span class="apidocCodeKeywordSpan">loadTaglibFromFile</span>(filePath);
    taglibLookup.registerTaglib(taglib);
    clearCaches();
};

exports.isVDOMSupported = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.loaders.loadTaglibFromProps" id="apidoc.element.marko.loaders.loadTaglibFromProps">
        function <span class="apidocSignatureSpan">marko.loaders.</span>loadTaglibFromProps
        <span class="apidocSignatureSpan">(taglib, taglibProps, dependencyChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadTaglibFromProps(taglib, taglibProps, dependencyChain) {
    ok(taglib, '"taglib" is required');
    ok(taglibProps, '"taglibProps" is required');
    ok(taglib.filePath, '"taglib.filePath" is required');

    if (!dependencyChain) {
        dependencyChain = new DependencyChain([taglib.filePath]);
    }

    var taglibLoader = new TaglibLoader(taglib, dependencyChain);

    try {
        taglibLoader.load(taglibProps);
    } catch(err) {
        throw createError('Unable to load taglib (' + dependencyChain + '): ' + err, err);
    }

    return taglib;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return taglibLookup.buildLookup(dirname);
}

exports.buildTaglibLookup = buildTaglibLookup;

function registerTaglib(taglibProps, taglibPath) {
    var taglib = taglibLoader.createTaglib(taglibPath);
    taglibLoader.<span class="apidocCodeKeywordSpan">loadTaglibFromProps</span>(taglib, taglibProps);
    taglibLookup.registerTaglib(taglib);
}

registerTaglib(require('../taglibs/core/marko.json'), require.resolve('../taglibs/core/marko.json'));
registerTaglib(require('../taglibs/layout/marko.json'), require.resolve('../taglibs/layout/marko.json'));
registerTaglib(require('../taglibs/html/marko.json'), require.resolve('../taglibs/html/marko.json'));
registerTaglib(require('../taglibs/svg/marko.json'), require.resolve('../taglibs/svg/marko.json'));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.macros" id="apidoc.module.marko.macros">module marko.macros</a></h1>


    <h2>
        <a href="#apidoc.element.marko.macros.createMacrosContext" id="apidoc.element.marko.macros.createMacrosContext">
        function <span class="apidocSignatureSpan">marko.macros.</span>createMacrosContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMacrosContext() {
    return new MacrosContext();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    return this._macros.getRegisteredMacro(name);
}

registerMacro(name, params) {
    if (!this._macros) {
        this._macros = macros.<span class="apidocCodeKeywordSpan">createMacrosContext</span>();
    }

    return this._macros.registerMacro(name, params);
}

importTemplate(relativePath, varName) {
    ok(typeof relativePath === 'string', '"path" should be a string');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.modules" id="apidoc.module.marko.modules">module marko.modules</a></h1>


    <h2>
        <a href="#apidoc.element.marko.modules.deresolve" id="apidoc.element.marko.modules.deresolve">
        function <span class="apidocSignatureSpan">marko.modules.</span>deresolve
        <span class="apidocSignatureSpan">(targetFilename, from)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deresolve = function (targetFilename, from) {
    return deresolve(targetFilename, from, deresolveOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

getErrors() {
    return this._errors;
}

getRequirePath(targetFilename) {
    return markoModules.<span class="apidocCodeKeywordSpan">deresolve</span>(targetFilename, this.dirname);
}

importModule(varName, path) {
    if (typeof path !== 'string') {
        throw new Error('"path" should be a string');
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.modules.require" id="apidoc.element.marko.modules.require">
        function <span class="apidocSignatureSpan">marko.modules.</span>require
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require = function (path) {
    return nativeRequire(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...




require('./runtime/env-init');

var assign = require('object-assign');
var express = module.parent.<span class="apidocCodeKeywordSpan">require</span>('express');
patchResponse(express.response);
delete require.cache[__filename];

module.exports = function markoAppMiddleware() {
var sacrificialApp = express();

sacrificialApp.once('mount', function onmount(parent) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.modules.resolve" id="apidoc.element.marko.modules.resolve">
        function <span class="apidocSignatureSpan">marko.modules.</span>resolve
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (path) {
    return nativeRequire.resolve(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
}
```

___ui-tabs/renderer.js___

```javascript
var template = require('marko').load(require.<span class="apidocCodeKeywordSpan">resolve</span>('./template.marko
'));

exports.renderer = function(input, out) {
var tabs = input.tabs;

// Tabs will be in the following form:
// [
//     {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.modules.resolveFrom" id="apidoc.element.marko.modules.resolveFrom">
        function <span class="apidocSignatureSpan">marko.modules.</span>resolveFrom
        <span class="apidocSignatureSpan">(from, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveFrom = function (from, target) {
    return resolveFrom(from, target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * 		 and use the tag directory as the "from".
 *
 * @param {String} value The renderer path
 */
renderer(value) {
    var tag = this.tag;
    var dirname = this.dirname;
    var path = markoModules.<span class="apidocCodeKeywordSpan">resolveFrom</span>(dirname, value);
    tag.renderer = path;
}

/**
 * A tag can use a renderer or a template to do the rendering. If
 * a template is provided then the value should be the path to the
 * template to use to render the custom tag.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.node_require" id="apidoc.module.marko.node_require">module marko.node_require</a></h1>


    <h2>
        <a href="#apidoc.element.marko.node_require.getExtensions" id="apidoc.element.marko.node_require.getExtensions">
        function <span class="apidocSignatureSpan">marko.node_require.</span>getExtensions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getExtensions = function () {
    return require.extensions[MARKO_EXTENSIONS];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    requireExtensions.push(options.extension);
}

if (options.extensions) {
    requireExtensions = requireExtensions.concat(options.extensions);
}

var nodeRequireExtensions = nodeRequire.<span class="apidocCodeKeywordSpan">getExtensions</span>();
if (nodeRequireExtensions) {
    requireExtensions = requireExtensions.concat(nodeRequireExtensions);
}

for (var i = 0; i &lt; requireExtensions.length; i++) {
    requireExtensions[i] = normalizeExtension(requireExtensions[i]);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.node_require.install" id="apidoc.element.marko.node_require.install">
        function <span class="apidocSignatureSpan">marko.node_require.</span>install
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function install(options) {
    options = options || {};

    var requireExtensions = options.require ? // options.require introduced for testing
        options.require.extensions :
        require.extensions;

    var compilerOptions = options.compilerOptions;

    if (compilerOptions) {
        require('./compiler').configure(compilerOptions);
    } else {
        compilerOptions = {};
    }

    var extensions = [];

    if (options.extension) {
        extensions.push(options.extension);
    }

    if (options.extensions) {
        extensions = extensions.concat(options.extensions);
    }

    if (extensions.length === 0) {
        extensions.push('.marko');
    }

    function markoRequireExtension(module, filename) {
        var targetFile = filename + '.js';
        var cachedTemplate = getLoadedTemplate(targetFile) || getLoadedTemplate(filename);
        if (cachedTemplate) {
            // The template has already been loaded so use the exports of the already loaded template
            module.exports = cachedTemplate;
            return;
        }

        // Resolve the appropriate compiler relative to the location of the
        // marko template file on disk using the "resolve-from" module.
        var dirname = path.dirname(filename);
        var markoCompilerModulePath = resolveFrom(dirname, 'marko/compiler');
        var markoCompiler = require(markoCompilerModulePath);

        // Now use the appropriate Marko compiler to compile the Marko template
        // file to JavaScript source code:
        var compiledSrc = compile(filename, markoCompiler, compilerOptions);

        // Append ".js" to the filename since that is where we write the compiled
        // source code that is being loaded. This allows stack traces to match up.
        module._compile(compiledSrc, targetFile);
    }

    requireExtensions[MARKO_EXTENSIONS] = requireExtensions[MARKO_EXTENSIONS] ||
        (requireExtensions[MARKO_EXTENSIONS] = []);

    extensions.forEach((extension) =&gt; {
        extension = normalizeExtension(extension);
        requireExtensions[extension] = markoRequireExtension;
        requireExtensions[MARKO_EXTENSIONS].push(extension);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Silently ignore errors when parsing tag definition code inlined in JavaScript

### 3.11.2

- Fixed [#318](https://github.com/marko-js/marko/issues/318) - Use compiler options passed to require hook to configure marko globally

```javascript
require('marko/node-require').<span class="apidocCodeKeywordSpan">install</span>({
    compilerOptions: {
        writeToDisk: false
    }
});
```

### 3.11.1
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.node_require_browser" id="apidoc.module.marko.node_require_browser">module marko.node_require_browser</a></h1>


    <h2>
        <a href="#apidoc.element.marko.node_require_browser.install" id="apidoc.element.marko.node_require_browser.install">
        function <span class="apidocSignatureSpan">marko.node_require_browser.</span>install
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Silently ignore errors when parsing tag definition code inlined in JavaScript

### 3.11.2

- Fixed [#318](https://github.com/marko-js/marko/issues/318) - Use compiler options passed to require hook to configure marko globally

```javascript
require('marko/node-require').<span class="apidocCodeKeywordSpan">install</span>({
    compilerOptions: {
        writeToDisk: false
    }
});
```

### 3.11.1
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.ready" id="apidoc.module.marko.ready">module marko.ready</a></h1>


    <h2>
        <a href="#apidoc.element.marko.ready.ready" id="apidoc.element.marko.ready.ready">
        function <span class="apidocSignatureSpan">marko.</span>ready
        <span class="apidocSignatureSpan">(callback, thisObj, doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ready(callback, thisObj, doc) {
    if (isReady) {
        return callback.call(thisObj);
    }

    listeners.push([callback, thisObj]);

    if (!readyBound) {
        readyBound = true;
        bindReady(doc || defaultDocument);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.ready.patchComponent" id="apidoc.element.marko.ready.patchComponent">
        function <span class="apidocSignatureSpan">marko.ready.</span>patchComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patchComponent = function () {
    require('./components/Component').prototype.ready = function (callback) {
        var document = this.el.ownerDocument;
        ready(callback, this, document);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return Component;
};

BaseState = require('./State-legacy');
BaseComponent = require('../Component');
inherit = require('raptor-util/inherit');

require('../../jquery').<span class="apidocCodeKeywordSpan">patchComponent</span>();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.registry" id="apidoc.module.marko.registry">module marko.registry</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.registry_browser" id="apidoc.module.marko.registry_browser">module marko.registry_browser</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.renderer" id="apidoc.module.marko.renderer">module marko.renderer</a></h1>


    <h2>
        <a href="#apidoc.element.marko.renderer.renderer" id="apidoc.element.marko.renderer.renderer">
        function <span class="apidocSignatureSpan">marko.</span>renderer
        <span class="apidocSignatureSpan">(templateRenderFunc, componentProps, renderingLogic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createRendererFunc(templateRenderFunc, componentProps, renderingLogic) {
    renderingLogic = renderingLogic || {};
    var onInput = renderingLogic.onInput;
    var typeName = componentProps.type;
    var roots = componentProps.roots;
    var assignedId = componentProps.id;
    var split = componentProps.split;

    return function renderer(input, out) {
        var outGlobal = out.global;

        if (out.isSync() === false) {
            if (!outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY]) {
                outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY] = true;
                out.on('beginAsync', handleBeginAsync);
            }
        }

        var component = outGlobal.$w;
        var isRerender = component !== undefined;
        var id = assignedId;
        var isExisting;
        var customEvents;
        var scope;

        if (component) {
            id = component.id;
            isExisting = true;
            outGlobal.$w = null;
        } else {
            var componentArgs = out.$c;

            if (componentArgs) {
                out.$c = null;

                scope = componentArgs[0];

                if (scope) {
                    scope = scope.id;
                }

                var key = componentArgs[1];
                if (key != null) {
                    key = key.toString();
                }
                id = id || resolveComponentKey(out, key, scope);
                customEvents = componentArgs[2];
            }
        }

        var componentsContext = getComponentsContext(out);
        id = id || componentsContext.$__nextComponentId();

        if (registry.$__isServer) {
            component = registry.$__createComponent(
                renderingLogic,
                id,
                input,
                out,
                typeName,
                customEvents,
                scope);
            input = component.$__updatedInput;
            component.$__updatedInput = undefined; // We don't want $__updatedInput to be serialized to the browser
        } else {
            if (!component) {
                if (isRerender) {
                    // Look in in the DOM to see if a component with the same ID and type already exists.
                    component = componentLookup[id];
                    if (component &amp;&amp; component.$__type !== typeName) {
                        component = undefined;
                    }
                }

                if (component) {
                    isExisting = true;
                } else {
                    isExisting = false;
                    // We need to create a new instance of the component
                    component = registry.$__createComponent(typeName, id);

                    if (split) {
                        split = false;

                        var renderingLogicProps = typeof renderingLogic == 'function' ?
                            renderingLogic.prototype :
                            renderingLogic;

                        copyProps(renderingLogicProps, component.constructor.prototype);
                    }
                }

                // Set this flag to prevent the component from being queued for update
                // based on the new input. The component is about to be rerendered
                // so we don't want to queue it up as a result of calling `setInput()`
                component.$__updateQueued = true;

                if (customEvents !== undefined) {
                    component.$__setCustomEvents(customEvents, scope);
                }


                if (isExisting === false) {
                    emitLifecycleEvent(component, 'create', input, out);
                }

                input = component.$__setInput(input, onInput, out);

                if (isExisting === true) {
                    if (component.$__isDirty === false || component.shouldUpdate(input, component.$__state) === false) {
                        preserveComponentEls(component, out, componentsContext);
                        return;
                    }
                } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;div&gt;Total: ${helpers.formatCurrency(data.total))&lt;/div&gt;
```

### Allow dynamic custom tags/components to be used with `&lt;include&gt;` ([#139](https://github.com/marko-js/marko/issues/
139))

**Old:**
```html
&lt;invoke data.myComponent.<span class="apidocCodeKeywordSpan">renderer</span>({name: 'Frank'}, out)/&gt;
```

**New:**
```html
&lt;include(data.myComponent) name='Frank' /&gt;
```
or
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.specialElHandlers" id="apidoc.module.marko.specialElHandlers">module marko.specialElHandlers</a></h1>


    <h2>
        <a href="#apidoc.element.marko.specialElHandlers.INPUT" id="apidoc.element.marko.specialElHandlers.INPUT">
        function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>INPUT
        <span class="apidocSignatureSpan">(fromEl, toEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">INPUT = function (fromEl, toEl) {
    syncBooleanAttrProp(fromEl, toEl, 'checked');
    syncBooleanAttrProp(fromEl, toEl, 'disabled');

    if (fromEl.value != toEl.value) {
        fromEl.value = toEl.value;
    }

    if (!toEl.$__hasAttribute('value')) {
        fromEl.removeAttribute('value');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.specialElHandlers.OPTION" id="apidoc.element.marko.specialElHandlers.OPTION">
        function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>OPTION
        <span class="apidocSignatureSpan">(fromEl, toEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">OPTION = function (fromEl, toEl) {
    syncBooleanAttrProp(fromEl, toEl, 'selected');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.specialElHandlers.SELECT" id="apidoc.element.marko.specialElHandlers.SELECT">
        function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>SELECT
        <span class="apidocSignatureSpan">(fromEl, toEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SELECT = function (fromEl, toEl) {
    if (!toEl.$__hasAttribute('multiple')) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = toEl.firstChild;
        while(curChild) {
            if (curChild.$__nodeName == 'OPTION') {
                if (curChild.$__hasAttribute('selected')) {
                    selectedIndex = i;
                    break;
                }
                i++;
            }
            curChild = curChild.nextSibling;
        }

        fromEl.selectedIndex = i;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.specialElHandlers.TEXTAREA" id="apidoc.element.marko.specialElHandlers.TEXTAREA">
        function <span class="apidocSignatureSpan">marko.specialElHandlers.</span>TEXTAREA
        <span class="apidocSignatureSpan">(fromEl, toEl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TEXTAREA = function (fromEl, toEl) {
    var newValue = toEl.value;
    if (fromEl.value != newValue) {
        fromEl.value = newValue;
    }

    var firstChild = fromEl.firstChild;
    if (firstChild) {
        // Needed for IE. Apparently IE sets the placeholder as the
        // node value and vise versa. This ignores an empty update.
        var oldValue = firstChild.nodeValue;

        if (oldValue == newValue || (!newValue &amp;&amp; oldValue == fromEl.placeholder)) {
            return;
        }

        firstChild.nodeValue = newValue;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.tag_def_from_code" id="apidoc.module.marko.tag_def_from_code">module marko.tag_def_from_code</a></h1>


    <h2>
        <a href="#apidoc.element.marko.tag_def_from_code.extractTagDef" id="apidoc.element.marko.tag_def_from_code.extractTagDef">
        function <span class="apidocSignatureSpan">marko.tag_def_from_code.</span>extractTagDef
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractTagDef(code) {

    var startMatches = tagStartRegExp.exec(code);

    var tagDefStart;
    var tagDefEnd;

    if (startMatches) {
        tagDefStart = startMatches.index + startMatches[1].length;
        var nextTokenMatches;
        tokensRegExp.lastIndex = tagDefStart;
        var depth = 0;

        while ((nextTokenMatches = tokensRegExp.exec(code))) {
            if (nextTokenMatches[0] === '{') {
                depth++;
                continue;
            } else if (nextTokenMatches[0] === '}') {
                if (--depth === 0) {
                    tagDefEnd = tokensRegExp.lastIndex;
                    break;
                }
            }
            else if (nextTokenMatches[0] === ';') {
                tagDefEnd = nextTokenMatches.index;
                break;
            }
        }

        if (tagDefStart != null &amp;&amp; tagDefEnd != null) {
            var jsTagDef = code.substring(tagDefStart, tagDefEnd);
            var tagDefObject;

            try {
                // Try parsing it as JSON
                tagDefObject = JSON.parse(jsTagDef);
            } catch(e) {
                // Try parsing it as JavaScript
                try {
                    tagDefObject = eval('(' + jsTagDef + ')');
                } catch(e) {
                    tagDefObject = {};
                }
            }
            return tagDefObject;
        }
    } else {
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                continue;
            }
        }
    }

    if (!hasTagJson &amp;&amp; (tagDef.renderer || tagDef.template)) {
        let templateCode = fs.readFileSync(tagDef.renderer || tagDef.template, fsReadOptions);
        let extractedTagDef = tagDefFromCode.<span class="apidocCodeKeywordSpan">extractTagDef</span>(templateCode);
        if (extractedTagDef) {
            extend(tagDef, extractedTagDef);
        }
    }
}

let tagDependencyChain;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.tokenizer" id="apidoc.module.marko.tokenizer">module marko.tokenizer</a></h1>


    <h2>
        <a href="#apidoc.element.marko.tokenizer.create" id="apidoc.element.marko.tokenizer.create">
        function <span class="apidocSignatureSpan">marko.tokenizer.</span>create
        <span class="apidocSignatureSpan">(tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(tokens) {
    function getToken(matches) {
        for (var i=0; i&lt;tokens.length; i++) {
            let tokenValue = matches[i + 1];
            if (tokenValue != null) {
                var tokenDef = tokens[i];
                return {
                    start: matches.index,
                    end: matches.index + matches[0].length,
                    name: tokenDef.name,
                    value: tokenValue
                };
            }
        }
    }

    var tokensRegExp = new RegExp(tokens
        .map((token) =&gt; {
            return '(' + token.pattern.source + ')';
        })
        .join('|'), 'g');

    return {
        forEachToken: function(value, callback, thisObj) {
            tokensRegExp.lastIndex = 0; // Start searching from the beginning again
            var matches;
            while ((matches = tokensRegExp.exec(value))) {
                let token = getToken(matches);
                callback.call(this, token);
            }
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

_example.marko_
```marko
import scrollmonitor from 'scrollmonitor';

class {
    onMount() {
        this.watcher = scrollmonitor.<span class="apidocCodeKeywordSpan">create</span>(this.el);
        this.watcher.enterViewport(() =&gt; console.log('I have entered the viewport'));
        this.watcher.exitViewport(() =&gt; console.log('I have left the viewport'));
    }
}

// ...
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.types" id="apidoc.module.marko.types">module marko.types</a></h1>


    <h2>
        <a href="#apidoc.element.marko.types.Attribute" id="apidoc.element.marko.types.Attribute">
        function <span class="apidocSignatureSpan">marko.types.</span>Attribute
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Attribute {
    constructor(name) {
        this.name = name;
        this.type = null;
        this.required = false;
        this.type = null;
        this.allowExpressions = true;
        this.setFlag = null;
        this.pattern = null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


function loadAttributeFromProps(attrName, attrProps, dependencyChain) {
assert.ok(typeof attrName === 'string');
assert.ok(dependencyChain, '"dependencyChain" is required');

var attr = new types.<span class="apidocCodeKeywordSpan">Attribute</span>(attrName);

var attrLoader = new AttrLoader(attr, dependencyChain);

try {
    attrLoader.load(attrProps);
} catch(err) {
    throw createError('Unable to load attribute "' + attrName + '" (' + dependencyChain + '): &amp;#
x27; + err, err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.types.ImportedVariable" id="apidoc.element.marko.types.ImportedVariable">
        function <span class="apidocSignatureSpan">marko.types.</span>ImportedVariable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ImportedVariable {
    constructor() {
        this.targetProperty = null;
        this.expression = null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.types.NestedVariable" id="apidoc.element.marko.types.NestedVariable">
        function <span class="apidocSignatureSpan">marko.types.</span>NestedVariable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NestedVariable {
    constructor() {
        this.name = null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.types.Property" id="apidoc.element.marko.types.Property">
        function <span class="apidocSignatureSpan">marko.types.</span>Property
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Property {
    constructor() {
        this.name = null;
        this.type = 'string';
        this.value = undefined;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.types.Tag" id="apidoc.element.marko.types.Tag">
        function <span class="apidocSignatureSpan">marko.types.</span>Tag
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Tag{
    constructor(filePath) {
        this.filePath = filePath;
        if (filePath) {
            this.dir = path.dirname(filePath);
        }

        this.attributes = {};
        this.transformers = {};
        this.patternAttributes = [];

        // NOTE: We don't set this properties since
        //       it breaks merging of tags when the same
        //       tag is declared at multiple levels

        // this.taglibId = null;
        // this.taglibPath = null;
        // this.name = undefined;
        // this.renderer = null;
        // this.codeGeneratorModulePath = null;
        // this.nodeFactoryPath = null;
        // this.template = null;
        // this.nestedVariables = null;
        // this.importedVariables = null;
        // this.bodyFunction = null;
        // this.nestedTags = null;
        // this.isRepeated = null;
        // this.isNestedTag = false;
        // this.parentTagName = null;
        // this.openTagOnly = null;
        // this.body = null;
        // this.type = null; // Only applicable for nested tags
        // this._nodeFactory = undefined;
    }

    forEachVariable(callback, thisObj) {
        if (!this.nestedVariables) {
            return;
        }

        this.nestedVariables.vars.forEach(callback, thisObj);
    }

    forEachImportedVariable(callback, thisObj) {
        if (!this.importedVariables) {
            return;
        }

        forEachEntry(this.importedVariables, function (key, importedVariable) {
            callback.call(thisObj, importedVariable);
        });
    }

    forEachTransformer(callback, thisObj) {
        forEachEntry(this.transformers, function (key, transformer) {
            callback.call(thisObj, transformer);
        });
    }
    hasTransformers() {
<span class="apidocCodeCommentSpan">        /*jshint unused:false */
</span>        for (var k in this.transformers) {
            if (this.transformers.hasOwnProperty(k)) {
                return true;
            }

        }
        return false;
    }
    addAttribute(attr) {
        attr.filePath = this.filePath;

        if (attr.pattern) {
            this.patternAttributes.push(attr);
        } else {
            if (attr.name === '*') {
                attr.dynamicAttribute = true;

                if (attr.targetProperty === null || attr.targetProperty === '') {
                    attr.targetProperty = null;

                }
                else if (!attr.targetProperty) {
                    attr.targetProperty = '*';
                }
            }

            this.attributes[attr.name] = attr;
        }
    }
    toString() {
        return '[Tag: &lt;' + this.name + '@' + this.taglibId + '&gt;]';
    }
    forEachAttribute(callback, thisObj) {
        for (var attrName in this.attributes) {
            if (this.attributes.hasOwnProperty(attrName)) {
                callback.call(thisObj, this.attributes[attrName]);
            }
        }
    }
    getAttribute(attrName) {
        var attributes = this.attributes;

        // try by exact match first
        var attribute = attributes[attrName] || attributes['*'];

        if (attribute === undefined &amp;&amp; this.patternAttributes) {
            // try searching by pattern
            for (var i = 0, len = this.patternAttributes.length; i &lt; len; i++) {
                var patternAttribute = this.patternAttributes[i];
                if (patternAttribute.pattern.test(attrName)) {
                    attribute = patternAttribute;
                    break;
                }
            }
        }

        return attribute;
    }

    hasAttribute(attrName) {
        return this.attributes.hasOwnProperty(attrName);
    }

    addNestedVariable(nestedVariable) {
        if (!this.nestedVariables) {
            this.nestedVariables = {
                __noMerge: true,
                vars: []
            };
        }

        this.nestedVariables.vars.push(nestedVariable);
    }
    addImportedVariable(importedVariable) {
        if (!this.importedVariables) {
            this.importedVariables = {};
        }
        var key = importedVariable.targetProperty;
        this.i ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function createTaglib(filePath) {
    return new types.Taglib(filePath);
}

function loadTag(tagProps, filePath) {
    var tag = new types.<span class="apidocCodeKeywordSpan">Tag</span>(filePath);
    loaders.loadTagFromProps(tag, tagProps, new DependencyChain(filePath ? [filePath] : []));
    return tag;
}

exports.clearCache = clearCache;
exports.createTaglib = createTaglib;
exports.loadTaglibFromProps = loadTaglibFromProps;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.types.Taglib" id="apidoc.element.marko.types.Taglib">
        function <span class="apidocSignatureSpan">marko.types.</span>Taglib
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Taglib {
    constructor(filePath) {
        ok(filePath, '"filePath" expected');
        this.filePath = this.path /* deprecated */ = this.id = filePath;
        this.dirname = path.dirname(this.filePath);
        this.tags = {};
        this.textTransformers = [];
        this.transformers = [];
        this.attributes = {};
        this.patternAttributes = [];
        this.inputFilesLookup = {};
        this.imports = null;
        this.importsLookup = null;
    }

    addAttribute(attribute) {
        ok(attribute.key, '"key" is required for global attributes');

        attribute.filePath = this.filePath;

        if (!attribute.pattern &amp;&amp; !attribute.name) {
            throw new Error('Invalid attribute: ' + require('util').inspect(attribute));
        }

        this.attributes[attribute.key] = attribute;
    }
    getAttribute(name) {
        var attribute = this.attributes[name];
        if (!attribute) {
            for (var i = 0, len = this.patternAttributes.length; i &lt; len; i++) {
                var patternAttribute = this.patternAttributes[i];
                if (patternAttribute.pattern.test(name)) {
                    attribute = patternAttribute;
                }
            }
        }
        return attribute;
    }
    addTag(tag) {
        ok(arguments.length === 1, 'Invalid args');
        if (!tag.name) {
            throw new Error('"tag.name" is required: ' + JSON.stringify(tag));
        }
        this.tags[tag.name] = tag;
        tag.taglibId = this.id || this.path;
    }
    addTextTransformer(transformer) {
        this.textTransformers.push(transformer);
    }
    addTransformer(transformer) {
        this.transformers.push(transformer);
    }
    forEachTag(callback, thisObj) {
        forEachEntry(this.tags, function (key, tag) {
            callback.call(thisObj, tag);
        }, this);
    }

    addImport(path) {
        var importedTaglib = loaders.loadTaglibFromFile(path);
        handleImport(this, importedTaglib);
    }

    toJSON() {
        return {
            path: this.path,
            tags: this.tags,
            textTransformers: this.textTransformers,
            attributes: this.attributes,
            patternAttributes: this.patternAttributes,
            imports: this.imports
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function clearCache() {
    cache.clear();
}

function createTaglib(filePath) {
    return new types.<span class="apidocCodeKeywordSpan">Taglib</span>(filePath);
}

function loadTag(tagProps, filePath) {
    var tag = new types.Tag(filePath);
    loaders.loadTagFromProps(tag, tagProps, new DependencyChain(filePath ? [filePath] : []));
    return tag;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.types.Transformer" id="apidoc.element.marko.types.Transformer">
        function <span class="apidocSignatureSpan">marko.types.</span>Transformer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Transformer {
    constructor() {
        this.id = nextTransformerId++;
        this.name = null;
        this.tag = null;
        this.path = null;
        this.priority = null;
        this._func = null;
        this.properties = {};
    }

    getFunc() {
        if (!this.path) {
            throw new Error('Transformer path not defined for tag transformer (tag=' + this.tag + ')');
        }

        if (!this._func) {
            var transformer = markoModules.require(this.path);

            if (typeof transformer === 'function') {
                if (transformer.prototype.process) {
                    var Clazz = transformer;
                    var instance = new Clazz();
                    instance.id = this.id;
                    this._func = instance.process.bind(instance);
                } else {
                    this._func = transformer;
                }
            } else {
                this._func = transformer.process || transformer.transform;
            }
        }
        return this._func;
    }
    toString() {
        return '[Taglib.Transformer: ' + this.path + ']';
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * will be called on the compile-time Node. The transformer can manipulate
     * the AST using the DOM-like API to change how the code gets generated.
     */
    transformer(value) {
var tag = this.tag;
var dirname = this.dirname;

var transformer = new types.<span class="apidocCodeKeywordSpan">Transformer</span>();

if (typeof value === 'string') {
    // The value is a simple string type
    // so treat the value as the path to the JS
    // module for the transformer
    value = {
        path: value
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.update_manager" id="apidoc.module.marko.update_manager">module marko.update_manager</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.util" id="apidoc.module.marko.util">module marko.util</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.marko.vdom" id="apidoc.module.marko.vdom">module marko.vdom</a></h1>


    <h2>
        <a href="#apidoc.element.marko.vdom.Template" id="apidoc.element.marko.vdom.Template">
        function <span class="apidocSignatureSpan">marko.vdom.</span>Template
        <span class="apidocSignatureSpan">(path, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Template(path, func) {
    this.path = path;
    this._ = func;
    this.meta = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.marko.vdom.t" id="apidoc.element.marko.vdom.t">
        function <span class="apidocSignatureSpan">marko.vdom.</span>t
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTemplate(path) {
     return new Template(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_Compiled for VDOM output (browser-side):_

```javascript
var marko_attrs0 = {
      "class": "color"
    },
  marko_node0 = marko_createElement("div", null, 1, marko_const_nextId())
    .<span class="apidocCodeKeywordSpan">t</span>("No colors!");

function render(data, out) {
var colors = data.colors;

if (colors &amp;&amp; colors.length) {
  out.be("ul");
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>